<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on PINEAL.ME</title>
    <link>https://pineal.github.com/categories/algorithm/</link>
    <description>Recent content in Algorithm on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Sep 2018 09:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DP III - Knapsack Problems</title>
      <link>https://pineal.github.com/posts/dynamic_programming_iii/</link>
      <pubDate>Sat, 08 Sep 2018 09:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_iii/</guid>
      <description>

&lt;h1 id=&#34;背包问题&#34;&gt;背包问题&lt;/h1&gt;

&lt;h2 id=&#34;0-1-背包问题&#34;&gt;0-1 背包问题&lt;/h2&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;p&gt;Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays $values[0..n-1]$ and $weights[0..n-1]$ which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, &lt;strong&gt;find out the maximum value subset of $values[0..n-1]$ such that sum of the weights of this subset is smaller than or equal to W&lt;/strong&gt;. You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From: &lt;a href=&#34;https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/&#34;&gt;GeekforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;analyze&#34;&gt;Analyze&lt;/h3&gt;

&lt;p&gt;每件物品只有一个，那么考虑最后一个物品 $i$ ，一共就放或者不放两种状态选择。如果不放第 $i$ 件物品，那么问题转化为 前 $i-1$ 件物品放入到容量为 $j$ 的背包中, 即为 $M[i, j] = M[i-1, j]$。如果放第 $i$ 件物品，那么就是 前 $i-1$ 件物品放到容量为 $j-W_i$ 的背包中的 $value$ 加上把第 $i$ 件物品放入背包中的价值，即为 $M[i, j] = M[i-1, j - weights_i + values_i]$.&lt;/p&gt;

&lt;p&gt;此外，这个问题问得是得到的结果尽可能大，并不要求背包正好装满，初始化的时候都是 0。 如果要求恰好装满背包，那么除了 $M[0, 0]$ 初始化为 0 之外，其他都初始化为负无穷大。这样就可以保证最终的到的结果是一种恰好装满背包的最优解。&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(W + 1, 0));
    for (int i = 1; i &amp;lt;= n; i++) {
        for (int j = 1; j &amp;lt;= W; j++) {
            if (weights[i - 1] &amp;lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    return M.back().back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;space-optimization&#34;&gt;Space Optimization&lt;/h3&gt;

&lt;p&gt;如果对以上代码填表，可以更直观的显示出当前状态只跟上一行的状态有关。所以空间复杂度可以优化到 $O(n)$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;int&amp;gt; M(W + 1, 0);
    for (int i = 0; i &amp;lt; n; i++) {
        for (int j = W; j &amp;gt;= weights[i]; j--) {
            M[j] = max(M[j], values[i] + M[j - weights[i]]);
        }
    }
    return M.back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;print-all-items&#34;&gt;Print all items&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(W + 1, 0));
    //M[0][0] = 0;
    for (int i = 0; i &amp;lt;= n; i++) {
        for (int j = 0; j &amp;lt;= W; j++) {
            if (weights[i - 1] &amp;lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    int res =  M.back().back();
    for (int i = n; i &amp;gt; 0 &amp;amp;&amp;amp; res &amp;gt; 0; i--) {
        if (res == M[i-1][W])
            continue;
        else {
            cout &amp;lt;&amp;lt; weights[i-1] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        res -= values[i-1];
        W = W - weights[i-1];
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;house-robber&#34;&gt;House Robber&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() &amp;lt;= 2) {
            return max(nums[0], nums.back());
        }
        vector&amp;lt;int&amp;gt; M(nums.size(), 0);
        M[0] = nums[0];
        M[1] = max(nums[0], nums[1]);
        for (int i = 2; i &amp;lt; M.size(); i++) {
            M[i] = max(M[i - 2] + nums[i], M[i - 1]);
        }
        return M.back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完全背包问题&#34;&gt;完全背包问题&lt;/h2&gt;

&lt;p&gt;由于每个物品的数量变成了无限，那么从0-1背包问题转变过来，从取或者不取两种状态转换到了取0个，取1个到最多取 $k = \frac{Capacity}{weights[i]}$ 个。&lt;/p&gt;

&lt;h3 id=&#34;example-coin-change-ii&#34;&gt;Example - Coin Change II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount*amount)
//O(mn)
class Solution {
public:
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        /*
        M[i][j] =&amp;gt; the number of combinations to make up amount j with the first i types of coins
        M[i][j] =   M[i-1][j],                   use coins[i-1] 0 times
                  + M[i-1][j - coins[i-1]]       use coins[i-1] 1 time
                  + M[i-1][j- coins[i-1] * 2]    use coins[i-1] 2 times
                  + M[i-1][j- coins[i-1] * 3]    use coins[i-1] 3 times
                  ...
        */
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                M[i][j] = 0;
                for (int k = 0; k * coins[i - 1] &amp;lt;= j; k++) {
                    M[i][j] += M[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return M.back().back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;time-optimization&#34;&gt;Time Optimization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount)
//O(mn)
class Solution {
public:
    /*
        1.
        f[i][j] = f[i-1][j]
                + f[i-1][j - coins[i-1]]
                + f[i-1][j - coins[i-1] * 2]
                + f[i-1][j - coins[i-1] * 3]
                ...
        2.
        f[i][j - coins[i-1]]
                = f[i-1][j-coins[i-1]]
                + f[i-1][j-coins[i-1] * 2]
                + f[i-1][j-coins[i-1] * 3]
                ...
        3.
        f[i][j] = f[i-1][j]
                + f[i][j - coins[i-1]]
    */
    
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                M[i][j] = M[i-1][j] + (coins[i-1] &amp;lt;= j? M[i][j - coins[i - 1]] : 0);
            }
        }
        return M.back().back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;space-optimization-1&#34;&gt;Space Optimization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount)
//O(amount)
class Solution {
public:
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        vector&amp;lt;int&amp;gt; M(amount + 1, 0);
        M[0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                if (coins[i-1] &amp;lt;= j) {
                    M[j] += M[j - coins[i -1]];
                }
            }
        }
        return M.back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;minimum-number-of-refueling-stops&#34;&gt;Minimum Number of Refueling Stops&lt;/h3&gt;

&lt;p&gt;Recursive - LTE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; stations) {
        if (stations.empty()) return startFuel &amp;gt;= target? 0 : -1;
        stations.insert(stations.begin(), {0, startFuel});
        int res = INT_MAX;
        helper(0, res, 0, startFuel, stations, target);
        return res == INT_MAX? -1 : res;
    }
    
    
    void helper(int level, int &amp;amp; res, int num, int remain, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; stations, int target) {
        if (remain &amp;lt; 0) {
            return;
        }
        if (level == stations.size()) {            
            res = min(res, num);
            return;
        }
        int cost = (level == stations.size() - 1)? target - stations[level][0] : stations[level + 1][0] - stations[level][0];
        int refuel = (level == stations.size() - 1)? 0 : stations[level+1][1];
        if (cost &amp;lt;= remain) {
            helper(level + 1, res, num, remain - cost, stations, target);
            helper(level + 1, res, num + 1, remain - cost + refuel, stations, target);        
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DP knapsack solution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    // dp[i][j]: pick j stops to refill from [0, i] stops, how far away can we go
    // dp[i][j] = max {dp[i-1][j] &amp;gt;= stations[i-1][0] ? dp[i-1][j] : 0
    //          =      dp[i-1][j-1] &amp;gt;= stations[i-1][0] ? dp[i-1][j-1] + stations[i-1][1] : 0 }
    // 
    int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; stations) {
        int n = stations.size();
        vector&amp;lt;vector&amp;lt;long&amp;gt;&amp;gt; M(n+1, vector&amp;lt;long&amp;gt;(n+1, 0));
        
        M[0][0] = startFuel;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (startFuel &amp;gt;= stations[i-1][0])
                M[i][0] = startFuel;
        }
        
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 1; j &amp;lt;= i; j++) {
                if (M[i-1][j] &amp;gt;= stations[i-1][0]) {
                    M[i][j] = M[i-1][j];
                }
                if (M[i-1][j-1] &amp;gt;= stations[i-1][0]) {
                    M[i][j] = max(M[i][j], M[i-1][j-1] + stations[i-1][1]);
                }
                    
            }
        }
        for (int t = 0; t &amp;lt;= n; ++t)
            if (M[n][t] &amp;gt;= target) return t;
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO: space optimization&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf&#34;&gt;背包九讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZKAILBWl08g&#34;&gt;https://www.youtube.com/watch?v=ZKAILBWl08g&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming II</title>
      <link>https://pineal.github.com/posts/dynamic_programming_ii/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_ii/</guid>
      <description>

&lt;h2 id=&#34;coin-game-winner&#34;&gt;Coin game winner&lt;/h2&gt;

&lt;p&gt;A and B are playing a game. At the beginning there are n coins. Given two more numbers x and y. In each move a player can pick x or y or 1 coins. A always starts the game. The player who picks the last coin wins the game. For a given value of n, find whether A will win the game or not if both are playing optimally.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Input :  n = 5, x = 3, y = 4&lt;/li&gt;
&lt;li&gt;Output : A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are 5 coins, every player can pick 1 or
3 or 4 coins on his/her turn.
A can win by picking 3 coins in first chance.
Now 2 coins will be left so B will pick one
coin and now A can win by picking the last coin.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Input : 2 3 4&lt;/li&gt;
&lt;li&gt;Output : B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let us take few example values of n for x = 3, y = 4.
n = 0 A can not pick any coin so he losses
n = 1 A can pick 1 coin and win the game
n = 2 A can pick only 1 coin. Now B will pick 1 coin and win the game
n = 3 4 A will win the game by picking 3 or 4 coins
n = 5, 6 A will choose 3 or 4 coins. Now B will have to choose from 2 coins so A will win.&lt;/p&gt;

&lt;p&gt;We can observe that A wins game for n coins only when it loses for coins n-1, n-x and n-y.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool findWinner(int x, int y, int n) {
    vector&amp;lt;bool&amp;gt; M(n + 1, false);
    M[1] = true;
    for (int i = 2; i &amp;lt;= n; i++) {
        if (i - 1 &amp;gt;= 0 &amp;amp;&amp;amp; M[i - 1] == false) {
            M[i] = true;
        }
        else if (i - x &amp;gt;= 0 &amp;amp;&amp;amp; M[i - x] == false) {
            M[i] = true;
        }
        else if (i - y &amp;gt;= 0 &amp;amp;&amp;amp; M[i - y] == false) {
            M[i] = true;
        }
        cout &amp;lt;&amp;lt; M[i] &amp;lt;&amp;lt; endl;
    }
    return M.back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;coin-up-probablity&#34;&gt;Coin up probablity&lt;/h2&gt;

&lt;p&gt;有 $n$ 枚硬币，每个硬币掷一次正面朝上的概率各不相同，假定第$i$个概率为$p_i$。如果把所有硬币都掷一次，求 $k$ 个硬币正面朝上的概率。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$M[i][j]$  抛 j 个硬币有 i 个正面朝上的概率&lt;/li&gt;
&lt;li&gt;$M[i][j] = M[i][j-1] *(1 - P[i]) + M[i-1][j-1] * P[i]$&lt;/li&gt;
&lt;li&gt;求 $M[n][k]$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;predict-the-winner&#34;&gt;Predict the Winner&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/predict-the-winner/description/&#34;&gt;Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$M[i][j]$ 表示从index i 到 index j，player 1 比 player 2 取的数的总和多多少。
每次取的时候，要么取首个，即为$nums[i]$，那么对手的结果就可以用子问题 $M[i+1][j]$ 来表示，同理取最后一个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    bool PredictTheWinner(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int n = nums.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, 0));
        for (int i = 0; i &amp;lt; n; i++) {
            M[i][i] = nums[i];
        }
        for (int offset = 1; offset &amp;lt; n; offset++) {
            for (int i = 0; i &amp;lt; n - offset; i++) {
                int j = i + offset;
                M[i][j] = max(nums[i] - M[i+1][j], nums[j] - M[i][j-1]);    
            }   
        }
        return M.front().back() &amp;gt;= 0;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;can-i-win&#34;&gt;Can I Win&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/can-i-win/description/&#34;&gt;https://leetcode.com/problems/can-i-win/description/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        if (maxChoosableInteger &amp;gt;= desiredTotal) return true;
        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 &amp;lt; desiredTotal) return false;
        //from 1 to maxChoosableInteger -&amp;gt; ignore position 0
        //state[i] represent the chosen Integer i has been used in the game? t/f 
        string state(maxChoosableInteger + 1, &#39;f&#39;); 
        unordered_map&amp;lt;string, bool&amp;gt; memo;   //dfs memorization 
        return dfs(maxChoosableInteger, 0, desiredTotal, memo, state);
    }
    
    
    bool dfs(int max, int cur , int target, unordered_map&amp;lt;string, bool&amp;gt; &amp;amp; table, string &amp;amp; state) {
        if (table.count(state)) {
            return table[state];
        }
        for (int i = 1; i &amp;lt;= max; i++) {
            if (state[i] == &#39;f&#39;) {
                state[i] = &#39;t&#39;;
                //only if opponent is lost or current chosen number is bigger than target
                //the player win
                if (cur + i &amp;gt;= target || dfs(max, cur + i, target, table, state) == false) {
                    //recover visited state
                    state[i] = &#39;f&#39;;
                    table[state] = true;
                    return true;
                }
                state[i] = &#39;f&#39;;    
            }
        }
        table[state] = false;
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Shortest Path</title>
      <link>https://pineal.github.com/posts/shortest_path_problems/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/shortest_path_problems/</guid>
      <description>

&lt;h2 id=&#34;maze-i&#34;&gt;Maze I&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool hasPath(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; maze, vector&amp;lt;int&amp;gt; &amp;amp; start, vector&amp;lt;int&amp;gt; &amp;amp; dest) {
    const vector&amp;lt;int&amp;gt; dx = {0, -1, 1, 0};
    const vector&amp;lt;int&amp;gt; dy = {1, 0, 0, -1};
    queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
    q.emplace(start[0], start[1]);
    maze[start[0]][start[1]] = 2;
    int m = maze.size();
    int n = maze.front().size();
    while (!q.empty()) {
        auto cur = q.front();
        q.pop();
        int x = cur.first;
        int y = cur.second;
        if (x == dest[0] &amp;amp;&amp;amp; y == dest[1]) {
            return true;
        }

        for (int i = 0; i &amp;lt; 4; i++) {
            int xx = x;
            int yy = y;
            while (xx &amp;gt;= 0 &amp;amp;&amp;amp; xx &amp;lt; m &amp;amp;&amp;amp; yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; n &amp;amp;&amp;amp; maze[xx][yy] != 1) {
                xx += dx[i];
                yy += dy[i];
            }
            xx -= dx[i];
            yy -= dy[i];
            if (maze[xx][yy] == 0) {
                maze[xx][yy] = 2;
                q.emplace(xx, yy);
            }
        }
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maze-ii&#34;&gt;Maze II&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Position {
    int x, y, d;
    Position(int x, int y, int d): x(x), y(y), d(d) {}
};

class Solution {
public:
    int shortestDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; maze, vector&amp;lt;int&amp;gt;&amp;amp; start, vector&amp;lt;int&amp;gt;&amp;amp; dest) {
        if (maze.empty()) {
            return -1;
        }
        auto cmp = [](Position &amp;amp; p1, Position &amp;amp; p2) {return p1.d &amp;gt; p2.d;};
        priority_queue&amp;lt;Position, vector&amp;lt;Position&amp;gt;, decltype(cmp)&amp;gt; pq(cmp);
        pq.emplace(Position(start[0], start[1], 0));
        
        int m = maze.size();
        int n = maze.front().size();
        
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dis(m, vector&amp;lt;int&amp;gt;(n, INT_MAX));
        const vector&amp;lt;int&amp;gt; dx = {0, 1, -1, 0};
        const vector&amp;lt;int&amp;gt; dy = {1, 0, 0, -1};
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            int x = p.x;
            int y = p.y;
            int d = p.d;
            if (x == dest[0] &amp;amp;&amp;amp; y == dest[1]) {
                return d;
            }
            dis[x][y] = d;
            for (int i = 0; i &amp;lt; 4; i++) {
                int nx = x;
                int ny = y;
                int nd = d;
                while (nx + dx[i] &amp;lt; m &amp;amp;&amp;amp; nx + dx[i] &amp;gt;= 0 &amp;amp;&amp;amp; ny + dy[i] &amp;lt; n &amp;amp;&amp;amp; ny + dy[i] &amp;gt;= 0 
                       &amp;amp;&amp;amp; maze[nx + dx[i]][ny + dy[i]] == 0) {
                    nx += dx[i];
                    ny += dy[i];
                    nd++;
                }
                if (dis[nx][ny] &amp;gt; nd) {
                        dis[nx][ny] = nd;
                        pq.emplace(Position(nx, ny, nd));
                }
            }
        }
        return -1;   
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maze-iii&#34;&gt;Maze III&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct State
{
    int x;
    int y;
    int d;
    State (int x, int y, int d) : x(x), y(y), d(d) {}
};

const vector&amp;lt;int&amp;gt; dx = {1, -1, 0, 0};
const vector&amp;lt;int&amp;gt; dy = {0, 0, -1, 1};
const string dirs = &amp;quot;dulr&amp;quot;;
    
class Solution {
public:
    string findShortestWay(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; maze, vector&amp;lt;int&amp;gt;&amp;amp; ball, vector&amp;lt;int&amp;gt;&amp;amp; hole) {
        auto cmp = [](State &amp;amp; s1, State &amp;amp; s2) {
            return s1.d &amp;gt; s2.d;  
        };
        priority_queue&amp;lt;State, vector&amp;lt;State&amp;gt;, decltype(cmp)&amp;gt; pq(cmp);
        pq.emplace(ball[0], ball[1], 0);
        int m = maze.size();
        int n = maze.front().size();
        //dis[x][y]=&amp;gt;maintain the shortest distance to the source so far
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dis(m, vector&amp;lt;int&amp;gt;(n, INT_MAX));
        //dir[x][y]=&amp;gt;maintain the lexicographically smallest way from the source so far
        vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; way(m, vector&amp;lt;string&amp;gt;(n));
        while(!pq.empty()) {
            auto state = pq.top();
            pq.pop();
            int x = state.x;
            int y = state.y;
            int d = state.d;
            if (d &amp;gt; dis[x][y]) {
                continue;
            }
            string path = way[x][y];
            dis[x][y] = d;
            if (x == hole[0] &amp;amp;&amp;amp; y == hole[1]) {
                return way[x][y];
            }
            for (int i = 0; i &amp;lt; 4; i++) {
                int nx = x;
                int ny = y;
                int nd = d;
                string path = way[x][y] + dirs[i]; 
                while (nx + dx[i] &amp;lt; m &amp;amp;&amp;amp; nx + dx[i] &amp;gt;= 0 &amp;amp;&amp;amp; ny + dy[i] &amp;lt; n &amp;amp;&amp;amp; ny + dy[i] &amp;gt;= 0 
                       &amp;amp;&amp;amp; maze[nx + dx[i]][ny + dy[i]] == 0) {
                    nx += dx[i];
                    ny += dy[i];
                    nd++;
                    if (nx == hole[0] &amp;amp;&amp;amp; ny == hole[1]) {
                        break;
                    }
                }
                if (nd &amp;lt; dis[nx][ny]) {
                    dis[nx][ny] = nd;
                    way[nx][ny] = path;
                    pq.emplace(nx, ny, nd);
                }
                if (nd == dis[nx][ny]) {
                    if (path &amp;lt; way[nx][ny]) {
                        way[nx][ny] = path;
                    }
                }
            }
        }
        return &amp;quot;impossible&amp;quot;;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;leetcode-317-shortest-distance-from-all-buildings&#34;&gt;Leetcode 317: Shortest Distance from All Buildings&lt;/h2&gt;

&lt;p&gt;找到一个点，从他开始到所有的buildings的距离最短的和，中间有障碍物。对每个点做BFS，然后加起来求一个最小值。这样的时间复杂度是 $O(m*n)[BFS] * O(m*n)[matrix] = O(m^2*n^2)$。优化：从building开始搜。那么时间复杂度为$O(k*m*n)$。 $k$ 是 building 的个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int shortestDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        int res = INT_MAX;
        
        vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dis(grid.size(), vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;(grid[0].size()));    
        //dis[i][j].first =&amp;gt; total distance from k buildings to grid[i][j]
        //dis[i][j].second =&amp;gt; num of times search from k buildings and visited to grid[i][j] successfully (avoid dead end)
        int m = grid.size();
        int n = grid[0].size();
        int num_buildings = 0;
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                    num_buildings++;
                }
            }
        }
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (dis[i][j].second == num_buildings) {
                    res = min(res, dis[i][j].first);
                }
            }
        }
        return res == INT_MAX? -1 : res;
    }
    
    
    void bfs(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; grid, vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; &amp;amp; dis, int i, int j) {
        queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&amp;lt;deque&amp;lt;bool&amp;gt;&amp;gt; visited(m, deque&amp;lt;bool&amp;gt;(n, false));
        
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to building in grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &amp;lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y].first += level;
                    dis[x][y].second++;
                }
                for (const auto &amp;amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &amp;lt; m &amp;amp;&amp;amp; x_prime &amp;gt;= 0 &amp;amp;&amp;amp; y_prime &amp;lt; n &amp;amp;&amp;amp; y_prime &amp;gt;= 0 &amp;amp;&amp;amp; 
                        grid[x_prime][y_prime] == 0 &amp;amp;&amp;amp;
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
        
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;best-meeting-point&#34;&gt;Best Meeting Point&lt;/h2&gt;

&lt;p&gt;和上题一样的做法，只是可以在人所在的位置。做BFS标记visited的时候要注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minTotalDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        int res = INT_MAX;        
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dis(grid.size(), vector&amp;lt;int&amp;gt;(grid[0].size()));    
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                }
            }
        }
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                    res = min(res, dis[i][j]);
            }
        }
        return res == INT_MAX? -1 : res;        
    }
    void bfs(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; grid, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; dis, int i, int j) {
        queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&amp;lt;deque&amp;lt;bool&amp;gt;&amp;gt; visited(m, deque&amp;lt;bool&amp;gt;(n, false));
        visited[i][j] = true;
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &amp;lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y] += level;
                }
                for (const auto &amp;amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &amp;lt; m &amp;amp;&amp;amp; x_prime &amp;gt;= 0 &amp;amp;&amp;amp; y_prime &amp;lt; n &amp;amp;&amp;amp; y_prime &amp;gt;= 0 &amp;amp;&amp;amp; 
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
    }    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但超时啦。
答案里给的方法是算出median。并不适用有obstacle的情况（是嘛？）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Time:  O(mn)
// Space: O(m+n)
class Solution {
public:
    int minTotalDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        vector&amp;lt;int&amp;gt; x, y;
        for (int i = 0; i &amp;lt; grid.size(); ++i) {
            for (int j = 0; j &amp;lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    x.emplace_back(i);
                    y.emplace_back(j);
                }
            }
        }
        nth_element(x.begin(), x.begin() + x.size() / 2, x.end());
        nth_element(y.begin(), y.begin() + y.size() / 2, y.end());
        const int mid_x = x[x.size() / 2];
        const int mid_y = y[y.size() / 2];
        int sum = 0;
        for (int i = 0; i &amp;lt; grid.size(); ++i) {
            for (int j = 0; j &amp;lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    sum += abs(mid_x - i) + abs(mid_y - j);
                }
            }
        }
        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations&#34;&gt;数学证明参考链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nth_element()
把按 comparator 排序的有第n个数放在 n 的位置，前面的都比它“小”， 后面的都比它“大”。 但其他并不保证有序，时间复杂度 $O(n)$ 比 sort 好一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&#34;&gt;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-star&#34;&gt;A star&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&#34;&gt;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Depth first search in matrix</title>
      <link>https://pineal.github.com/posts/dfs/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dfs/</guid>
      <description>

&lt;h2 id=&#34;robot-room-cleaner&#34;&gt;Robot Room Cleaner&lt;/h2&gt;

&lt;p&gt;Given a robot cleaner in a room modeled as a grid.&lt;/p&gt;

&lt;p&gt;Each cell in the grid can be empty or blocked.&lt;/p&gt;

&lt;p&gt;The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.&lt;/p&gt;

&lt;p&gt;When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.&lt;/p&gt;

&lt;p&gt;Design an algorithm to clean the entire room using only the 4 given APIs shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Robot {
  // returns true if next cell is open and robot moves into the cell.
  // returns false if next cell is obstacle and robot stays on the current cell.
  boolean move();

  // Robot will stay on the same cell after calling turnLeft/turnRight.
  // Each turn will be 90 degrees.
  void turnLeft();
  void turnRight();

  // Clean the current cell.
  void clean();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reference: &lt;a href=&#34;https://leetcode.com/problems/robot-room-cleaner/description/&#34;&gt;Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * // This is the robot&#39;s control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *   public:
 *     // Returns true if the cell in front is open and robot moves into the cell.
 *     // Returns false if the cell in front is blocked and robot stays in the current cell.
 *     bool move();
 *
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     void turnLeft();
 *     void turnRight();
 *
 *     // Clean the current cell.
 *     void clean();
 * };
 */
class Solution {
public:
    int x = 0;
    int y = 0;
    int dir = 0;
    
    unordered_set&amp;lt;string&amp;gt; cleaned;
    int dx[4]={0, -1, 0, 1};    //define it anti-clockwisely
    int dy[4]={1, 0, -1, 0};    //N -&amp;gt; W -&amp;gt; S -&amp;gt; E
    
    void turnAround(Robot &amp;amp; r) {
        r.turnRight();
        r.turnRight();
    }
    
    void cleanRoom(Robot&amp;amp; robot) {
        string state = to_string(x) + &amp;quot; &amp;quot; + to_string(y);
        if (cleaned.count(state)) {
            return;
        }    
        
        cleaned.emplace(state);        
        robot.clean();
    
        //try 
        for (int i = 0; i &amp;lt; 4; i++) {
            if (robot.move()) {
                //record the current location
                x += dx[dir];
                y += dy[dir];
                //dfs goto next state
                cleanRoom(robot);
                //reset old location
                turnAround(robot);
                robot.move();
                x -= dx[dir];
                y -= dy[dir];                
                //reset old direction 
                turnAround(robot);
            }
            //make turn anti-clockwisely 
            // - we are going to try next direction 
            robot.turnLeft();
            //record the current direction
            dir = (dir + 1) % 4;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-random-maze&#34;&gt;Generate Random Maze&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Randomly generate a maze of size N * N (where N = 2K + 1) whose corridor and wall’s width are both 1 cell. For each pair of cells on the corridor, there must exist one and only one path between them. (Randomly means that the solution is generated randomly, and whenever the program is executed, the solution can be different.). The wall is denoted by 1 in the matrix and corridor is denoted by 0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assumptions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;N = 2K + 1 and K &amp;gt;= 0
the top left corner must be corridor
there should be as many corridor cells as possible
for each pair of cells on the corridor, there must exist one and only one path between them&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;N = 5, one possible maze generated is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0  0  0  1  0

    1  1  0  1  0

    0  1  0  0  0

    0  1  1  1  0

    0  0  0  0  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res, int x, int y) {
    int n = res.size();
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    random_shuffle(dirs.begin(), dirs.end());
    int xx, xxx, yy, yyy;
    xx = xxx = x;
    yy = yyy = y;
    for (const auto &amp;amp; dir : dirs) {
        int dx =dir.first;
        int dy = dir.second;
        xx = x + dx;
        xxx = x + dx * 2;
        yy = y + dy;
        yyy = y + dy * 2;

        if (xxx &amp;gt;= 0 &amp;amp;&amp;amp; xxx &amp;lt; n &amp;amp;&amp;amp; yyy &amp;gt;= 0 &amp;amp;&amp;amp; yyy &amp;lt; n &amp;amp;&amp;amp; res[xxx][yyy] != 0) {
            res[xxx][yyy] = 0;
            res[xx][yy] = 0;
            dfs(res, xxx, yyy);
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; generateRandomMaze(int n) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res(n, vector&amp;lt;int&amp;gt;(n, 1));
    dfs(res, 0, 0);
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Voting Algorithm</title>
      <link>https://pineal.github.com/posts/voting_algorithm/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/voting_algorithm/</guid>
      <description>

&lt;h2 id=&#34;majority-element&#34;&gt;Majority Element&lt;/h2&gt;

&lt;p&gt;俄罗斯方块的消除方式。出现两个不一样的消除：counter 减一。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A&lt;/li&gt;
&lt;li&gt;A B -&amp;gt; 消除&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int major;
        int count = 0;
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            if (count == 0) {
                major = nums[i];
                count++;
            } else {
                count += (nums[i] == major)? 1 : -1;
            }
        }
        return major;        
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;majority-element-ii&#34;&gt;Majority Element II&lt;/h2&gt;

&lt;p&gt;同理：俄罗斯方块的消除方式，当出现三个不一样的时候消除。
要注意的是，最后得到的candidate，需要再过一遍数组来确定是不是最后的答案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int x = 0;
        int y = 1;
        //just need to be different test with case [0,0,0,0,0,0]
        int cnt1 = 0;
        int cnt2 = 0;
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            if (nums[i] == x) {
                cnt1++;
            } else if (nums[i] == y) {
                cnt2++;
            } else if (cnt1 == 0) {
                x = nums[i];
                cnt1++;
            } else if (cnt2 == 0) {
                y = nums[i];
                cnt2++;
            }  else {
                cnt1--;
                cnt2--;
            }
        }
        cnt1 = 0, cnt2 = 0;
        for (int i = 0; i &amp;lt; nums.size(); i++) {
            if (nums[i] == x) {
                cnt1++;
            } else if (nums[i] == y) {
                cnt2++;
            }
        }
        vector&amp;lt;int&amp;gt; rst;
        if (cnt1 &amp;gt; nums.size() / 3) {
            rst.emplace_back(x);
        }
        if (cnt2 &amp;gt; nums.size() / 3) {
            rst.emplace_back(y);
        }
        return rst;
    } 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;majority-element-iii&#34;&gt;Majority Element III&lt;/h2&gt;

&lt;p&gt;More than 1/k&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming I</title>
      <link>https://pineal.github.com/posts/dynamic_programming_i/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_i/</guid>
      <description>

&lt;h2 id=&#34;max-product-of-cutting-rope&#34;&gt;Max Product Of Cutting Rope&lt;/h2&gt;

&lt;p&gt;Given a rope with positive integer-length n, how to cut the rope into m integer-length parts with length $p[0], p[1], &amp;hellip;,p[m-1]$, in order to get the maximal product of $p[0]p[1] &amp;hellip; p[m-1]$? m is determined by you and must be greater than 0 (at least one cut must be made). Return the max product you can have.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;n = 12, the max product is 3 * 3 * 3 * 3 = 81 (cut the rope into 4 pieces with length of each is 3).&lt;/p&gt;

&lt;h3 id=&#34;top-down-recursion&#34;&gt;Top-Down Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    if (length &amp;lt;= 2) {
      return 1;
    }
    int res = 0;
    for (int i = 1; i &amp;lt; length - 1; i++) {
      res = max(res, max(length - i, maxProduct(length - i)) * i);
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-down-recursion-memorization&#34;&gt;Top-Down Recursion + Memorization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    if (length &amp;lt;= 2) {
      return 1;
    }
    vector&amp;lt;int&amp;gt; M(length + 1, 0);
    return maxProductHelper(length, M);
  }
  
  int maxProductHelper(int length, vector&amp;lt;int&amp;gt; &amp;amp; M) {
    if (M[length]) {
      return M[length];
    }
    int res = 0;
    for (int i = 1; i &amp;lt; length - 1; i++) {
      res = max(res, max(length - i, maxProductHelper(length - i, M)) * i);
    }
    M[length] = res;
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-dp-solution&#34;&gt;Bottom-up DP Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    vector&amp;lt;int&amp;gt; M(length + 1, 0);
    //M[i] =&amp;gt; max product of first i length rope
    for (int i = 1; i &amp;lt; length + 1; i++) {
      for (int j = 0; j &amp;lt; i; j++) {
        M[i] = max(M[i], max(j, M[j])/*take care of corner case*/ * (i - j));
      }
    }
    return M.back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cut-rope-ii&#34;&gt;Cut rope II&lt;/h2&gt;

&lt;p&gt;There is a wooden stick with length L &amp;gt;= 1, we need to cut it into pieces, where the cutting positions are defined in an int array A. The positions are guaranteed to be in ascending order in the range of $[1, L - 1]$. The cost of each cut is the length of the stick segment being cut. Determine the minimum total cost to cut the stick into the defined pieces.&lt;/p&gt;

&lt;h3 id=&#34;top-down-recursion-1&#34;&gt;Top-Down Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    return helper(0, cuts.size() - 1, cuts);
  }
  
  int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; cuts) {
    if (start + 1 == end) {
      return 0;
    }
 
    int res = INT_MAX;
    for (int k = start + 1; k &amp;lt; end; k++) {
      res = min(res, helper(start, k, cuts) + 
                cuts[end] - cuts [start] + 
                helper(k, end, cuts));
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-down-recursion-memorization-1&#34;&gt;Top-Down Recursion + Memorization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    int n = cuts.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    return helper(0, n - 1, cuts, M);
  }

  int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; cuts, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; M) {
    if (start + 1 == end) {
      return 0;
    }
    if (M[start][end] != INT_MAX) {
      return M[start][end];
    } 
    int res = INT_MAX;
    for (int k = start + 1; k &amp;lt; end; k++) {
      res = min(res, helper(start, k, cuts, M) + 
                cuts[end] - cuts [start] + 
                helper(k, end, cuts, M));
    }
    M[start][end] = res;
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    int n = cuts.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    for (int right = 1; right &amp;lt; n; right++) {
      for (int left = right - 1; left &amp;gt;= 0; left--) {
        if (left + 1 == right) {
          M[left][right] = 0;
        }
        else {
          for (int k = left + 1; k &amp;lt;= right - 1; k++) {
            M[left][right] = min(M[left][right],
                          M[left][k] + M[k][right] + cuts[right] - cuts[left]);            
          }
        }
      }
    }
    return M.front().back();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;merge-stone&#34;&gt;Merge Stone&lt;/h2&gt;

&lt;p&gt;We have a list of piles of stones, each pile of stones has a certain weight, represented by an array of integers. In each move, we can merge two adjacent piles into one larger pile, the cost is the sum of the weights of the two piles. We merge the piles of stones until we have only one pile left. Determine the minimum total cost.&lt;/p&gt;

&lt;p&gt;stones is not null and is length of at least 1&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;{4, 3, 3, 4}, the minimum cost is 28&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;merge first 4 and first 3, cost 7&lt;/li&gt;
&lt;li&gt;merge second 3 and second 4, cost 7&lt;/li&gt;
&lt;li&gt;merge two 7s, cost 14&lt;/li&gt;
&lt;li&gt;total cost = 7 + 7 + 14 = 28&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recursion-memo&#34;&gt;Recursion + memo&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; stones) {
    return helper(0, stones.size() - 1, stones);
  }
  
  int helper(int left, int right, const vector&amp;lt;int&amp;gt; &amp;amp; stones) {
    if (left == right) {
      return 0;
    }
    if (left + 1 == right) {
      return stones[left] + stones[right];
    }
    
    int sum = 0;
    for (int i = left; i &amp;lt;= right; i++) {
      sum += stones[i];
    }
    
    int res = INT_MAX;
    for (int k = left; k &amp;lt;= right - 1; k++) {
      res = min(res, 
                helper(left, k, stones) + helper(k + 1, right, stones) + sum);
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming-1&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; stones) {
    int n = stones.size();
    //sum[i] ==&amp;gt; sum from stones[0] to stones[i]
    vector&amp;lt;int&amp;gt; sums(n);
    for (int i = 0; i &amp;lt; stones.size(); i++) {
      if (i == 0) {
        sums[i] = stones[i];
      }
      else {
        sums[i] = sums[i - 1] + stones[i];
      }
    }
    //M[i][j] =&amp;gt; min cost from stones[i] to stones[j]
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    for (int right = 0; right &amp;lt; n; right++) {
      for (int left = right; left &amp;gt;= 0; left--) {
        int sum = left == 0? sums[right] : sums[right] - sums[left - 1];
        if (left == right) {
          M[left][right] = 0;
          continue;
        }
        //k =&amp;gt; last stone to merge
        for (int k = left; k &amp;lt;= right; k++) {
          int rightsub = k == right? 0 : M[k + 1][right];
          M[left][right] = min(M[left][right], 
                               M[left][k] + sum + (k == right? 0 : M[k + 1][right]));
        }
      }    
    }
    return M.front().back();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;burst-bsllons&#34;&gt;Burst Bsllons&lt;/h2&gt;

&lt;p&gt;Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get $nums[left] * nums[i] * nums[right]$ coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.&lt;/p&gt;

&lt;p&gt;Find the maximum coins you can collect by bursting the balloons wisely.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;You may imagine $nums[-1] = nums[n] = 1$. They are not real therefore you can not burst them.&lt;/p&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Input: {3,1,5,8}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nums = {3,1,5,8} &amp;ndash;&amp;gt; {3,5,8} &amp;ndash;&amp;gt;   {3,8}   &amp;ndash;&amp;gt;  {8}  &amp;ndash;&amp;gt; {}&lt;/li&gt;
&lt;li&gt;coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recursion&#34;&gt;Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        return helper(0, nums.size() - 1, nums);
    }
    
    int helper(int start, int end, vector&amp;lt;int&amp;gt; &amp;amp; nums) {
        if (start + 1 == end) {
            return 0;
        }
        int res = 0;
        for (int i = start + 1; i &amp;lt; end; i++) {
            res = max(res, 
                      helper(start, i, nums) + 
                      nums[start] * nums[i] * nums[end] + 
                      helper(i, end, nums));
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursion-memo-1&#34;&gt;Recursion + Memo&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        int n = nums.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, 0));
        return helper(0, nums.size() - 1, nums, M);
    }
    
    int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; M) {
        if (start + 1 == end) {
            return 0;
        }
        if (M[start][end]) {
            return M[start][end];
        }
        int res = 0;
        for (int i = start + 1; i &amp;lt; end; i++) {
            res = max(res, 
                      helper(start, i, nums, M) + 
                      nums[start] * nums[i] * nums[end] + 
                      helper(i, end, nums, M));
        }
        M[start][end] = res;
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming-2&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        int n = nums.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, 0));

        for (int right = 2; right &amp;lt; n; right++) {
            for (int left = right - 2; left &amp;gt;= 0; left--) {
                for (int k = left + 1; k &amp;lt; right; k++) {
                    M[left][right] = max(M[left][right],
                                        M[left][k] + nums[left] * nums[k] * nums[right] + M[k][right]);
                }
            }
        }
        return M[0][n - 1];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Topics on Gragh Algorithm</title>
      <link>https://pineal.github.com/posts/graph_algorithms/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/graph_algorithms/</guid>
      <description>

&lt;h1 id=&#34;graph&#34;&gt;Graph&lt;/h1&gt;

&lt;h2 id=&#34;graph-representing&#34;&gt;Graph Representing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-and-its-representations/&#34;&gt;https://www.geeksforgeeks.org/graph-and-its-representations/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs&#34;&gt;https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;adjacent-matrix&#34;&gt;Adjacent Matrix&lt;/h3&gt;

&lt;h3 id=&#34;adjacent-list&#34;&gt;Adjacent List&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/&#34;&gt;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/&#34;&gt;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;edges&#34;&gt;Edges&lt;/h3&gt;

&lt;h2 id=&#34;traversal&#34;&gt;Traversal&lt;/h2&gt;

&lt;h3 id=&#34;bfs&#34;&gt;BFS&lt;/h3&gt;

&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pacific Atlantic Water Flow&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;start from matrix&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;start from occean&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone Graph
follow up: reverse if DAG&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;topological-sorting&#34;&gt;Topological Sorting&lt;/h2&gt;

&lt;h3 id=&#34;dfs-method&#34;&gt;DFS method&lt;/h3&gt;

&lt;p&gt;拓扑排序的常规方法是用DFS。DFS 有一个好处就是可以 backtracking 到所有的 solution。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/topological-sorting/&#34;&gt;https://www.geeksforgeeks.org/topological-sorting/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bfs-1&#34;&gt;BFS&lt;/h3&gt;

&lt;p&gt;另一个方法 Kahn’s algorithm 用记录入度/出度的方式进行BFS, 相对容易记忆和实现&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/&#34;&gt;https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;More questions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule&#34;&gt;Course Schedule&lt;/a&gt; | &lt;a href=&#34;https://github.com/pineal/Leetcode_OJ/blob/master/cpp/207_Course_Schedule.cpp&#34;&gt;Solution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule-ii&#34;&gt;Course Schedule II&lt;/a&gt; | &lt;a href=&#34;https://github.com/pineal/Leetcode_OJ/blob/master/cpp/210_Course_Schedule_II.cpp&#34;&gt;Solution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sequence-reconstruction&#34;&gt;Sequence Reconstruction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-increasing-path-in-a-matrix&#34;&gt;Longest Increasing Path in a Matrix&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/alien-dictionary&#34;&gt;Alien Dictionary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/&#34;&gt;All Topological sorts of a DAG&lt;/a&gt; | should use DFS&lt;/p&gt;

&lt;h2 id=&#34;connected-component&#34;&gt;Connected Component&lt;/h2&gt;

&lt;h3 id=&#34;connected-components-for-undirected-graph&#34;&gt;Connected components for undirected graph&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/&#34;&gt;Number of Connected Components&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;strongly-connected-components&#34;&gt;Strongly Connected Components&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/strongly-connected-components/&#34;&gt;https://www.geeksforgeeks.org/strongly-connected-components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/&#34;&gt;https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/connectivity-in-a-directed-graph/&#34;&gt;https://www.geeksforgeeks.org/connectivity-in-a-directed-graph/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;shortest-path&#34;&gt;Shortest Path&lt;/h2&gt;

&lt;h3 id=&#34;shortest-distance-in-adjacent-table-bfs&#34;&gt;Shortest distance in adjacent table - BFS&lt;/h3&gt;

&lt;p&gt;Best Meeting Point&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/shortest-distance-from-all-buildings/description/&#34;&gt;Shortest Distance from All Buildings&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&#34;&gt;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-star&#34;&gt;A star&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&#34;&gt;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;iterative-deepening-search-ids-or-iterative-deepening-depth-first-search-iddfs&#34;&gt;Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/&#34;&gt;https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;bipartite&#34;&gt;Bipartite&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/is-graph-bipartite&#34;&gt;Is Graph Bipartite&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Basic Backtracking Problems</title>
      <link>https://pineal.github.com/posts/backtracking/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/backtracking/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Backtracking 类型的题目最重要的是想清楚每一层在做什么，以及到下一层一共有几个分叉。&lt;/p&gt;

&lt;p&gt;时间复杂度： branch factor ^ level&lt;/p&gt;

&lt;p&gt;时间复杂度： call stack -&amp;gt; level&lt;/p&gt;

&lt;h2 id=&#34;subsets&#34;&gt;Subsets&lt;/h2&gt;

&lt;p&gt;这一类的题目的框架为，在递归树中的第 i 层，代表正在处理 nums 里的第 i 个元素。 从该层的父节点一定会伸展出两个分叉： 第一个分叉代表着一层会放这个元素，第二个分叉代表不放这个元素。 这样出来的递归树非常平衡。&lt;/p&gt;

&lt;h3 id=&#34;subsets-i-http-www-lintcode-com-en-problem-subsets&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        sort(nums.begin(), nums.end());
        vector&amp;lt;int&amp;gt; cur;
        dfs(rst, cur, nums, 0);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; rst, vector&amp;lt;int&amp;gt; &amp;amp; cur, const vector&amp;lt;int&amp;gt;&amp;amp; nums, int level) {
        if (level == nums.size()) {
            rst.emplace_back(cur);
            return;
        }
        cur.emplace_back(nums[level]);
        dfs(rst, cur, nums, level + 1);
        cur.pop_back();
        dfs(rst, cur, nums, level + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subsets-ii-dedup-http-www-lintcode-com-en-problem-subsets-ii&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II - Dedup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;去重首先需要排序，要利用有序性。从递归树上看的话，放的那一个分支不变，因为我们是先做放元素，再走不放该元素的。如果不放该元素，那么此时的结果会跟父节点的是重复的。ab1 -&amp;gt; ab1b2, ab1。  a -&amp;gt; ab2, a。 ab1 和 ab2 不能同时出现。 所以这个分支就需要直接跳到跟当前层元素不同的那一层。在代码上体现就是level++。&lt;/p&gt;

&lt;p&gt;ab1 ab2 出发产生的分支都是完全一样的。那么我们可以去掉ab2。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; cur;
        sort(nums.begin(), nums.end());
        dfs(rst, nums, 0, cur);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; result, vector&amp;lt;int&amp;gt; &amp;amp; nums, int level, vector&amp;lt;int&amp;gt; &amp;amp; cur) {
        if (level == nums.size()) {
            result.emplace_back(cur);
            return;
        }
        
        cur.emplace_back(nums[level]);
        dfs(result, nums, level + 1, cur);
        cur.pop_back();
        //pruning techniques
        while (level &amp;lt; nums.size() - 1 &amp;amp;&amp;amp; nums[level] == nums[level+1]) {
            level++;
        }                
        dfs(result, nums, level + 1, cur);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variant-i-combination&#34;&gt;Variant I - Combination&lt;/h3&gt;

&lt;p&gt;整体框架跟 Subset I 一模一样， 唯一的区别是 base case return 的时候加上条件： 当前结果的长度为 k 才返回。
原题链接：&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;去重的方法也应该和 Subset II 一样。&lt;/p&gt;

&lt;h3 id=&#34;variant-ii-permutations-of-inserting-spaces-into-a-string&#34;&gt;Variant II - Permutations of inserting spaces into a string&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&#34;&gt;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还有别的问法，比如如何分一个给定的数组成两部分，两部分的和相同。或者要在一串数组/字符串里面插入。&lt;/li&gt;
&lt;li&gt;时间复杂度是$O(2^n)$&lt;/li&gt;
&lt;li&gt;另一种常见做法：k层，每层的意义为最后的结果钟第几个元素应该是什么。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;permutations&#34;&gt;Permutations&lt;/h2&gt;

&lt;p&gt;因为全排列需要全部元素都出现，唯一不同的是他们的顺序，那么我们可以不停两两交换数组中的元素，得到全排列。&lt;/p&gt;

&lt;p&gt;Time n * (n-1) * (n - 2) = O(n!)&lt;/p&gt;

&lt;p&gt;Space O(n)&lt;/p&gt;

&lt;p&gt;如果要求 一个长度不变的array/string 的 permutation 只是 order 不一样，就可以考虑用 swap-swap 的方法。&lt;/p&gt;

&lt;h3 id=&#34;permutations-i&#34;&gt;Permutations I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
  if (input == &amp;quot;&amp;quot;) {
    return {&amp;quot;&amp;quot;};
  }
  vector&amp;lt;string&amp;gt; result;
  helper(result, input, 0);
  return result;
  }
  
private:
  void swap(string &amp;amp;s, int i, int j) {
    auto temp = s[i];
    s[i] = s[j];
    s[j] = temp;
  }

  void helper(vector&amp;lt;string&amp;gt; &amp;amp; result, string &amp;amp; s, int index) {
    if (index == s.size()){
      result.emplace_back(s);
      return;
    }
    for (int i = index; i &amp;lt; s.size(); i++) {
      swap(s, i, index);
      helper(result, s, index + 1);
      swap(s, i, index);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;permutations-ii-dedup&#34;&gt;Permutations II - Dedup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
    vector&amp;lt;string&amp;gt; result;
    helper(input, result, 0);
    return result;
  }
  
private:
  void helper(string &amp;amp; input, vector&amp;lt;string&amp;gt; &amp;amp; result, int level) {
    if (level == input.size()) {
        result.emplace_back(input);
        return;
    }
    
    set&amp;lt;char&amp;gt; charset;
    for (int i = level; i &amp;lt; input.size(); ++i) {
      if (charset.find(input[i]) != charset.end()) {
        continue;
      }
      charset.emplace(input[i]);
      swap(input[i], input[level]);
      helper(input, result, level + 1);
      swap(input[i], input[level]);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parenthesis-problems&#34;&gt;Parenthesis Problems&lt;/h2&gt;

&lt;h3 id=&#34;valid&#34;&gt;Valid&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Given N pairs of parentheses “()”, return a list with all the valid permutations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void validParenthesisHelper(int l, int r, int n, string &amp;amp; cur, vector&amp;lt;string&amp;gt; &amp;amp; res) {
    if (l + r ==  2 * n) {
        res.emplace_back(cur);
        return;
    }
    
    if (l &amp;lt; n) {
        cur += &amp;quot;(&amp;quot;;
        validParenthesisHelper(l + 1, r, n, cur, res);
        cur.pop_back();
    }
    
    if (r &amp;lt; l) {
        cur += &amp;quot;)&amp;quot;;
        validParenthesisHelper(l, r + 1, n, cur, res);
        cur.pop_back();
    }
}

vector&amp;lt;string&amp;gt; validParenthesis(int n) {
    vector&amp;lt;string&amp;gt; res;
    string cur;
    validParenthesisHelper(0, 0, n, cur, res);
    return res;
}

void testvalidParenthesis() {
    auto res = validParenthesis(3);
    for (const auto &amp;amp; str : res) {
        cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time: O(2^2n)
Space: O(2n)&lt;/p&gt;

&lt;h2 id=&#34;coin-combinations&#34;&gt;Coin Combinations&lt;/h2&gt;

&lt;h3 id=&#34;99-cents&#34;&gt;99 Cents&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&#34;&gt;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void coinCombinationHelper(const vector&amp;lt;int&amp;gt; &amp;amp; coins,
                           vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res,
                           vector&amp;lt;int&amp;gt; &amp;amp; cur,
                           int remaining,
                           int level) {
    if (level == coins.size()) {
        if (remaining == 0) {
            res.emplace_back(cur);
        }
        return;
    }

    int n = remaining/coins[level];
    for (int i = 0; i &amp;lt;= n; i++) {
        cur.emplace_back(i);
        coinCombinationHelper(coins, res, cur, remaining - i * coins[level], level + 1);
        cur.pop_back();
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; coinCombination(const vector&amp;lt;int&amp;gt; &amp;amp; coins, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; cur;
    coinCombinationHelper(coins, res, cur, target, 0);
    return res;
}

void testCoinsCombination() {
    vector&amp;lt;int&amp;gt; coins = {25, 10, 5, 1};
    auto res = coinCombination(coins, 99);
    for (const auto &amp;amp; v : res) {
        for (const auto &amp;amp; c : v) {
            cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;find-all-valid-combinations-of-factors-that-form-an-integer&#34;&gt;find all valid combinations of factors that form an integer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&#34;&gt;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;backtracking-on-tree&#34;&gt;Backtracking on Tree&lt;/h2&gt;

&lt;h3 id=&#34;longest-consecutive-sequence&#34;&gt;Longest consecutive sequence&lt;/h3&gt;

&lt;p&gt;int global_max = INT_MIN;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int helper(TreeNode* root) {
  if (root == nullptr) {
    return 0;
  }

  int left = 0;
  int right = 0;

  if (root-&amp;gt;left &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;val -1 == root-&amp;gt;val) {
    left = helper(root-&amp;gt;left);
  } 
  if (root-&amp;gt;right &amp;amp;&amp;amp; root-&amp;gt;right-&amp;gt;val -1 == root-&amp;gt;val) {
    right = helper(root-&amp;gt;right);
  } 
  int local_max = max(left, right) + 1;
  global_max = max(global_max, local_max)l
  return local_max;

} 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Extended Kalman Filter</title>
      <link>https://pineal.github.com/posts/extended_kalman_filter/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/extended_kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;review-of-kalman-filter&#34;&gt;Review of Kalman filter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pineal.github.io/2015/03/Kalman-Filter/]&#34;&gt;Previous post on basic kalman filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ilectureonline.com/lectures/subject/SPECIAL%20TOPICS/26/190&#34;&gt;iLecture lessons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Distribution of Gausion is not Gaussian, it becomes non-linear&lt;/p&gt;

&lt;p&gt;Extented Kalman filter uses a linear approximation of h(x)
Here we use first order taylor expansion to&lt;/p&gt;

&lt;p&gt;Given a function f(x), a taylor series expansion could be expressed:&lt;/p&gt;

&lt;p&gt;$$f(x) \approx \frac{\partial{f(\mu)} }{\partial{x}}(x - \mu)$$&lt;/p&gt;

&lt;h2 id=&#34;multivariate-taylor-series&#34;&gt;Multivariate Taylor Series&lt;/h2&gt;

&lt;h2 id=&#34;design-kalman-filter-for-1d-tracking-problem&#34;&gt;Design Kalman Filter for 1D tracking problem&lt;/h2&gt;

&lt;p&gt;We need to define two linear functions:
1. state transition function
2. measurement function&lt;/p&gt;

&lt;h3 id=&#34;state-transition-function&#34;&gt;State transition function&lt;/h3&gt;

&lt;p&gt;$$ x&amp;rsquo; = F * x + noise $$&lt;/p&gt;

&lt;p&gt;where,&lt;/p&gt;

&lt;p&gt;$$F = \begin{pmatrix}
        1 &amp;amp; \Delta{t}  \\ 0 &amp;amp; 1
      \end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;$$x = \begin{pmatrix} p \\ v\end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;postion $p$ is linear motion model, calculation is:&lt;/p&gt;

&lt;p&gt;$$p&amp;rsquo; = p + v * \Delta{t}$$&lt;/p&gt;

&lt;p&gt;Thus We can express it in a matrix form:&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;h1 id=&#34;begin-pmatrix-p-v-end-pmatrix&#34;&gt;\begin{pmatrix} p&amp;rsquo; \\ v&amp;rsquo; \end{pmatrix}&lt;/h1&gt;

&lt;p&gt;\begin{pmatrix}
        1 &amp;amp; \Delta{t} \\ 0 &amp;amp; 1
\end{pmatrix}
\begin{pmatrix} p \\ v\end{pmatrix}
$$&lt;/p&gt;

&lt;h3 id=&#34;measurement-update-function&#34;&gt;Measurement Update function&lt;/h3&gt;

&lt;p&gt;At time $t$, the belief is represented by the mean $\mu_t$ and the covariance $\Sigma_t$.&lt;/p&gt;

&lt;h4 id=&#34;process-model&#34;&gt;Process Model&lt;/h4&gt;

&lt;p&gt;The state transition probability $p(x_t \mid u&lt;em&gt;t, x&lt;/em&gt;{t-1})$ must be a linear functoin in its arguments with added Gaussian noise. This is expressed by the following equation:&lt;/p&gt;

&lt;p&gt;$$x_t = A&lt;em&gt;tx&lt;/em&gt;{t-1} + B_tu_t + \epsilon_t$$&lt;/p&gt;

&lt;h4 id=&#34;measurement-model&#34;&gt;Measurement Model&lt;/h4&gt;

&lt;p&gt;The measurement probability $p(z_t \mid x_t)$ must also be linear in its arguments, with added Gaussian noise:&lt;/p&gt;

&lt;p&gt;$$z_t = C_tx_t + \delta_t$$&lt;/p&gt;

&lt;h4 id=&#34;kalman-filter-algorithm&#34;&gt;Kalman Filter Algorithm&lt;/h4&gt;

&lt;p&gt;$$\bar\mu_t  = A&lt;em&gt;t\mu&lt;/em&gt;{t-1} + B_tu_t$$&lt;/p&gt;

&lt;p&gt;$$\bar\Sigma_t = A&lt;em&gt;t\Sigma&lt;/em&gt;{t-1} + R_t $$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cache Design</title>
      <link>https://pineal.github.com/posts/cache_design/</link>
      <pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/cache_design/</guid>
      <description>

&lt;h1 id=&#34;cache-design&#34;&gt;Cache Design&lt;/h1&gt;

&lt;h2 id=&#34;lru&#34;&gt;LRU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1-SMH7LNov8UM8BuCKMJGTQ523GnK5Td02qqX-E0LWQk/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;
&lt;/iframe&gt;

&lt;h2 id=&#34;lfu&#34;&gt;LFU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1B_BeXdSxWUKpag_fWd_4laL8HVRmXZ5KU8prgOWIxB8/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;
&lt;/iframe&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/tree/master/Cache%20Design/Cache%20Design&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kth Problems</title>
      <link>https://pineal.github.com/posts/kth_problems/</link>
      <pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kth_problems/</guid>
      <description>

&lt;h1 id=&#34;kth-problems&#34;&gt;Kth Problems&lt;/h1&gt;

&lt;h2 id=&#34;solution-with-priority-queue&#34;&gt;Solution with priority queue&lt;/h2&gt;

&lt;p&gt;套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).&lt;/p&gt;

&lt;h3 id=&#34;merge-k-sorted-lists&#34;&gt;Merge k Sorted Lists&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
//Time O(nlogk)
//Space O(n)
//provides greater
struct Cmp {
  bool operator() (ListNode* n1, ListNode* n2) {
    return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;
  }
};

class Solution {
public:
  ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
    //min_heap needs a greater comparator
    //Method 1: redefine functor
    //priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, Cmp&amp;gt; min_heap;
    //Method 2: Lambda
    auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;};
    priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp);
    //maintain the min_heap of size k instead of all nodes
    // klogn =&amp;gt; nlogk
    for (int i = 0; i &amp;lt; lists.size(); i++) {
      if (lists[i]) {
        min_heap.emplace(lists[i]);
      }
    }

    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (!min_heap.empty()) {
      ListNode* temp = min_heap.top();
      cur -&amp;gt; next = temp;
      min_heap.pop();
      if (temp -&amp;gt; next) {
        min_heap.emplace(temp -&amp;gt; next);
      }
      cur = cur -&amp;gt; next;
    }
    return dummy -&amp;gt; next;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-number-in-sorted-matrix&#34;&gt;Kth Smallest Number In Sorted Matrix&lt;/h3&gt;

&lt;p&gt;Solution 1: use priority queue&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(klogk)
class Solution {
public:
    int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int k) {
        int n = matrix.size();
        auto cmp = [&amp;amp;matrix](const pair&amp;lt;int, int&amp;gt; &amp;amp; p1, const pair&amp;lt;int, int&amp;gt; &amp;amp; p2) {
            return matrix[p1.first][p1.second] &amp;gt; matrix[p2.first][p2.second];
        };
        priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp);
        deque&amp;lt;deque&amp;lt;bool&amp;gt;&amp;gt; visited(n, deque&amp;lt;bool&amp;gt;(n, false));
        min_heap.emplace(0, 0);
        visited[0][0] = true;
        while (k &amp;gt; 1) {
            auto p = min_heap.top();
            min_heap.pop();
            int x = p.first;
            int y = p.second;
            if (x + 1 &amp;lt; n &amp;amp;&amp;amp; visited[x+1][y] == false) {
                visited[x+1][y] = true;
                min_heap.emplace(x+1, y);
            }
            if (y + 1 &amp;lt; n &amp;amp;&amp;amp; visited[x][y+1] == false) {
                visited[x][y+1] = true;
                min_heap.emplace(x, y+1);
            }
            k--;
        }
        return matrix[min_heap.top().first][min_heap.top().second];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sulution 2: use binary search&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int k) {
        return helper(matrix, k, matrix.front().front(), matrix.back().back());   
    }
    
    int helper(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int k, int left, int right) {
        if (left &amp;gt;= right) {
            return left;
        }
        //pick a reference value
        int mid = left + (right - left)/2;
        int n = matrix.size(); 
        int m = 0;
        //counts number of elements smaller than or equal to mid
        for (int i = 0; i &amp;lt; n; i++) {
                          
            /* 
             * 
             *The upper bound idea if optimized from:
              for (int j = 0; j &amp;lt; matrix[i].size(); j++) {
                  if (matrix[i][j] &amp;lt;= mid) {
                      m++;
                  }
              }
             * using for loop is the basic idea to help understand,
             * actually we can use binary search again to find the smallest element that larger than mid
             */            

            int num = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            m += num;
        }
        // now we know that there are m elements &amp;lt;= mid[include mid]
        // thus mid is m th smallest element in the matrix
        // if m == k, actually mid is the kth 
        // if m &amp;lt; k, then kth smallest element must appear after mid
        // otherwise, kth element must appear before mid

        if (m &amp;lt; k) {
            return helper(matrix, k, mid + 1, right);
        } else {
            return helper(matrix, k, left, mid);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-sum-in-two-sorted-arrays&#34;&gt;Kth Smallest Sum In Two Sorted Arrays&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Cell {
public:
  int i;
  int j;
  int sum;
  Cell(int _i, int _j, int _sum) {
    i = _i;
    j = _j;
    sum = _sum;
  }

  bool operator &amp;lt; (const Cell &amp;amp; c) const {
    return sum &amp;lt;= c.sum;
  }

  bool operator &amp;gt; (const Cell &amp;amp; c) const {
    return sum &amp;gt; c.sum;
  }
};

class Solution {
 public:
  int kthSum(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, int k) {
    // Write your solution here
    priority_queue&amp;lt;Cell, vector&amp;lt;Cell&amp;gt;, greater&amp;lt;Cell&amp;gt;&amp;gt; min_heap;
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(a.size(), vector&amp;lt;bool&amp;gt;(b.size(), false));
    visited[0][0] = true;
    min_heap.emplace(Cell(0, 0, a[0] + b[0]));
    for (int i = 0; i &amp;lt; k - 1; i++) {
      Cell cur = min_heap.top();
      min_heap.pop();
      if (cur.i + 1 &amp;lt; a.size() &amp;amp;&amp;amp; !visited[cur.i + 1][cur.j]) {
        int sum = a[cur.i + 1] + b[cur.j];
        min_heap.emplace(Cell(cur.i + 1, cur.j, sum));
        visited[cur.i + 1][cur.j] = true;
      }

      if (cur.j + 1 &amp;lt; b.size() &amp;amp;&amp;amp; !visited[cur.i][cur.j + 1]) {
        int sum = a[cur.i] + b[cur.j + 1];
        min_heap.emplace(Cell(cur.i, cur.j + 1, sum));
        visited[cur.i][cur.j + 1] = true;
      }
    }
    return min_heap.top().sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-with-only-3-5-7-as-factors&#34;&gt;Kth Smallest With Only 3, 5, 7 As Factors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  long kth(int k) {
    // Write your solution here.
    priority_queue&amp;lt;long, vector&amp;lt;long&amp;gt;, greater&amp;lt;long&amp;gt;&amp;gt; min_heap;
    min_heap.emplace(105);
    set&amp;lt;long&amp;gt; visited;
    visited.emplace(105);
    for (int i = 0; i &amp;lt; k - 1; i++) {
      long cur = min_heap.top();
      min_heap.pop();
      if (visited.find(cur * 3) == visited.end()) {
        min_heap.emplace(cur * 3);
        visited.emplace(cur * 3);
      }

      if (visited.find(cur * 5) == visited.end()) {
        min_heap.emplace(cur * 5);
        visited.emplace(cur * 5);
      }      

      if (visited.find(cur * 7) == visited.end()) {
        min_heap.emplace(cur * 7);
        visited.emplace(cur * 7);
      }      
    }

    return min_heap.top();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-closest-point&#34;&gt;Kth Closest Point&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {
public:
    int x;
    int y;
    int z;
    double dis;
    Point (int _x, int _y, int _z, double _dis) {
        x = _x;
        y = _y;
        z = _z;
        dis = _dis;
    }

    bool operator &amp;lt; (const Point &amp;amp; p1) const {
        return dis &amp;lt;= p1.dis;
    }

    bool operator &amp;gt; (const Point &amp;amp; p1) const {
        return dis &amp;gt; p1.dis;
    }

};

class Solution {
 public:
    vector&amp;lt;int&amp;gt; closest(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, vector&amp;lt;int&amp;gt; c, int k) {
        priority_queue&amp;lt;Point, vector&amp;lt;Point&amp;gt;, greater&amp;lt;Point&amp;gt;&amp;gt; min_heap;
        set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited;
        double d = sqrt(a[0] * a[0] + b[0] * b[0] + c[0] * c[0] + 0.0);
        Point* start = new Point(0,0,0,d);
        min_heap.emplace(*start);
        visited.emplace(vector&amp;lt;int&amp;gt;{0,0,0});
        for (int i = 0; i &amp;lt; k - 1; i++) {
            Point p = min_heap.top();
            min_heap.pop();
            if (p.x + 1 &amp;lt; a.size()) {
                double d = sqrt(a[p.x + 1] * a[p.x + 1] + b[p.y] * b[p.y] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x + 1,p.y,p.z,d);
                if (visited.find({p.x + 1,p.y,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x + 1, p.y, p.z};
                    visited.emplace(v);
                }
            }
            if (p.y + 1 &amp;lt; b.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y + 1] * b[p.y + 1] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x,p.y + 1,p.z,d);
                if (visited.find({p.x,p.y + 1,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y + 1,p.z};
                    visited.emplace(v);
                }
            }

            if (p.z + 1 &amp;lt; c.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y] * b[p.y] + c[p.z + 1] * c[p.z + 1] + 0.0);
                Point* temp = new Point(p.x,p.y,p.z + 1,d);
                if (visited.find({p.x,p.y,p.z + 1}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y,p.z + 1};
                    visited.emplace(v);
                }
            }      
        }

        Point rst = min_heap.top();
        return {a[rst.x], b[rst.y], c[rst.z]};
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;visited尽量用bool数组表示，二维三维都可。不要存放node类的class，地址不一样。&lt;/p&gt;

&lt;h2 id=&#34;solution-with-binary-search&#34;&gt;Solution with binary search&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://pineal.github.io/posts/binary_search/#advanced-using-binary-search-to-solve-kth-problem&#34;&gt;post about binary search&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution-with-quick-sort-partition&#34;&gt;Solution with quick-sort partition&lt;/h2&gt;

&lt;p&gt;Kth Largest Element in an Array&lt;/p&gt;

&lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:    
    int partition(vector&amp;lt;int&amp;gt; &amp;amp; nums, int left, int right) {        
        int pivot_index = left + rand() % (right - left + 1); 
        int pivot = nums[pivot_index];
        swap(nums[left], nums[pivot_index]);
        int left_bound = left + 1;
        int right_bound = right;
        while (left_bound &amp;lt;= right_bound) {
            if (nums[right_bound] &amp;lt;= pivot) {
                right_bound--;
            } 
            else if (nums[left_bound] &amp;gt;= pivot) {
                left_bound++;
            } 
            else {
                swap(nums[left_bound++], nums[right_bound--]);
            }
        }
        swap(nums[left], nums[right_bound]);
        return right_bound;
    }
    
    int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) {
        int left = 0;
        int right = nums.size() - 1;
        while (true) {
            int pos = partition(nums, left, right); 
            if (pos == k - 1) {
                return nums[pos];
            } 
            else if (pos &amp;gt; k - 1) {
                right = pos - 1;
            } 
            else {
                left = pos + 1;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://pineal.github.com/posts/bit_manipulation/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/bit_manipulation/</guid>
      <description>

&lt;h1 id=&#34;summary-of-basic-bit-manipulation&#34;&gt;Summary of Basic Bit Manipulation&lt;/h1&gt;

&lt;h2 id=&#34;count-1-in-binary&#34;&gt;Count 1 in Binary&lt;/h2&gt;

&lt;p&gt;数的二进制表示中有多少位1. 有两种方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每次把各位的数和 1 做 &amp;amp; 运算，然后计数，右移进行下一位。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        for (int i = 0; i &amp;lt; sizeof(int)*8; i++) {
            counter += num &amp;amp; 1;
            num &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;把 num 和 num - 1 做 &amp;amp; 运算， 直到num为0，有多少次运算就有多少个1. 因为每次“&amp;amp;”都会去掉num最右边的1.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        while (num) {
            num &amp;amp;= num - 1;
            counter++;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用法判断是不是2的整数次幂很容易，因为2的整数次幂必然只有1个bit的1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkPowerOf2(int n) {
    // write your code here
    return n &amp;gt; 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flip-bits&#34;&gt;Flip Bits&lt;/h2&gt;

&lt;p&gt;用到了xor的性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param a, b: Two integer
     *return: An integer
     */
    int bitSwapRequired(int a, int b) {
        // write your code here
        int counter = 0;
        int c = a^b;
        for (int i = 0; i &amp;lt; 32; i++) {
            counter += c &amp;amp; 1;
            c &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-b-problem&#34;&gt;A + B problem&lt;/h2&gt;

&lt;p&gt;这题。
         主要利用异或运算来完成。
         异或运算有一个别名叫做：不进位加法。
         那么a ^ b就是a和b相加之后，该进位的地方不进位的结果。
         然后下面考虑哪些地方要进位，自然是a和b里都是1的地方。
         a &amp;amp; b就是a和b里都是1的那些位置，a &amp;amp; b &amp;lt;&amp;lt; 1 就是进位
         之后的结果。所以：a + b = (a ^ b) + (a &amp;amp; b &amp;lt;&amp;lt; 1)
         。令a&amp;rsquo; = a ^ b, b&amp;rsquo; = (a &amp;amp; b) &amp;lt;&amp;lt; 1
         可以知道，这个过程是在模拟加法的运算过程，进位不可能
         一直持续，所以b最终会变为0。因此重复做上述操作就可以
         求得a + b的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
       while (b != 0) {
            int _a = a ^ b;
            int _b = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
            a = _a;
            b = _b;
        }
        return a;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-bits&#34;&gt;Update Bits&lt;/h2&gt;

&lt;p&gt;Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.&lt;/p&gt;

&lt;p&gt;把一个数的 ［j， i］ 之间的bits 用另一个数去填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int right_part = n &amp;amp; ((1 &amp;lt;&amp;lt; i) - 1);
        // The behavior of right shift &amp;gt;= 32 is undefined in C++.
        int left_part = j &amp;gt;= 31 ? 0 : (n &amp;gt;&amp;gt; (j + 1)) &amp;lt;&amp;lt; (j + 1);
        return left_part | (m &amp;lt;&amp;lt; i) | right_part;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用一个 mask 把 i 右边的数给取出来。
左边的数要这么取：先把bits右移 j + 1位，然后再左移 j + 1位，这样右边的数就都清空了。
最后一步把 m 左移后再把左边部分和右边部分用 ｜ 粘起来。
这种思想还可以用来做高地位互换等。把前一半的数右移，把后一半的数左移，然后 ｜ 起来。&lt;/p&gt;

&lt;h2 id=&#34;swap-two-variables&#34;&gt;swap two variables&lt;/h2&gt;

&lt;p&gt;如何不用第三个临时变量来交换两个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(int &amp;amp;a, int &amp;amp;b){
	if (a != b){
		  a ^= b;
      b ^= a;
      a ^= b;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;abs&#34;&gt;abs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//取符号位
	int a = -100;
	int i = a &amp;gt;&amp;gt; 31;
	//i = 0 正数
	if(i == 0){
		printf(&amp;quot;%d\n&amp;quot;,a);
	}
	//i = 1 负数
	else{
		printf(&amp;quot;%d\n&amp;quot;,~a + 1);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-complement&#34;&gt;Number Complement&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int findComplement(int num) {
        unsigned mask = ~0;
        while (num &amp;amp; mask) mask &amp;lt;&amp;lt;= 1;
        return ~mask &amp;amp; ~num;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://pineal.github.com/posts/sorting_algorithms/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sorting_algorithms/</guid>
      <description>

&lt;p&gt;假设这里的排序都是升序。&lt;/p&gt;

&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort:&lt;/h2&gt;

&lt;p&gt;归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// merge part
  vector&amp;lt;int&amp;gt; merge(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
	  vector&amp;lt;int&amp;gt; rst;
	  std::vector&amp;lt;int&amp;gt;::iterator iter1 = A.begin(), iter2 = B.begin();

	  while (iter1 != A.end() || iter2 != B.end()) {
	  	if (iter1 == A.end()) {
		  	rst.insert(rst.end(), iter2, B.end());
		  	break;
		  }
		  if (iter2 == B.end()) {
		  	rst.insert(rst.end(), iter1, A.end());
		  	break;
		  }
		  if (*iter1 &amp;lt; *iter2) {
			  rst.emplace_back(*iter1);
			  iter1++;
		  }
		  else {
			  rst.emplace_back(*iter2);
			  iter2++;
		  }
	  }
	  return rst;
  }

// key part of merge sort, recursive function
  vector&amp;lt;int&amp;gt; MSort(vector&amp;lt;int&amp;gt; array, int left, int right) {
	  vector&amp;lt;int&amp;gt; rst;
	  if (left == right) {
		  rst.emplace_back(array[left]);
		  return rst;
	  }
	  int mid = left + (right - left) / 2;
	  vector&amp;lt;int&amp;gt; leftArr = MSort(array, left, mid);
	  vector&amp;lt;int&amp;gt; rightArr = MSort(array, mid + 1, right);
	  rst = merge(leftArr, rightArr);
	  return rst;
  }
// driver for merge sort
  vector&amp;lt;int&amp;gt; mergeSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
	  vector&amp;lt;int&amp;gt; rst;
	  rst = MSort(array, 0, array.size() - 1);
	  return rst;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析： $O(nlog(n))$&lt;/p&gt;

&lt;p&gt;画出递归树，一共 $log(n)$ 层, 每一层是 $O(n)$ 的复杂度.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort:&lt;/h2&gt;

&lt;p&gt;快速排序的核心的思想为是 &lt;strong&gt;partition&lt;/strong&gt;. 这个思想在很多类型的问题中都会用到，会在后文举例说明。&lt;/p&gt;

&lt;p&gt;快速排序的基本操作为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选取一个pivot。&lt;/li&gt;
&lt;li&gt;所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边。&lt;/li&gt;
&lt;li&gt;分割数组：对pivot两边的数组递归重复以上步骤，直到不能分割。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体有哪些实现呢。
先来看第一种方法。这是一个textbook的解法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; int median(vector&amp;lt;int&amp;gt;&amp;amp; arr, int left, int right){
   // arr[left] &amp;lt;= arr[center] &amp;lt;= arr[right]
   int center = left + (right - left)/2;
   if (arr[left] &amp;gt; arr[center]) swap(&amp;amp;arr[left], &amp;amp;arr[center]);
   if (arr[left] &amp;gt; arr[right])  swap(&amp;amp;arr[left], &amp;amp;arr[right]);
   if (arr[center] &amp;gt; arr[right]) swap(&amp;amp;arr[center], &amp;amp;arr[right]);
   swap(&amp;amp;arr[center], &amp;amp;arr[right - 1]); //hide pivot
   return arr[right - 1];
 }

 void QSort(vector&amp;lt;int&amp;gt; &amp;amp; arr, int left, int right) {

//   if (left &amp;gt;= right) return;
   if (left + CutOff &amp;lt;= right){
     int pivot = median(arr, left, right);
     int i = left;
     int j = right - 1;
     for(;;){
      while (arr[++i] &amp;lt; pivot){}
       while (arr[--j] &amp;gt; pivot){}
      if (i &amp;lt; j) swap(&amp;amp;arr[i], &amp;amp;arr[j]);
       else  break;
     }
//   if (left + 1 != right){
       swap(&amp;amp;arr[i], &amp;amp;arr[right - 1]); //restore pivot
//   }  
     QSort(arr, left, i - 1);
     QSort(arr, i + 1, right);
   }
   else{
     insertion_Sort(arr, left, right - left + 1);
   }
 }

 vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
   if (array.size() &amp;lt;= 1) return array;
   QSort(array, 0, array.size() - 1);
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个解法。基本思想是一样的。每次都要保持所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边这个条件。
实现的过程为，选取两块挡板，分别从数组的头和尾往中间靠拢，直到挡板相遇。在每一次的循环中，保证第一块挡板左边的数都小于pivot，第二块挡板右边的数都大于pivot。&lt;/p&gt;

&lt;p&gt;事实上根据上面这个general rule来分，两个挡板指向的两个数只有四种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;lt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt;= pivot, a[j] &amp;lt;= pivot$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么对应刚才的rule该做着么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;满足条件：移动挡板i++， j&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足前半个条件，移动挡板i++，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足后半个条件，移动挡板j&amp;ndash;，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不满足任何条件，但是一旦交换两个挡板上的数，即可让条件满足&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  void QuickSort(vector&amp;lt;int&amp;gt; &amp;amp; array, int left, int right){
    if (left &amp;gt; right) return;
    int pivot_index = (left + right)/2;
    int pivot =  array[pivot_index];
    int left_bound = left;
    int right_bound = right - 1;
    //hide the pivot in the rightmost
    std::swap(array[pivot_index], array[right]);
    //three regions:
    //1. [0, leftbound - 1] : all elements smaller than pivot should be here
    //2. [leftbound, rightbound]: to be discovered, scan the element in a[leftbound], and move leftbound every step
    //3. [rightbound + 1, array.size() - 1] all elements bigger than pivot should be here
    while (left_bound &amp;lt;= right_bound) {
      //check two
      if (array[left_bound] &amp;lt; pivot) {
      // obey all three rules, move leftbound
        ++left_bound;
      }
      else if (array[right_bound] &amp;gt; pivot) {
        --right_bound;
      }
      else {
        //array[left_bound] &amp;gt; pivot &amp;amp;&amp;amp; array[right_bound &amp;lt; pivot]
        std::swap(array[left_bound++], array[right_bound--]);      
      }
    }
    //restore the pivot to the original position
    std::swap(array[left_bound], array[right]);
    //partition and recursion
    QuickSort(array, left, left_bound - 1);
    QuickSort(array, left_bound + 1, right);
  }

  vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
    QuickSort(array, 0, array.size() - 1);
    return array;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的解法可以归结为一种类型。比如一堆数中只有两种，三种四种数，那么就可以对应个数的挡板将数分割成相应区域，每次检查条件是否满足。Eg: Sort colors。这样的做法复杂度只需要$O(n)$.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-i-sort-colors&#34;&gt;Partition Extension I: Sort Colors&lt;/h3&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int zero = 0;
    int one = 0;    //explorer
    int two = nums.size() - 1;
    //Three seperator Four regions
    //[0, zero)     0
    //[zero, one]   1
    //(two, end]    2
    while (one &amp;lt;= two) {
        if (nums[one] == 0) {   
            swap(nums[one++], nums[zero++]);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums[one], nums[two--]);
            //don&#39;t move &#39;one&#39;:
            //you don&#39;t know what is swaped from &#39;two&#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-i-four-colors&#34;&gt;Follow up I: four colors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; rainbowSortII(vector&amp;lt;int&amp;gt; array) {
   int zero = 0, one = 0, other = array.size() - 1;
   while (one &amp;lt;= other) {
     if (array[one] &amp;lt; 1) {
       swap(array[one++], array[zero++]);
     } else if (array[one] &amp;gt; 1) {
       swap(array[other--], array[one]);
     } else {
       one++;
     }
   }
   int two = one, three = array.size() - 1;
   while (two &amp;lt;= three) {
     if (array[two] == 3 &amp;amp;&amp;amp; array[three] == 2) {
       swap(array[two++], array[three--]);
     } else if (array[two] == 2) {
       two++;
     } else {
       three--;
     }
   }
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-ii-k-colors&#34;&gt;Follow up II: k colors&lt;/h3&gt;

&lt;p&gt;TODO: couting sort.&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-ii-kth-smallest-largest-element-in-an-unsorted-array&#34;&gt;Partition Extension II: Kth smallest/largest element in an unsorted array&lt;/h3&gt;

&lt;p&gt;quick sort partition 思想的另一经典应用。
&lt;a href=&#34;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&#34;&gt;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wiggle-sort&#34;&gt;Wiggle Sort&lt;/h2&gt;

&lt;p&gt;$nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]&amp;hellip;.$&lt;/p&gt;

&lt;p&gt;这个时间复杂度优化到了O(n)。下面那个做法是通用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    for (int i=0; i&amp;lt;(int)nums.size() - 1; i++) {
        if (i % 2 == 0 &amp;amp;&amp;amp; nums[i] &amp;gt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
        if (i % 2 == 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
    }        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-wiggle-sort-ii&#34;&gt;Follow up: Wiggle Sort II&lt;/h3&gt;

&lt;p&gt;$nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;$&lt;/p&gt;

&lt;p&gt;根据这个性质，我们可以确定一种排法一定可以成立：把小的那一半排在偶数位，把大的那一半排在奇数位。这个是通用的。
 时间复杂度 $ O(nlog(n)) $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    vector&amp;lt;int&amp;gt; copy(nums);
    sort(copy.begin(), copy.end());
    int left = (nums.size() + 1) / 2 - 1;
    int right = nums.size() - 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        nums[i] = (i % 2 == 0)? copy[left--] : copy[right--];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传说中$O(n)$ 的解法。&lt;/p&gt;

&lt;h2 id=&#34;sort-in-specified-order&#34;&gt;Sort In Specified Order&lt;/h2&gt;

&lt;p&gt;A1 = {2, 1, 2, 5, 7, 1, 9, 3},&lt;/p&gt;

&lt;p&gt;A2 = {2, 1, 3},&lt;/p&gt;

&lt;p&gt;A1 is sorted to {2, 2, 1, 1, 3, 5, 7, 9}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; helper(vector&amp;lt;int&amp;gt; &amp;amp; A1, vector&amp;lt;int&amp;gt; &amp;amp; A2) {
   // Write your solution here.
   if (A1.size() &amp;lt;= 1 |||| A2.size() == 0) {
       sort(A1.begin(), A1.end());
       return A1;
   }
   map&amp;lt;int, int&amp;gt; t;
   for (int i = 0; i &amp;lt; A2.size(); i++) {
       t.emplace(A2[i], i);
   }

   int j = 0, k = A1.size() - 1;
   while (j &amp;lt;= k) {
       if (t.find(A1[j]) == t.end() &amp;amp;&amp;amp; t.find(A1[k]) != t.end()) {
           swap(A1[j], A1[k]);
           j++;
           k--;
       }
       else if (t.find(A1[j]) != t.end()) {
           j++;
       }
       else {
           k--;
       }
   }

   //sort the [0, j) in specified order
   //[2 1 3 4]
   //2 1 2 1 4 3 =&amp;gt; 2 2 1 1 3 4

   for (int i = 0; i &amp;lt; j; i++) {
       int min_index = i;
       for (int l = i; l &amp;lt; j; l++) {
           if (t[A1[min_index]] &amp;gt; t[A1[l]]) {
               min_index = l;
           }
       }
       swap(A1[i], A1[min_index]);
   }

   //sort the (k, n) part in ascending order
   sort(A1.begin() + k + 1, A1.end());
   return A1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort:&lt;/h2&gt;

&lt;p&gt;插入排序。假设一个长度为N的数组$A[]$，总体过程为，从 index 为 1 开始到 N-1，使得 $A[0,index]$ 是一个排好序的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void insertion_sort(T arr[], int len){
  for (int i = 1; i &amp;lt; len; i++){
    int temp = arr[i];
      for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1]&amp;gt;temp; j--){ //实际比较的是j-1
        arr[j] = arr[j-1];  //全部往后移一位腾出位置等插入
      }
    arr[j] = temp;    //插入到腾出来的位置
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度：
$O(n^2)$&lt;/p&gt;

&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort:&lt;/h2&gt;

&lt;p&gt;选择排序。假设一个长度为N的数组$A[]$，总体过程为，从index为0开始到N-1，使得$A[0,index]$是一个排好序的数组。&lt;/p&gt;

&lt;p&gt;怎么跟插入排序这么像呢？是挺像的，但是具体的过程是有区别。这区别就是“插入”和“选择”的区别。&lt;/p&gt;

&lt;p&gt;插入排序是每次往前面那些已经排序好的数里“插入”进去，而选择排序则是，每次从这个数后面那些没排好序的数里“选择”到最小的，和这个数交换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void selection_sort(T arr[], int len){
  for (int i = 0; i &amp;lt; len - 1; i++){  //len - 1即可，最后一次交换在倒数第一个和倒数第二个之间进行
    int min_index = i;
    for (int j = i + 1; j &amp;lt; len; j++){
      //找到未排序的数组中最小的数的index
      if (arr[j]&amp;lt;arr[min_index]){
          min_index = j;
      }        
    }
    swap(arr[i], arr[min_index]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析：
$O(n^2)$的复杂度。实际上是冒泡排序的一个优化，虽然最坏时间复杂度上是一样的。&lt;/p&gt;

&lt;p&gt;附上冒泡排序代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(int arr[], int n) {
    int i, j;
    for (i = 0; i &amp;lt; n - 1; i++) {
        for (j = 0; j &amp;lt; n - 1 - i; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://pineal.github.com/posts/binary_tree/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_tree/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;h3 id=&#34;concepts&#34;&gt;Concepts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Binary Tree: 全部都填满的树。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Complete Binary Tree: 除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Balanced Binary Tree: 左右子树的高度最多差1. Height of the tree: $O(log(n))$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary Search Tree: Recursively, Leftsubtree is smaller than root and righ subtree is larger than root. Inorder traverse is increasing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;traverse&#34;&gt;Traverse&lt;/h2&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preorder: 8-&amp;gt;3-&amp;gt;1-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;10-&amp;gt;14-&amp;gt;13&lt;/li&gt;
&lt;li&gt;Inorder:  1-&amp;gt;3-&amp;gt;4-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;10-&amp;gt;13-&amp;gt;14&lt;/li&gt;
&lt;li&gt;Postorder: 1-&amp;gt;4-&amp;gt;7-&amp;gt;6-&amp;gt;3-&amp;gt;13-&amp;gt;14-&amp;gt;10-&amp;gt;8&lt;/li&gt;
&lt;li&gt;Levelorder: 8-&amp;gt;3-&amp;gt;10-&amp;gt;1-&amp;gt;6-&amp;gt;14-&amp;gt;4-&amp;gt;7-&amp;gt;13&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traverse-recursively&#34;&gt;Traverse Recursively&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void helper(TreeNode* node, vector&amp;lt;int&amp;gt; &amp;amp; rst){
    if (node != nullptr){
//      rst.emplace_back(root -&amp;gt; val);  If it is PreOder
        helper(node -&amp;gt; left, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is InOrder
        helper(node -&amp;gt; right, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is PostOrder
    }
}
vector&amp;lt;int&amp;gt; DFS_Traversal(TreeNode* root) {
    // write your code here
    vector&amp;lt;int&amp;gt; rst;
    helper(root, rst);
    return rst;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;preorder-iterative&#34;&gt;Preorder iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s, vector&amp;lt;int&amp;gt; &amp;amp; res) {
    while (root) {
        res.emplace_back(root-&amp;gt;val);
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; preorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s, res);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        cur = cur-&amp;gt;right;
        pushleft(cur, s, res);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inorder-iterative&#34;&gt;Inorder Iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s) {
    while (root) {
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; inorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        res.emplace_back(cur-&amp;gt;val);
        cur = cur-&amp;gt;right;
        pushleft(cur, s);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-i&#34;&gt;Postorder iterative I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s1, s2;
    s1.push(root);
    while (!s1.empty()) {
        auto cur = s1.top();
        s2.push(cur);
        s1.pop();
        if (cur-&amp;gt;left) {
            s1.push(cur-&amp;gt;left);
        }
        if (cur-&amp;gt;right) {
            s1.push(cur-&amp;gt;right);
        }
    }
    while (!s2.empty()) {
        auto cur = s2.top();
        s2.pop();
        res.emplace_back(cur-&amp;gt;val);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-ii&#34;&gt;Postorder iterative II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorderII(TreeNode* root) {
    if (root == nullptr) {
        return {};
    }
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    s.push(root);
    TreeNode* prev = nullptr;
    while (!s.empty()) {
        auto cur = s.top();
        if (prev == nullptr || cur == prev-&amp;gt;left || cur == prev-&amp;gt;right) {
            if (cur-&amp;gt;left) {
                s.push(cur-&amp;gt;left);
            }
            else if (cur-&amp;gt;right) {
                s.push(cur-&amp;gt;right);
            }
            else {
                s.pop();
                res.emplace_back(cur-&amp;gt;val);
            }
        }
        else if (prev == cur-&amp;gt;right || prev == cur-&amp;gt;left &amp;amp;&amp;amp; cur-&amp;gt;right == nullptr) {
            s.pop();
            res.emplace_back(cur-&amp;gt;val);
        }
        else {
            s.push(cur-&amp;gt;right);
        }
        prev = cur;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bfs-level-order&#34;&gt;BFS level order&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    if (root == nullptr) return rst;

    queue&amp;lt;TreeNode*&amp;gt; nodes;
    nodes.push(root);

    while(!nodes.empty()){
        vector&amp;lt;int&amp;gt; level;
        int size = nodes.size();
        for (int i = 0; i &amp;lt; size; i++){
            TreeNode* node = nodes.front();
            nodes.pop();
            level.emplace_back(node -&amp;gt; val);
            if (node -&amp;gt; left != nullptr) nodes.push(node -&amp;gt; left);
            if (node -&amp;gt; right != nullptr) nodes.push(node -&amp;gt; right);    
        }
        rst.emplace_back(level);
    }
return rst;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;morris-traverse-todo&#34;&gt;Morris Traverse(TODO)&lt;/h3&gt;

&lt;h2 id=&#34;binary-tree-iterator&#34;&gt;Binary Tree Iterator&lt;/h2&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/d600d536acf50c6d3299e99b200a4c247b79ece7/Binary_Tree/Binary_Tree_Iterator.cpp&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bst-iterator&#34;&gt;BST iterator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BSTIterator {
private:
    stack&amp;lt;TreeNode*&amp;gt; s;
public:
    BSTIterator(TreeNode *root) {
        while (root) {
            s.push(root);
            root = root -&amp;gt; left;
        }
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !s.empty();
    }

    /** @return the next smallest number */
    //which means ascending order
    //which means inoredr traversal
    int next() {
        if (s.empty()) {
            return INT_MAX;
        }
        
        TreeNode* parent = s.top();
        s.pop();
        TreeNode* cur = parent -&amp;gt; right;
        while (cur) {
            s.push(cur);
            cur = cur -&amp;gt; left;
        }
        return parent -&amp;gt; val;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;different-views-of-tree&#34;&gt;Different views of tree&lt;/h2&gt;

&lt;h3 id=&#34;boundary-of-binary-tree&#34;&gt;Boundary of Binary Tree&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;int&amp;gt; boundaryOfBinaryTree(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector&amp;lt;int&amp;gt; left, right, bottom, res;
        res.emplace_back(root-&amp;gt;val);
        getLeft(root-&amp;gt;left, left);
        getBottom(root-&amp;gt;left, bottom);
        getBottom(root-&amp;gt;right, bottom);
        getRight(root-&amp;gt;right, right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), bottom.begin(), bottom.end());
        res.insert(res.end(), right.rbegin(), right.rend());
        return res;
    }
private:    
    void getLeft(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;left) {
            getLeft(root-&amp;gt;left, res);
        }
        else {
            getLeft(root-&amp;gt;right, res);    
        }
    }
    
    void getRight(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;right) {
            getRight(root-&amp;gt;right, res);
        } 
        else {
            getRight(root-&amp;gt;left, res);
        }
    }
    
    void getBottom(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            res.emplace_back(root-&amp;gt;val);
        }
        getBottom(root-&amp;gt;left, res);
        getBottom(root-&amp;gt;right, res);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;path-problems&#34;&gt;Path problems&lt;/h2&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-i&#34;&gt;Maximum Path Sum Binary Tree I&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from one leaf node to another leaf node. If there is no such path available, return INT_MIN (C++).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
 int global_max = INT_MIN;
 
  int maxPathSum(TreeNode* root){
    dfs(root);
    return global_max;
  }
 
  int dfs(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
  
    int left =  dfs(root -&amp;gt; left);
    int right = dfs(root -&amp;gt; right);

    if (root -&amp;gt; left &amp;amp;&amp;amp; root -&amp;gt; right) {
      int sum = left + right + root -&amp;gt; value;
      global_max = max(sum, global_max);
      return max(left, right) + root -&amp;gt; value;
    } 
      return (!root -&amp;gt; left)? right + root -&amp;gt; value : left + root -&amp;gt; value;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-ii&#34;&gt;Maximum Path Sum Binary Tree II&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from any node to any node &lt;strong&gt;(the start node and the end node can be the same)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);    
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    //left = (left &amp;lt; 0)? 0 : left;
    //right = (right &amp;lt; 0)? 0 : right; 
    global_max = max(global_max, left + right + root -&amp;gt; value);
    return max(0, max(left, right) + root -&amp;gt; value); 
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-iii&#34;&gt;Maximum Path Sum Binary Tree III&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number.
Find the maximum possible subpath sum&lt;strong&gt;(both the starting and ending node of the subpath should be on the same path from root to one of the leaf nodes, and the subpath is allowed to contain only one node)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    int sum = max(max(left, right) , 0) + root -&amp;gt; value;
    global_max = max(global_max, sum);
    return sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lca-problems&#34;&gt;LCA problems&lt;/h2&gt;

&lt;h3 id=&#34;lca-i&#34;&gt;LCA I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root -&amp;gt; left, p, q);
        TreeNode* right = lowestCommonAncestor(root -&amp;gt; right, p, q);
        if (left &amp;amp;&amp;amp; right) {
            return root;
        }
        return left? left : right;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-of-bst&#34;&gt;LCA of BST&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return root;
        // p, q are in two sides or root is one of p, q
        } else if ((root-&amp;gt;val - p-&amp;gt;val) * (root-&amp;gt;val - q-&amp;gt;val) &amp;lt;= 0) {
            return root;
        //p,q are smaller than root =&amp;gt; both in left side
        } else if (root-&amp;gt;val &amp;gt; p-&amp;gt;val &amp;amp;&amp;amp; root -&amp;gt; val &amp;gt; q-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;left, p, q);
        //both in right side
        } else {
            return lowestCommonAncestor(root-&amp;gt;right, p, q);            
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-ii&#34;&gt;LCA II&lt;/h3&gt;

&lt;p&gt;Give the treenode with parent pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//class TreeNodeP {
// public:
//  int value;
//  TreeNodeP* left;
//  TreeNodeP* right;
//  TreeNodeP* parent;
//  TreeNodeP(int v, TreeNodeP* p) 
//      : value(v), left(NULL), right(NULL), parent(p) {}
//};

class Solution {
private:
 int path_length(TreeNodeP* node) {
   int length = 0;
   while (node) {
     node = node -&amp;gt; parent;
     length++;
   }
   return length;
 }
 
 TreeNodeP* llc(TreeNodeP* small, TreeNodeP* large, int diff) {
   while (diff &amp;gt; 0) {
     large = large -&amp;gt; parent;
     diff--;
   }
   while (large != small) {
     large = large -&amp;gt; parent;
     small = small -&amp;gt; parent;
   }
   return large;
 }
 public:
  TreeNodeP* LCA(TreeNodeP* one, TreeNodeP* two) {
    int l1 = path_length(one);
    int l2 = path_length(two);
    if (l1 &amp;lt;= l2) {
      return llc(one, two, l2 - l1);
    } else {
      return llc(two, one, l1 - l2);
    }
  }
  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iii&#34;&gt;LCA III&lt;/h3&gt;

&lt;p&gt;Given two nodes in a binary tree, find their lowest common ancestor (the given two nodes are not guaranteed to be in the binary tree). Return null If any of the nodes is not in the tree. There is no parent pointer for the nodes in the binary tree. The given two nodes are not guaranteed to be in the binary tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  bool flag1 = false;
  bool flag2 = false;
  TreeNode* solve(TreeNode* root, TreeNode* one, TreeNode* two) {
  
    traversal(root, one, two);
    if (flag1 &amp;amp;&amp;amp; flag2) {
      return findLCA(root, one, two);
    } 
    return nullptr;
  }
  void traversal(TreeNode* root, TreeNode* one, TreeNode* two) {
    if (root == nullptr) {
      return;
    }
    if (root == one) {flag1 = true;}
    if (root == two) {flag2 = true;}
    traversal(root -&amp;gt; left, one, two);
    traversal(root -&amp;gt; right, one, two);
  }
  TreeNode* findLCA(TreeNode* root, TreeNode* one, TreeNode* two) {
   
    if (root == nullptr) {
      return nullptr;
    }
    
    if (root == one) {
      return root;
    }
    
    if (root == two) {
      return root;
    }
    
    auto left =  findLCA(root -&amp;gt; left,  one, two);
    auto right = findLCA(root -&amp;gt; right, one, two);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else if (left) {
      return left;
    } else if (right) {
      return right;
    } else {
      return nullptr;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iv&#34;&gt;LCA IV&lt;/h3&gt;

&lt;p&gt;Give k nodes, find their CLA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* LCA(TreeNode* root, vector&amp;lt;TreeNode*&amp;gt; nodes) {
    if (root == nullptr) {
      return root;
    }
    
    for (int i = 0; i &amp;lt; nodes.size(); i++) {
      if (root == nodes[i]) {
        return root;
      }
    }
    
    auto left = LCA(root -&amp;gt; left, nodes);
    auto right = LCA(root -&amp;gt; right, nodes);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else {
      return left? left : right;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-if-cousins&#34;&gt;Check if cousins&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/check-two-nodes-cousins-binary-tree/&#34;&gt;Geeksforgeeks source&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkIfCousins(TreeNode* root, TreeNode* one, TreeNode* two) {
  
  bool res = false;
  helper(root, one, two, 0, res);
  return res;
}

//return target&#39;node level
//return -1 is not found
int helper(TreeNode* root, TreeNode* one, TreeNode* Two, int level, bool &amp;amp; res) {

  if (root == nullptr) {
    return -1;
  }

  if (root == one || root == two) {
    return level;
  }

  int left = helper(root-&amp;gt;left, one, two, level + 1, res);
  int right = helper(root-&amp;gt;right, one, two, level + 1, res);

  if (left == right &amp;amp;&amp;amp; left - 1 &amp;gt; level) {
    res = true;
  }
  return max(left, right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serialize-and-deserialize-binary-tree&#34;&gt;Serialize and deserialize binary tree&lt;/h2&gt;

&lt;h3 id=&#34;reconstruct-binary-tree-with-preorder-and-inorder&#34;&gt;Reconstruct Binary Tree With Preorder And Inorder&lt;/h3&gt;

&lt;p&gt;一棵树需要什么信息？需要知道什么是根，左子树和右子树分别又是什么。&lt;/p&gt;

&lt;p&gt;那么从这两种遍历之中可以获取什么信息？&lt;/p&gt;

&lt;p&gt;先序遍历： root | left subtree | right subtree&lt;/p&gt;

&lt;p&gt;中序遍历： left subtree | root | right subtree&lt;/p&gt;

&lt;p&gt;先序遍历的最左边，一定是根，但是无法找到左子树和右子树的分界点；但是可以通过找到根，从而从中序遍历中找到这个分界。&lt;/p&gt;

&lt;p&gt;解题步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;leftmost of preOrder must be root&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find position of root in inOrder =&amp;gt; need a hashtable to pre-store indices&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: left side of root is left subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: right side of root is right subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;recursively solve the problem on left subtree and right subtree&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; pre) {
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    
    return helper(in, 0, in.size() - 1, pre, 0, table);
  }
  
  TreeNode* helper(const vector&amp;lt;int&amp;gt; &amp;amp; in, int in_left, int in_right, 
                   const vector&amp;lt;int&amp;gt; &amp;amp; pre, int pre_left,
                    unordered_map&amp;lt;int, int&amp;gt; table) {
                      
    if (in_left &amp;gt; in_right) {
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(pre[pre_left]);
    int index = table[root -&amp;gt; value];
    root -&amp;gt; left = helper(in, in_left, index - 1, pre, pre_left + 1, table);
    root -&amp;gt; right = helper(in, index + 1, in_right, pre, pre_left + index - in_left + 1, table);
    return root;                  
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-with-level-order&#34;&gt;Reconstruct with level order&lt;/h3&gt;

&lt;p&gt;level order 的第一个元素，一定是root。通过inorder找到root的位置，然后根据index的关系，分割左右子树。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; level) {
    map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    return helper(level, table);
  }
  TreeNode* helper(vector&amp;lt;int&amp;gt; level, map&amp;lt;int, int&amp;gt; table) {
    if (level.size() == 0) {
      return nullptr;
    }
    TreeNode* root = new TreeNode(level[0]);
    int index = table[root-&amp;gt;value];
    vector&amp;lt;int&amp;gt; left;
    vector&amp;lt;int&amp;gt; right;
    
    for (int i = 0; i &amp;lt; level.size(); i++) {
      if (table[level[i]] &amp;lt; index) {
        left.emplace_back(level[i]);
      } else if (table[level[i]] &amp;gt; index) {
        right.emplace_back(level[i]);
      }
    }
    root -&amp;gt; left = helper(left, table);
    root -&amp;gt; right = helper(right, table);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-binary-search-tree-with-postorder-traversal&#34;&gt;Reconstruct Binary Search Tree With Postorder Traversal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; post) {
    //Post order -&amp;gt; [leftsubtree][rightsubtree]root =&amp;gt; determine the position of root
    //In   order -&amp;gt; [left]root[right] =&amp;gt;recursively find left and right parts
    vector&amp;lt;int&amp;gt; in(post);
    sort(in.begin(), in.end());
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
        table[in[i]] = i;
    }
    return helper(in, post, table, post.size() - 1, 0, in.size() - 1);
  }
  
  TreeNode* helper(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; post, unordered_map&amp;lt;int, int&amp;gt; &amp;amp; table,
                    int post_right, int in_left, int in_right) {
  
    if (in_left &amp;gt; in_right){
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(post[post_right]);
    int index = table[root -&amp;gt; value];
    
    root -&amp;gt; right = helper(in, post, table, post_right - 1, index + 1, in_right);
    root -&amp;gt; left = helper(in, post, table, post_right - 1 - (in_right - index), in_left, index - 1);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string order;
        inorderDFS(root, order);
        return order;
    }
    
    inline void inorderDFS(TreeNode* root, string&amp;amp; order) {
        if (!root) return;
        char buf[4];
        memcpy(buf, &amp;amp;(root-&amp;gt;val), sizeof(int)); //burn the int into 4 chars
        for (int i=0; i&amp;lt;4; i++) order.push_back(buf[i]);
        inorderDFS(root-&amp;gt;left, order);
        inorderDFS(root-&amp;gt;right, order);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int pos = 0;
        return reconstruct(data, pos, INT_MIN, INT_MAX);
    }
    
    inline TreeNode* reconstruct(const string&amp;amp; buffer, int&amp;amp; pos, int minValue, int maxValue) {
        if (pos &amp;gt;= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.
        
        int value;
        memcpy(&amp;amp;value, &amp;amp;buffer[pos], sizeof(int));
        if (value &amp;lt; minValue || value &amp;gt; maxValue) return NULL;
        
        TreeNode* node = new TreeNode(value);
        pos += sizeof(int);
        node-&amp;gt;left = reconstruct(buffer, pos, minValue, value);
        node-&amp;gt;right = reconstruct(buffer, pos, value, maxValue);
        return node;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-doubly-linked-list-from-a-ternary-tree&#34;&gt;Create a Doubly Linked List from a Ternary Tree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/create-doubly-linked-list-ternary-ree/&#34;&gt;Question source&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;difference-between-dfs-and-bfs&#34;&gt;Difference between DFS and BFS&lt;/h3&gt;

&lt;p&gt;DFS using stacks, and BFS using queues if Non-Recursion&lt;/p&gt;

&lt;h3 id=&#34;difference-between-recursion-and-non-recursion&#34;&gt;Difference between Recursion and Non-Recursion&lt;/h3&gt;

&lt;p&gt;Recursion is dangerous when memory resource is limited: stack may overflow;
However Non-Recursion method occupies more space&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://pineal.github.com/posts/binary_search/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_search/</guid>
      <description>

&lt;h2 id=&#34;经典二分搜索及其变种&#34;&gt;经典二分搜索及其变种&lt;/h2&gt;

&lt;p&gt;二分搜索的核心思想是，在给定的搜索空间内，排除掉一定不对的那一部分。应用场景往往是有序的，或者局部有序的。这样从 $O(n)$ 可以优化到 $O(logn)$. 搜索空间的定义可以是具体的值，也可以是数组的索引，需要具体问题具体分析。&lt;/p&gt;

&lt;h3 id=&#34;classic-binary-search&#34;&gt;Classic binary search&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int classic_binary_search(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty()) {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt;= right){
      int mid = left + (right - left)/2;
      if (input[mid] == target){
        return mid;
      }
      else if (input[mid] &amp;lt; target) {
        left = mid + 1;
      }
      else {
        right = mid - 1;
      }
    }
    return -1;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;find-last-first-index-of-target&#34;&gt;find last/first index of target&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_first_index(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.size() == 0) return -1;
    int left = 0, right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt; input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[left] == target){
      return left;
    }
    else if (input[right] == target) {
      return right;
    }
    else
      return -1;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_last_index(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty())  {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt;= input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[right] == target) {
      return right;
    }
    else if (input[left] == target) {
      return left;
    }
    else {
      return -1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;search-in-a-sorted-array-of-unknown-size&#34;&gt;Search in a sorted array of unknown size&lt;/h3&gt;

&lt;p&gt;Given an integer array sorted in ascending order,
write a function to search target in nums.
If target exists, then return its index, otherwise return -1.
However, the array size is unknown to you.
You may only access the array using an ArrayReader interface,
where ArrayReader.get(k) returns the element of the array at index k (0-indexed).&lt;/p&gt;

&lt;p&gt;You may assume all integers in the array are less than 10000,
and if you access the array out of bounds, ArrayReader.get will return 2147483647.&lt;/p&gt;

&lt;p&gt;Example 1:
Input: array = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4&lt;/p&gt;

&lt;p&gt;Example 2:
Input: array = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
Note:&lt;/p&gt;

&lt;p&gt;You may assume that all elements in the array are unique.
The value of each element in the array will be in the range [-9999, 9999].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int search(const ArrayReader&amp;amp; reader, int target) {
        int prev = 0, cur = 1;
        while (prev &amp;lt; cur) {
            long k = reader.get(cur);
            if (k == target) {
               return cur; 
            }
            else if (k &amp;lt; target) {
                prev = cur;
                cur = cur * 2;
            } else {
                cur = (prev + cur) / 2;                 
            }
        }
        return reader.get(0) == target? 0 : -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二维二分搜索&#34;&gt;二维二分搜索&lt;/h2&gt;

&lt;h3 id=&#34;search-a-2d-matrix&#34;&gt;Search a 2D Matrix&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix/&#34;&gt;Problem Link from Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从左到右递增，下一行的开头一定比上一行的末尾大。那么就可以转化为一维的二分搜索。考点在二维矩阵到一维矩阵的变换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
  int left = 0;
  int right = matrix.size() * matrix[0].size() - 1;
  while (left &amp;lt;= right) {
    int mid = left + (right - left) / 2;
    int i = mid / matrix[0].size();
    int j = mid % matrix[0].size();
    if (matrix[i][j] == target) {
      return true;
    } else if (target &amp;gt; matrix[i][j]) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;search-a-2d-matrix-ii&#34;&gt;Search a 2D matrix II&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix-ii/&#34;&gt;Problem Link from Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从左往右一定递增，从上到下一定递增。跟之前一题相比，这里的二维矩阵并不能保证转化成一维递增的矩阵。
如果从左上角开始往右下角搜索，那么有多种可能，刚开始用的是分治法，把矩阵分成四块，由于这个矩形的性质，我们只能排除掉一块，然后往三块可能的继续搜。时间复杂度为$O(n^{1.58})$, 参考分治法时间复杂度分析公式.
但如果从右上角往左下角搜，那么可以保证向左一定是递减的，向下一定是递增的，那么可以排除掉特定行或者特定列。这样的时间复杂度出来的是$O(m + n)$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
	int m = matrix.size();
	if (m == 0) return false;
	int n = matrix[0].size();
	int i = 0, j = n - 1;
	while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;gt;= 0) {
		if (matrix[i][j] == target)
			return true;
		else if (matrix[i][j] &amp;gt; target) {
			j--;
		} else
			i++;
	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;binary-search-in-rotated-array&#34;&gt;Binary search in rotated array&lt;/h2&gt;

&lt;h3 id=&#34;find-minimum-in-rotated-sorted-array&#34;&gt;Find Minimum in Rotated Sorted Array&lt;/h3&gt;

&lt;p&gt;Duplication allowed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 5 1 1 2 2 2 3 4
class Solution {
public:
    int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int left = 0;
        int right = nums.size() - 1;
        while (left &amp;lt; right - 1) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &amp;lt; nums[right]) {
                right = mid;
            } else if (nums[mid] &amp;gt; nums[right]) {
                left = mid + 1;
            } else {
                right--;
            }
        }
        return min(nums[left], nums[right]);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/&#34;&gt;Find Minimum in Rotated Sorted Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/&#34;&gt;Find Minimum in Rotated Sorted Array II&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/&#34;&gt;Search in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;binary-search-to-solve-kth-problem&#34;&gt;Binary search to solve Kth problem&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;find-kth-smallest-largest-number-in-two-sorted-array&#34;&gt;Find Kth smallest/largest number in two sorted array&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) {
        int N = a.size() + b.size();
        //return (findKthSmallest(a, b, 0, 0, (N + 1)/2) + findKthSmallest(a, b, 0, 0, (N + 2)/2)) / 2.0;
        return (findKthLargest(a, b, a.size() - 1, b.size() - 1, (N + 1)/2) + findKthLargest(a, b, a.size() - 1, b.size() - 1, (N + 2)/2)) / 2.0;

    }
    
    int findKthLargest(const vector&amp;lt;int&amp;gt; &amp;amp; a, const vector&amp;lt;int&amp;gt; &amp;amp; b, int a_right, int b_right, int k) {        
        if (a_right &amp;lt; 0) {
            return b[b_right - k + 1];
        }
        if (b_right &amp;lt; 0) {
            return a[a_right - k + 1];
        }
        if (k == 1) {
            return max(a[a_right], b[b_right]);
        }        
        int p = (a_right - k/2 + 1 &amp;gt;= 0) ? a[a_right - k/2 + 1] : INT_MIN;
        int q = (b_right - k/2 + 1 &amp;gt;= 0) ? b[b_right - k/2 + 1] : INT_MIN;

        if (p &amp;gt;= q) {
            return findKthLargest(a, b, a_right - k/2, b_right, k - k/2);
        }
        else {
            return findKthLargest(a, b, a_right, b_right - k/2, k - k/2);
        }
    }
    
    int findKthSmallest(const vector&amp;lt;int&amp;gt; &amp;amp; a, const vector&amp;lt;int&amp;gt; &amp;amp; b, int a_left, int b_left, int k) {
        if (a_left == a.size()) {
            return b[b_left + k - 1];
        } 
        if (b_left == b.size()) {
            return a[a_left + k - 1];
        }
        if (k == 1) {
            return min(a[a_left], b[b_left]);
        }
        // p: half kth smallest in array a
        int p = (a_left + k/2 - 1) &amp;lt; a.size()? a[a_left + k/2 - 1] : INT_MAX;
        // q: half kth smallest in array a
        int q = (b_left + k/2 - 1) &amp;lt; b.size()? b[b_left + k/2 - 1] : INT_MAX;
        
        //discard 
        if (p &amp;lt; q) {    
            return findKthSmallest(a, b, a_left + k/2, b_left, k - k/2);
        } else {
            return findKthSmallest(a, b, a_left, b_left + k/2, k - k/2);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference: &lt;a href=&#34;https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/&#34;&gt;https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Follow up: find Kth smallest element in m sorted arrays&lt;/p&gt;

&lt;h3 id=&#34;find-kth-smallest-element-in-a-sorted-matrix&#34;&gt;Find Kth smallest element in a sorted matrix&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/&#34;&gt;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int k) {
        return helper(matrix, k, matrix.front().front(), matrix.back().back());   
    }
    
    int helper(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int k, int left, int right) {
        if (left &amp;gt;= right) {
            return left;
        }
        //pick a reference value
        int mid = left + (right - left)/2;
        int n = matrix.size(); 
        int m = 0;
        //counts number of elements smaller than or equal to mid
        for (int i = 0; i &amp;lt; n; i++) {
                          
            /* 
             * 
             *The upper bound idea if optimized from:
              for (int j = 0; j &amp;lt; matrix[i].size(); j++) {
                  if (matrix[i][j] &amp;lt;= mid) {
                      m++;
                  }
              }
             * using for loop is the basic idea to help understand,
             * actually we can use binary search again to find the smallest element that larger than mid
             */            

            int num = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            m += num;
        }
        // now we know that there are m elements &amp;lt;= mid[include mid]
        // thus mid is m th smallest element in the matrix
        // if m == k, actually mid is the kth 
        // if m &amp;lt; k, then kth smallest element must appear after mid
        // otherwise, kth element must appear before mid

        if (m &amp;lt; k) {
            return helper(matrix, k, mid + 1, right);
        } else {
            return helper(matrix, k, left, mid);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;more-questions&#34;&gt;More questions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/&#34;&gt;Kth smallest number in multiplication table&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/&#34;&gt;Find kth smallest pair distance&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/&#34;&gt;Kth element two sorted arrays&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-k-closest-elements/&#34;&gt;Find K closest elements&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/&#34;&gt;Kth smallest element in a sorted matrix&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dynamic-programming-and-binary-search&#34;&gt;Dynamic programming and binary search&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/&#34;&gt;Longest Increasing Subsequence&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/russian-doll-envelopes/description/&#34;&gt;Russian Doll Envelopes&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;浮点类型&#34;&gt;浮点类型&lt;/h2&gt;

&lt;p&gt;浮点类型往往需要引入最小收敛精度，当搜索空间越来越小知道逼近到这个精度的时候停止搜索。不要乱加这个精度，不要乱加这个精度，不要乱加这个精度。&lt;/p&gt;

&lt;h3 id=&#34;calculate-square-root&#34;&gt;Calculate Square Root&lt;/h3&gt;

&lt;p&gt;Here is a very intuitive binary search solution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double sqrt(const double number) {
    const double e = 1.0e-7;
    double left, right, guess;
    
    if (number &amp;lt; 1) {
        left = number;
        right = 1;
    }
    else {
        left = 1;
        right = number;
    }
    
    while ((right - left) &amp;gt; e) {
        guess = left + (right - left) / 2;
        if (guess &amp;gt; number / guess) {
            right = guess;
        }
        else {
            left = guess;
        }
    }
    return left + (right - left) / 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to Newton–Raphson method,&lt;/p&gt;

&lt;p&gt;$$ x_{n+1} = x_n - \frac{f(x_n)}{f&amp;rsquo;(x_n)}$$&lt;/p&gt;

&lt;p&gt;Here $f(x_n) = {x_n}^2 - S = 0$, so we can deduce that，&lt;/p&gt;

&lt;p&gt;$$x_{n+1} = x_n -  \frac{f(x_n)}{f&amp;rsquo;(x_n)} =  x_n - \frac{{x_n}^2 - S}{2x_n} = \frac{1}{2}(x_n + \frac{S}{x_n})$$&lt;/p&gt;

&lt;p&gt;Based on this induction rule, we can do a binary search in the space.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double sqrt(const double num) {
    const double e = 1.0e-7;
    double guess = num / 2;
    while (abs(guess * guess - num) &amp;gt; e) {
        guess = (guess + num / guess) / 2;
    }
    return guess;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;calculate-pow-x-n&#34;&gt;Calculate pow(x, n)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    double myPow(double x, int n) {
        if (n &amp;lt; 0) {
            return 1.0 / helper(x, -n);
        } else {
            return helper(x , n); 
        }
    }
    
    double helper(double x, int n) {
        if (n == 0) {
            return 1;
        }
        double v = helper(x, n / 2);
        //return (n % 2 == 0)? helper(x, n / 2) * helper(x, n / 2) : helper(x, n / 2) * helper(x, n / 2) * x;
        return (n % 2 == 0)? v * v : v * v * x;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference: &lt;a href=&#34;https://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi&#34;&gt;Best Square Root Method&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kalman Filter</title>
      <link>https://pineal.github.com/posts/kalman_filter/</link>
      <pubDate>Tue, 24 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;purpose-and-usage&#34;&gt;Purpose and Usage&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Eliminate noise in measurements&lt;/li&gt;
&lt;li&gt;Generate non-observable states(e.g., Velocity from position signals)&lt;/li&gt;
&lt;li&gt;For prediction of future state&lt;/li&gt;
&lt;li&gt;Optimal filtering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;framework-and-model&#34;&gt;Framework and Model&lt;/h2&gt;

&lt;h3 id=&#34;given&#34;&gt;Given:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A discrete stochastic linear controlled dynamical system:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1}$$&lt;/p&gt;

&lt;p&gt;Each current signal value $x^k$ is a combination of previous signal value $x_{k-1}$ times a constant, a control signal $u_{k}$ and a process noise and a process noise signal $w_{k-1}$ (which usually considered as zero).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A measurement function, where $v_{k}$ is the measurement noise.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$ y_{k} = Hx_{k} + v_{k} $$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Assume the process noise and the measurement noise are both considered to be normal distribution that&lt;/p&gt;

&lt;p&gt;$$ p(w) \sim N (0, Q), $$&lt;/p&gt;

&lt;p&gt;$$ p(v) \sim N (0, R). $$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In reality, covariance matrix $Q$ and $R$ may change in every iteration. We assume they are constant here however.&lt;/p&gt;

&lt;h3 id=&#34;goal&#34;&gt;Goal:&lt;/h3&gt;

&lt;p&gt;Find the best (recursive) estimate of the state $x$ of the system.&lt;/p&gt;

&lt;h3 id=&#34;computational-origins&#34;&gt;Computational Origins&lt;/h3&gt;

&lt;p&gt;Define $e_{k}^{-}$ to be a priori state estimate at step k given knowledge of the process prior to step $k$, and define $e_{k}$  to be a posteriori state estimate at step $k$ given measurement $z_{k}$. Then a priori and a posteriori estimate errors can be defined as:&lt;/p&gt;

&lt;p&gt;$$e_{k}^{-} \equiv x_{k} - \hat{x}_{k}^{-}$$&lt;/p&gt;

&lt;p&gt;$$e_{k} \equiv x_{k} - \hat{x}_{k}$$&lt;/p&gt;

&lt;p&gt;The a priori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k}^{-} = E[e_{k}^{-}e_{k}^{-T}]$$&lt;/p&gt;

&lt;p&gt;The a posteriori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k} = E[e_{k}e_{k}^{T}]$$&lt;/p&gt;

&lt;p&gt;Then How can we optimally (linearly) combine the estimate and measurement to obtain the best reconstruction of ￼the true x?&lt;/p&gt;

&lt;p&gt;The answer given in “The Probabilistic Origins of the Filter” found.&lt;/p&gt;

&lt;p&gt;$$
   \hat{x} = \hat{x}_{k}^{-} - K \times residual
$$&lt;/p&gt;

&lt;p&gt;Where &lt;em&gt;residual&lt;/em&gt; is $z_k - H \hat{x}_{k}^{-}$. It also can be called as measurement innovation.&lt;/p&gt;

&lt;p&gt;The Kalman filter gains are derived by minimizing the posterior error covariance, resulting in&lt;/p&gt;

&lt;p&gt;$$K_k = \frac{P_k^-H^T}{(HP_k^-H^T + R)^{-1}}$$&lt;/p&gt;

&lt;p&gt;If the a priori estimate of the process noise is zero, Then&lt;/p&gt;

&lt;p&gt;$$K = 0$$&lt;/p&gt;

&lt;p&gt;If the measurement noise is zero&lt;/p&gt;

&lt;p&gt;$$K = H^{-1}$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linear Programming</title>
      <link>https://pineal.github.com/posts/linear_programming/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/linear_programming/</guid>
      <description>&lt;p&gt;$$\matrix{A} \times \matrix{X} = \matrix{B}  $$&lt;/p&gt;

&lt;p&gt;Coeffienent matrix&lt;/p&gt;

&lt;p&gt;A =&amp;gt; n * n, x vector of unknowns, B right hand side&lt;/p&gt;

&lt;p&gt;Linear system of equations.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;$$A \times X ≥ B$$&lt;/p&gt;

&lt;p&gt;Objective function&lt;/p&gt;

&lt;p&gt;$$C^T \times X $$&lt;/p&gt;

&lt;p&gt;linear&lt;/p&gt;

&lt;p&gt;Goal : Minimize the objective function&lt;/p&gt;

&lt;p&gt;E.g.:
$$
\cases{x1 - x2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x1 + x2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;Maximize
$x1 + 2x_2$&lt;/p&gt;

&lt;p&gt;###Simplex method
Only look at the vertex&lt;/p&gt;

&lt;p&gt;Start of one vertex, go clockwise, find the max before the value going down&lt;/p&gt;

&lt;p&gt;###Weighted vertex cover problem&lt;/p&gt;

&lt;p&gt;for G = (V, E), S $\in$ V in a set such that each edge has at least one end in S $W_i ≥ 0$ for each i $\in$ V $$W(S) = \sum i \in S w_i$$&lt;/p&gt;

&lt;p&gt;Objective: Minimize W(S)&lt;/p&gt;

&lt;p&gt;Model this as an LP&lt;/p&gt;

&lt;p&gt;x_i is a decision valuable for each node i \in V&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_1 - x_2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x_1 + x_2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_i = 0 &amp;amp; i \notin S \&lt;br /&gt;
x_i = 1 &amp;amp; i \in S
}
$$&lt;/p&gt;

&lt;p&gt;x_i + x_j ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;Minimize \sigma w_ix_i
Subject to
$x_i + x_j ≥ 1 for (i, j) \in E$
$x_i \in {0,1} for i \in V$  &amp;lt;= discreate&lt;/p&gt;

&lt;p&gt;Integer Programming&lt;/p&gt;

&lt;p&gt;Linear programming  (continues variables)
Integer Programming (discrete variables)
mixed integer programming&lt;/p&gt;

&lt;p&gt;Drop the requirement that x_i \in {0,1}
and solve the LP in poly time and find {x_i^*} between 0 and 1&lt;/p&gt;

&lt;p&gt;so that x_i^* + x_j^* ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;W_{LP} = \sigma w_ix_i^*&lt;/p&gt;

&lt;p&gt;S^* is the opt vertex cover set
W(S^*) = weight of the opt solution&lt;/p&gt;

&lt;p&gt;W(S^*) ≥ W_{LP}&lt;/p&gt;

&lt;p&gt;S is our approx. solution&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W&lt;em&gt;{LP}
W&lt;/em&gt;{LP} ≤ 2 * W(s^*)&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W(S^*)&lt;/p&gt;

&lt;p&gt;Solve the max. flow problem using LP. Variable are flow over edges.&lt;/p&gt;

&lt;p&gt;Maximize \sigma f{e}
subject to
0 ≤ f(e) ≤ c_e foe each edge e \in E
\sigma f(e) - \sigma f(e) = 0 for v \in V&lt;/p&gt;

&lt;p&gt;A = B
A - B ≥ 0
B - A ≥ 0&lt;/p&gt;

&lt;p&gt;Max flow with lower bounds on flow over the edges
objective function stays same
conservation of the flow stays same&lt;/p&gt;

&lt;p&gt;Cap constraint: l_e≤f(e)≤c_e for each edge e \in E&lt;/p&gt;

&lt;p&gt;###Multi commodity flow
f_i(e): flow of commodity i over edge e
\alpha_i: is the profit associated with one unit of flow for commodity i.&lt;/p&gt;

&lt;p&gt;We have m commodities&lt;/p&gt;

&lt;p&gt;Objective: maximize profit&lt;/p&gt;

&lt;p&gt;Maximize $\sigma&lt;em&gt;{l=i}^m \sigma&lt;/em&gt;{eoutofS} \alpha_i f_i(e)$&lt;/p&gt;

&lt;p&gt;subject to 0 ≤ \sigma_{i=1}^m f&lt;em&gt;i{e} ≤c&lt;/em&gt;{e} for each e \in E&lt;/p&gt;

&lt;p&gt;\sigma_{i=1}^m f&lt;em&gt;i{e} = \sigma&lt;/em&gt;{i=1}^m f_i{e} for each node v \in V and for each i = 1 to m&lt;/p&gt;

&lt;p&gt;###Shortest path using LP
Shortest distance from V to t is d(v) for each node V
For each node V
$$
d(t) ≤ d(y) + c&lt;em&gt;{yt} \&lt;br /&gt;
d(t) ≤ d(w) + c&lt;/em&gt;{wt} \&lt;br /&gt;
d(t) ≤ d(x) + c_{xt} \&lt;br /&gt;
$$&lt;/p&gt;

&lt;p&gt;d&lt;em&gt;{v} ≤ d&lt;/em&gt;{u} + w(u, v) for each edge (u, v) \in E
d(s) = 0&lt;/p&gt;

&lt;p&gt;Objective function:
    Minimize d(t)&lt;/p&gt;

&lt;p&gt;1:36&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NP problem</title>
      <link>https://pineal.github.com/posts/np_problem/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/np_problem/</guid>
      <description>&lt;p&gt;##Introduction&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Plan&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Explore the space of computationally hand problem to arrive at a mathematic characteristic a large d of them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Technique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Compare negative difficultly of different problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Problems can find a polynomial time algorithm to solve.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NP problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;An algorithm that can be verified if it is a solution to a problem or not in polynomial time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loose definition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If problem X in at least as hard as problem Y. It means that if we could solve X, we could also solve Y.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Y X&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Y is polynomial time reduced to X. If Y can be solved using a poly number of std computational steps plus a poly no of called to a black box to love X.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If X can be solved in polynomial time, then Y can be solved in polynomial time.&lt;/li&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If Y cannot be solved in polynomial time, then X cannot be solved in polynomial time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NP-Complete Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is NPC problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prove it is a NP problem.&lt;/li&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;NP hard Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is hard problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##Examples&lt;/p&gt;

&lt;p&gt;###Independent Set
Ref: Given a graph $G = (V,E)$, we say a set of nodes, $S \in V$ in independent if no two nodes in S and joined by an edge.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the maximum size independent set in graph G.(Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G and a number k, does G contain an independent set of size at least K.(Decision version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ans: No solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Vertex Cover
Ref: Given a $graph G=(V,E)$ we say that a set of nodes $S \in V$ in a vertex cover if every edge $e \in E$ has at least one end in S.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the smallest vertex cover set in G (Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G=(V,E) and a number k, G contain a vertex cover of size at most k.(Decision version)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Independent Set and Vertex Cover&lt;/p&gt;

&lt;p&gt;FACT: let G=(V,E) be a graph then S in an independent set if and only if its complement (V-S) is a vertex cover.&lt;/p&gt;

&lt;p&gt;S is an independent set.&lt;/p&gt;

&lt;p&gt;**case 1 **&lt;/p&gt;

&lt;p&gt;U is in S and V is not.
V-S will have V and not U.&lt;/p&gt;

&lt;p&gt;case 2
V is in S and U is not.
V-S will have U and not V&lt;/p&gt;

&lt;p&gt;case 3
Neither V or U are in the set&lt;/p&gt;

&lt;p&gt;Suppose V-S is a vertex cover can prove that S is an independent set.&lt;/p&gt;

&lt;p&gt;Claim: independent Set≤P vertex Cover
Prove If we have a black box to solve the vertex cover problem. We can decide if G has independent set of size at least k by asking the black box if G has a vertex cover of size at most n-k.&lt;/p&gt;

&lt;p&gt;Claim: Vertex cover ≤S independent Set&lt;/p&gt;

&lt;p&gt;Proof: if we have a black box to solve the independent set we can deicide if G has a vertex cover of size at most k by asking the black box if G has an independent set of size at least n-k.&lt;/p&gt;

&lt;p&gt;Set cover problem
Given a set U of n elements, a collection s_1 to s_m of sub sets of U and and a number of k, does there exist a collection of at most k of these sets whose union is equal to all of U.&lt;/p&gt;

&lt;p&gt;Set U = set of all edges in G
S1 = {(1, 2), (1,3)}
S2 = {(1,2), (2,3), (2,4), (2,5)}&lt;/p&gt;

&lt;p&gt;Proof of correction:
A) If we have a vertex cover of size k in G, then i can find a collection of k sets whose union is equal to all of U.
B) If I have a collection of k sets, whose union is equal to all of U, then I can find a vertex cover of size k in G.&lt;/p&gt;

&lt;p&gt;Given u bolean variable x1&amp;hellip;xn a&lt;/p&gt;

&lt;p&gt;a truth assignment fox X is an assignment of values 0 or 1 to each x_i&lt;/p&gt;

&lt;p&gt;An assignment satisfies a change C if it causes C to evaluate 1.&lt;/p&gt;

&lt;p&gt;An assignment satisfies a collection of if C1 and C2 and &amp;hellip; CK evaluate to 1.&lt;/p&gt;

&lt;p&gt;Given a set of closures C1 to Ck over a set of variables x - {x1, &amp;hellip; xn} does there exist a satisfying truth&lt;/p&gt;

&lt;p&gt;Problem statement
Given a set of&lt;/p&gt;

&lt;p&gt;Three set problem
Given an&lt;/p&gt;

&lt;p&gt;C1 = (x1, x2, x3)&lt;/p&gt;

&lt;p&gt;Efficient Certification&lt;/p&gt;

&lt;p&gt;ex: indenpendent set problem.
certificate is a set of nodes of size at least k.
certifier: go over every edge and check the if they are not both in S the edge is OK.
check the size of set S.&lt;/p&gt;

&lt;p&gt;Evaluate each clause&lt;/p&gt;

&lt;p&gt;If X \in NP and for all Y \in NP&lt;/p&gt;

&lt;p&gt;Is there a problem in NP that all other problem in NP can be reduced to it in polynomial time&lt;/p&gt;

&lt;p&gt;Basic strategy to probe a problem X is NP-complete
1.prove X \in nP
2.choose a problem Y that is known to be NP-complete
3.Prove that Y≤pX&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>