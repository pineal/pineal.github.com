<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PINEAL.ME</title>
    <link>https://pineal.github.com/</link>
    <description>Recent content on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Sep 2018 09:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://pineal.github.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dynamic Programming III</title>
      <link>https://pineal.github.com/posts/dynamic_programming_iii/</link>
      <pubDate>Sat, 08 Sep 2018 09:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_iii/</guid>
      <description>背包问题 0-1 背包问题 Question Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays $values[0..n-1]$ and $weights[0..n-1]$ which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of $values[0..n-1]$ such that sum of the weights of this subset is smaller than or equal to W.</description>
    </item>
    
    <item>
      <title>Dynamic Programming II</title>
      <link>https://pineal.github.com/posts/dynamic_programming_ii/</link>
      <pubDate>Sat, 08 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_ii/</guid>
      <description>Coin game winner A and B are playing a game. At the beginning there are n coins. Given two more numbers x and y. In each move a player can pick x or y or 1 coins. A always starts the game. The player who picks the last coin wins the game. For a given value of n, find whether A will win the game or not if both are playing optimally.</description>
    </item>
    
    <item>
      <title>Shortest Path</title>
      <link>https://pineal.github.com/posts/shortest_path_problems/</link>
      <pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/shortest_path_problems/</guid>
      <description>Maze I bool hasPath(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; maze, vector&amp;lt;int&amp;gt; &amp;amp; start, vector&amp;lt;int&amp;gt; &amp;amp; dest) { const vector&amp;lt;int&amp;gt; dx = {0, -1, 1, 0}; const vector&amp;lt;int&amp;gt; dy = {1, 0, 0, -1}; queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q; q.emplace(start[0], start[1]); maze[start[0]][start[1]] = 2; int m = maze.size(); int n = maze.front().size(); while (!q.empty()) { auto cur = q.front(); q.pop(); int x = cur.first; int y = cur.second; if (x == dest[0] &amp;amp;&amp;amp; y == dest[1]) { return true; } for (int i = 0; i &amp;lt; 4; i++) { int xx = x; int yy = y; while (xx &amp;gt;= 0 &amp;amp;&amp;amp; xx &amp;lt; m &amp;amp;&amp;amp; yy &amp;gt;= 0 &amp;amp;&amp;amp; yy &amp;lt; n &amp;amp;&amp;amp; maze[xx][yy] !</description>
    </item>
    
    <item>
      <title>Depth first search in matrix</title>
      <link>https://pineal.github.com/posts/dfs/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dfs/</guid>
      <description>Robot Room Cleaner Given a robot cleaner in a room modeled as a grid.
Each cell in the grid can be empty or blocked.
The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.
When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.
Design an algorithm to clean the entire room using only the 4 given APIs shown below.</description>
    </item>
    
    <item>
      <title>Voting Algorithm</title>
      <link>https://pineal.github.com/posts/voting_algorithm/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/voting_algorithm/</guid>
      <description>Majority Element 俄罗斯方块的消除方式。出现两个不一样的消除：counter 减一。
 A A B -&amp;gt; 消除  classSolution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int major; int count = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { if (count == 0) { major = nums[i]; count++; } else { count += (nums[i] == major)? 1 : -1; } } return major; } };  Majority Element II 同理：俄罗斯方块的消除方式，当出现三个不一样的时候消除。 要注意的是，最后得到的candidate，需要再过一遍数组来确定是不是最后的答案。
classSolution { public: vector&amp;lt;int&amp;gt; majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int x = 0; int y = 1; //just need to be different test with case [0,0,0,0,0,0]  int cnt1 = 0; int cnt2 = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>Dynamic Programming I</title>
      <link>https://pineal.github.com/posts/dynamic_programming_i/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_i/</guid>
      <description>Max Product Of Cutting Rope Given a rope with positive integer-length n, how to cut the rope into m integer-length parts with length $p[0], p[1], &amp;hellip;,p[m-1]$, in order to get the maximal product of $p[0]p[1] &amp;hellip; p[m-1]$? m is determined by you and must be greater than 0 (at least one cut must be made). Return the max product you can have.
Example n = 12, the max product is 3 * 3 * 3 * 3 = 81 (cut the rope into 4 pieces with length of each is 3).</description>
    </item>
    
    <item>
      <title>Topics on Gragh Algorithm</title>
      <link>https://pineal.github.com/posts/graph_algorithms/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/graph_algorithms/</guid>
      <description>Graph Graph Representing https://www.geeksforgeeks.org/graph-and-its-representations/
https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs
Adjacent Matrix Adjacent List https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/
https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/
Edges Traversal BFS DFS  Pacific Atlantic Water Flow
 start from matrix start from occean  Clone Graph follow up: reverse if DAG
  Evaluate Division classSolution { public: double dfs(string cur, const string &amp;amp; dest, unordered_set&amp;lt;string&amp;gt; visited, unordered_map&amp;lt;string, unordered_map&amp;lt;string, double&amp;gt;&amp;gt; &amp;amp; edges) { if (!edges.count(cur)) { return -1.0; } if (cur == dest) { return 1.</description>
    </item>
    
    <item>
      <title>Basic Backtracking Problems</title>
      <link>https://pineal.github.com/posts/backtracking/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/backtracking/</guid>
      <description>Introduction Backtracking 类型的题目最重要的是想清楚每一层在做什么，以及到下一层一共有几个分叉。
时间复杂度： branch factor ^ level
时间复杂度： call stack -&amp;gt; level
Subsets 这一类的题目的框架为，在递归树中的第 i 层，代表正在处理 nums 里的第 i 个元素。 从该层的父节点一定会伸展出两个分叉： 第一个分叉代表着一层会放这个元素，第二个分叉代表不放这个元素。 这样出来的递归树非常平衡。
Subsets I classSolution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst; sort(nums.begin(), nums.end()); vector&amp;lt;int&amp;gt; cur; dfs(rst, cur, nums, 0); return rst; } void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; rst, vector&amp;lt;int&amp;gt; &amp;amp; cur, const vector&amp;lt;int&amp;gt;&amp;amp; nums, int level) { if (level == nums.size()) { rst.emplace_back(cur); return; } cur.emplace_back(nums[level]); dfs(rst, cur, nums, level + 1); cur.</description>
    </item>
    
    <item>
      <title>Extended Kalman Filter</title>
      <link>https://pineal.github.com/posts/extended_kalman_filter/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/extended_kalman_filter/</guid>
      <description>Review of Kalman filter  Previous post on basic kalman filter iLecture lessons  Distribution of Gausion is not Gaussian, it becomes non-linear
Extented Kalman filter uses a linear approximation of h(x) Here we use first order taylor expansion to
Given a function f(x), a taylor series expansion could be expressed:
$$f(x) \approx \frac{\partial{f(\mu)} }{\partial{x}}(x - \mu)$$
Multivariate Taylor Series Design Kalman Filter for 1D tracking problem We need to define two linear functions: 1.</description>
    </item>
    
    <item>
      <title>Cache Design</title>
      <link>https://pineal.github.com/posts/cache_design/</link>
      <pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/cache_design/</guid>
      <description>Cache Design LRU  LFU  Implementation link</description>
    </item>
    
    <item>
      <title>Kth Problems</title>
      <link>https://pineal.github.com/posts/kth_problems/</link>
      <pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kth_problems/</guid>
      <description>Kth Problems Solution with priority queue 套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).
Merge k Sorted Lists //Time O(nlogk) //Space O(n) //provides greater struct Cmp { bool operator() (ListNode* n1, ListNode* n2) { return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val; } }; classSolution { public: ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { //min_heap needs a greater comparator  //Method 1: redefine functor  //priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, Cmp&amp;gt; min_heap;  //Method 2: Lambda  auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;}; priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp); //maintain the min_heap of size k instead of all nodes  // klogn =&amp;gt; nlogk  for (int i = 0; i &amp;lt; lists.</description>
    </item>
    
    <item>
      <title>Data Structures for Disjoint Sets</title>
      <link>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</guid>
      <description>Disjoint Sets 基本操作  make_set(x) 将一个vertex变成一个disjoint
 union(x, y) 将包含vertex x 的 set 和 包含vertex y 的 set 并起来
 find_set(x) 返回一个指针，指向包含这个vertex 的唯一的 set
  Basic implementation 最基本的应用是来确定一个 undirected graph 中的 connected components.
连接components:
connected_component(G) for each vertex v in G make_set(v) for each edge(u, v) e in G if (find_set(u) != find_set(v)) union(u, v) 判断两个vertices是否连接在同一component中:
same_component(u, v) if find_set(u) == find_set(v) return true else return false Example Number of Connected Components in an Undirected Graph classSolution { public: //compress the path and return the root of the union set  int find_set(vector&amp;lt;int&amp;gt; &amp;amp; allsets, int node) { if (node !</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://pineal.github.com/posts/bit_manipulation/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/bit_manipulation/</guid>
      <description>Summary of Basic Bit Manipulation Count 1 in Binary 数的二进制表示中有多少位1. 有两种方法。
 每次把各位的数和 1 做 &amp;amp; 运算，然后计数，右移进行下一位。  classSolution { public: /** * @param num: an integer * @return: an integer, the number of ones in num */ int countOnes(int num) { // write your code here  int counter = 0; for (int i = 0; i &amp;lt; sizeof(int)*8; i++) { counter += num &amp;amp; 1; num &amp;gt;&amp;gt;= 1; } return counter; } };   把 num 和 num - 1 做 &amp;amp; 运算， 直到num为0，有多少次运算就有多少个1.</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://pineal.github.com/posts/sorting_algorithms/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sorting_algorithms/</guid>
      <description>假设这里的排序都是升序。
Merge Sort: 归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。
// merge part  vector&amp;lt;int&amp;gt; merge(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) { vector&amp;lt;int&amp;gt; rst; std::vector&amp;lt;int&amp;gt;::iterator iter1 = A.begin(), iter2 = B.begin(); while (iter1 != A.end() || iter2 != B.end()) { if (iter1 == A.end()) { rst.insert(rst.end(), iter2, B.end()); break; } if (iter2 == B.end()) { rst.insert(rst.end(), iter1, A.end()); break; } if (*iter1 &amp;lt; *iter2) { rst.emplace_back(*iter1); iter1++; } else { rst.emplace_back(*iter2); iter2++; } } return rst; } // key part of merge sort, recursive function  vector&amp;lt;int&amp;gt; MSort(vector&amp;lt;int&amp;gt; array, int left, int right) { vector&amp;lt;int&amp;gt; rst; if (left == right) { rst.</description>
    </item>
    
    <item>
      <title>Optimal Control</title>
      <link>https://pineal.github.com/posts/optimal_control/</link>
      <pubDate>Sat, 26 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/optimal_control/</guid>
      <description>Optimal Control Optimal Control Framework Given: A controlled dynamical system：$ x^{n+1} = f(x^n, u^n)$
A cost function：$V = \phi(x^N, \alpha) + \sum^{N-1}_{i=0}L(x^i, u^i, \alpha)$
Goal: Find the sequence of commands that minimizes(maximizes) the cost function
Bellman&amp;rsquo;s Principle of Optimality Optimize it using dynamic programming:
$$ J_i(Xi) = \mathop{arg min}{u_i\in u(xi)}{{L(x^i, u^i, \alpha) + V^*{i+1}x_{(i+1)}}} $$
Linear quadratic regulator Special Assumption: Linear System Dynamics $$ x^{n+1} = Ax^n + Bu^n $$</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://pineal.github.com/posts/binary_tree/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_tree/</guid>
      <description>Intro Concepts  Full Binary Tree: 全部都填满的树。
 Complete Binary Tree: 除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。
 Balanced Binary Tree: 左右子树的高度最多差1. Height of the tree: $O(log(n))$
 Binary Search Tree: Recursively, Leftsubtree is smaller than root and righ subtree is larger than root. Inorder traverse is increasing.
  Traverse Example  Preorder: 8-&amp;gt;3-&amp;gt;1-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;10-&amp;gt;14-&amp;gt;13 Inorder: 1-&amp;gt;3-&amp;gt;4-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;10-&amp;gt;13-&amp;gt;14 Postorder: 1-&amp;gt;4-&amp;gt;7-&amp;gt;6-&amp;gt;3-&amp;gt;13-&amp;gt;14-&amp;gt;10-&amp;gt;8 Levelorder: 8-&amp;gt;3-&amp;gt;10-&amp;gt;1-&amp;gt;6-&amp;gt;14-&amp;gt;4-&amp;gt;7-&amp;gt;13  Traverse Recursively void helper(TreeNode* node, vector&amp;lt;int&amp;gt; &amp;amp; rst){ if (node != nullptr){ // rst.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://pineal.github.com/posts/binary_search/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_search/</guid>
      <description>经典二分搜索及其变种 二分搜索的核心思想是，在给定的搜索空间内，排除掉一定不对的那一部分。应用场景往往是有序的，或者局部有序的。这样从 $O(n)$ 可以优化到 $O(logn)$. 搜索空间的定义可以是具体的值，也可以是数组的索引，需要具体问题具体分析。
Classic binary search int classic_binary_search(vector&amp;lt;int&amp;gt; input, int target) { if (input.empty()) { return -1; } int left = 0; int right = input.size() - 1; while (left &amp;lt;= right){ int mid = left + (right - left)/2; if (input[mid] == target){ return mid; } else if (input[mid] &amp;lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; } };  find last/first index of target int find_first_index(vector&amp;lt;int&amp;gt; input, int target) { if (input.</description>
    </item>
    
    <item>
      <title>Kalman Filter</title>
      <link>https://pineal.github.com/posts/kalman_filter/</link>
      <pubDate>Tue, 24 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kalman_filter/</guid>
      <description>Purpose and Usage  Eliminate noise in measurements Generate non-observable states(e.g., Velocity from position signals) For prediction of future state Optimal filtering  Framework and Model Given:  A discrete stochastic linear controlled dynamical system:  $$x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1}$$
Each current signal value $x^k$ is a combination of previous signal value $x_{k-1}$ times a constant, a control signal $u_{k}$ and a process noise and a process noise signal $w_{k-1}$ (which usually considered as zero).</description>
    </item>
    
    <item>
      <title>Linear Programming</title>
      <link>https://pineal.github.com/posts/linear_programming/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/linear_programming/</guid>
      <description>$$\matrix{A} \times \matrix{X} = \matrix{B} $$
Coeffienent matrix
A =&amp;gt; n * n, x vector of unknowns, B right hand side
Linear system of equations.
$$A \times X ≥ B$$
Objective function
$$C^T \times X $$
linear
Goal : Minimize the objective function
E.g.: $$ \cases{x1 - x2 ≥ 0 \
x_1 ≥ 0 \
x_2 ≥ 0 \
x1 + x2 ≤ 4 }$$
Maximize $x1 + 2x_2$
###Simplex method Only look at the vertex</description>
    </item>
    
    <item>
      <title>NP problem</title>
      <link>https://pineal.github.com/posts/np_problem/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/np_problem/</guid>
      <description>##Introduction
Plan
Explore the space of computationally hand problem to arrive at a mathematic characteristic a large d of them.
Technique
Compare negative difficultly of different problem.
P problem
Problems can find a polynomial time algorithm to solve.
NP problem
An algorithm that can be verified if it is a solution to a problem or not in polynomial time.
Loose definition
If problem X in at least as hard as problem Y.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://pineal.github.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/about/</guid>
      <description> Hesen Zhang  Birthday: 13th, July, 1991 Hometown: Ningbo, China Email: hesen.zhang@gmail.com Github: https://github.com/pineal LinkedIn: http://www.linkedin.com/in/hesenzhang/   Education Background  MSc on Computer Science in University of Southern California, U.S. BEng on Electronics Engineering in University of Liverpool, U.K.  Research Interests  Robotics AI Game Programming Networks  Cool things  Photography/Videography Reading Soccer Music/Guitar  </description>
    </item>
    
    <item>
      <title>Archives</title>
      <link>https://pineal.github.com/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Categories</title>
      <link>https://pineal.github.com/categories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/categories/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Tags</title>
      <link>https://pineal.github.com/tags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/tags/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>