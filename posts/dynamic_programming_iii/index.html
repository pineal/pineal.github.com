<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>DP III - Knapsack Problems</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="DP III - Knapsack Problems">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="DP III - Knapsack Problems">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.github.com/posts/dynamic_programming_iii/">
	<meta name="og:site_name" content="DP III - Knapsack Problems">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Dynamic Programming ">
	<link rel="stylesheet" type="text/css" href="https://pineal.github.com/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.github.com/" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.github.com/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.github.com/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.github.com/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>DP III - Knapsack Problems</h1>
  <aside> <nav id="TableOfContents">
<ul>
<li><a href="#背包问题">背包问题</a>
<ul>
<li><a href="#0-1-背包问题">0-1 背包问题</a>
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#analyze">Analyze</a></li>
<li><a href="#solution">Solution</a></li>
<li><a href="#space-optimization">Space Optimization</a></li>
<li><a href="#print-all-items">Print all items</a></li>
<li><a href="#house-robber">House Robber</a></li>
</ul></li>
<li><a href="#完全背包问题">完全背包问题</a>
<ul>
<li><a href="#example-coin-change-ii">Example - Coin Change II</a></li>
<li><a href="#time-optimization">Time Optimization</a></li>
<li><a href="#space-optimization-1">Space Optimization</a></li>
<li><a href="#minimum-number-of-refueling-stops">Minimum Number of Refueling Stops</a></li>
</ul></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
</nav></aside>
  

<h1 id="背包问题">背包问题</h1>

<h2 id="0-1-背包问题">0-1 背包问题</h2>

<h3 id="question">Question</h3>

<p>Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays $values[0..n-1]$ and $weights[0..n-1]$ which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, <strong>find out the maximum value subset of $values[0..n-1]$ such that sum of the weights of this subset is smaller than or equal to W</strong>. You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).</p>

<ul>
<li>From: <a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">GeekforGeeks</a></li>
</ul>

<h3 id="analyze">Analyze</h3>

<p>每件物品只有一个，那么考虑最后一个物品 $i$ ，一共就放或者不放两种状态选择。如果不放第 $i$ 件物品，那么问题转化为 前 $i-1$ 件物品放入到容量为 $j$ 的背包中, 即为 $M[i, j] = M[i-1, j]$。如果放第 $i$ 件物品，那么就是 前 $i-1$ 件物品放到容量为 $j-W_i$ 的背包中的 $value$ 加上把第 $i$ 件物品放入背包中的价值，即为 $M[i, j] = M[i-1, j - weights_i + values_i]$.</p>

<p>此外，这个问题问得是得到的结果尽可能大，并不要求背包正好装满，初始化的时候都是 0。 如果要求恰好装满背包，那么除了 $M[0, 0]$ 初始化为 0 之外，其他都初始化为负无穷大。这样就可以保证最终的到的结果是一种恰好装满背包的最优解。</p>

<h3 id="solution">Solution</h3>

<pre><code class="language-cpp">int knapsack(int W, vector&lt;int&gt; weights, vector&lt;int&gt; values) {
    int n = weights.size();
    vector&lt;vector&lt;int&gt;&gt; M(n + 1, vector&lt;int&gt;(W + 1, 0));
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= W; j++) {
            if (weights[i - 1] &lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    return M.back().back();
}
</code></pre>

<h3 id="space-optimization">Space Optimization</h3>

<p>如果对以上代码填表，可以更直观的显示出当前状态只跟上一行的状态有关。所以空间复杂度可以优化到 $O(n)$.</p>

<pre><code class="language-cpp">int knapsack(int W, vector&lt;int&gt; weights, vector&lt;int&gt; values) {
    int n = weights.size();
    vector&lt;int&gt; M(W + 1, 0);
    for (int i = 0; i &lt; n; i++) {
        for (int j = W; j &gt;= weights[i]; j--) {
            M[j] = max(M[j], values[i] + M[j - weights[i]]);
        }
    }
    return M.back();
}
</code></pre>

<h3 id="print-all-items">Print all items</h3>

<pre><code class="language-cpp">int knapsack(int W, vector&lt;int&gt; weights, vector&lt;int&gt; values) {
    int n = weights.size();
    vector&lt;vector&lt;int&gt;&gt; M(n + 1, vector&lt;int&gt;(W + 1, 0));
    //M[0][0] = 0;
    for (int i = 0; i &lt;= n; i++) {
        for (int j = 0; j &lt;= W; j++) {
            if (weights[i - 1] &lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    int res =  M.back().back();
    for (int i = n; i &gt; 0 &amp;&amp; res &gt; 0; i--) {
        if (res == M[i-1][W])
            continue;
        else {
            cout &lt;&lt; weights[i-1] &lt;&lt; &quot; &quot;;
        }
        res -= values[i-1];
        W = W - weights[i-1];
    }
    return res;
}
</code></pre>

<h3 id="house-robber">House Robber</h3>

<pre><code class="language-cpp">class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() &lt;= 2) {
            return max(nums[0], nums.back());
        }
        vector&lt;int&gt; M(nums.size(), 0);
        M[0] = nums[0];
        M[1] = max(nums[0], nums[1]);
        for (int i = 2; i &lt; M.size(); i++) {
            M[i] = max(M[i - 2] + nums[i], M[i - 1]);
        }
        return M.back();
    }
};
</code></pre>

<h2 id="完全背包问题">完全背包问题</h2>

<p>由于每个物品的数量变成了无限，那么从0-1背包问题转变过来，从取或者不取两种状态转换到了取0个，取1个到最多取 $k = \frac{Capacity}{weights[i]}$ 个。</p>

<h3 id="example-coin-change-ii">Example - Coin Change II</h3>

<pre><code class="language-cpp">//O(n*amount*amount)
//O(mn)
class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int n = coins.size();
        /*
        M[i][j] =&gt; the number of combinations to make up amount j with the first i types of coins
        M[i][j] =   M[i-1][j],                   use coins[i-1] 0 times
                  + M[i-1][j - coins[i-1]]       use coins[i-1] 1 time
                  + M[i-1][j- coins[i-1] * 2]    use coins[i-1] 2 times
                  + M[i-1][j- coins[i-1] * 3]    use coins[i-1] 3 times
                  ...
        */
        vector&lt;vector&lt;int&gt;&gt; M(n + 1, vector&lt;int&gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                M[i][j] = 0;
                for (int k = 0; k * coins[i - 1] &lt;= j; k++) {
                    M[i][j] += M[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return M.back().back();
    }
};
</code></pre>

<h3 id="time-optimization">Time Optimization</h3>

<pre><code class="language-cpp">//O(n*amount)
//O(mn)
class Solution {
public:
    /*
        1.
        f[i][j] = f[i-1][j]
                + f[i-1][j - coins[i-1]]
                + f[i-1][j - coins[i-1] * 2]
                + f[i-1][j - coins[i-1] * 3]
                ...
        2.
        f[i][j - coins[i-1]]
                = f[i-1][j-coins[i-1]]
                + f[i-1][j-coins[i-1] * 2]
                + f[i-1][j-coins[i-1] * 3]
                ...
        3.
        f[i][j] = f[i-1][j]
                + f[i][j - coins[i-1]]
    */
    
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int n = coins.size();
        vector&lt;vector&lt;int&gt;&gt; M(n + 1, vector&lt;int&gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                M[i][j] = M[i-1][j] + (coins[i-1] &lt;= j? M[i][j - coins[i - 1]] : 0);
            }
        }
        return M.back().back();
    }
};
</code></pre>

<h3 id="space-optimization-1">Space Optimization</h3>

<pre><code class="language-cpp">//O(n*amount)
//O(amount)
class Solution {
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) {
        int n = coins.size();
        vector&lt;int&gt; M(amount + 1, 0);
        M[0] = 1;
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 0; j &lt;= amount; j++) {
                if (coins[i-1] &lt;= j) {
                    M[j] += M[j - coins[i -1]];
                }
            }
        }
        return M.back();
    }
};
</code></pre>

<h3 id="minimum-number-of-refueling-stops">Minimum Number of Refueling Stops</h3>

<p>Recursive - LTE</p>

<pre><code class="language-cpp">class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) {
        if (stations.empty()) return startFuel &gt;= target? 0 : -1;
        stations.insert(stations.begin(), {0, startFuel});
        int res = INT_MAX;
        helper(0, res, 0, startFuel, stations, target);
        return res == INT_MAX? -1 : res;
    }
    
    
    void helper(int level, int &amp; res, int num, int remain, const vector&lt;vector&lt;int&gt;&gt; &amp; stations, int target) {
        if (remain &lt; 0) {
            return;
        }
        if (level == stations.size()) {            
            res = min(res, num);
            return;
        }
        int cost = (level == stations.size() - 1)? target - stations[level][0] : stations[level + 1][0] - stations[level][0];
        int refuel = (level == stations.size() - 1)? 0 : stations[level+1][1];
        if (cost &lt;= remain) {
            helper(level + 1, res, num, remain - cost, stations, target);
            helper(level + 1, res, num + 1, remain - cost + refuel, stations, target);        
        }

    }
};
</code></pre>

<p>DP knapsack solution</p>

<pre><code class="language-cpp">class Solution {
public:
    // dp[i][j]: pick j stops to refill from [0, i] stops, how far away can we go
    // dp[i][j] = max {dp[i-1][j] &gt;= stations[i-1][0] ? dp[i-1][j] : 0
    //          =      dp[i-1][j-1] &gt;= stations[i-1][0] ? dp[i-1][j-1] + stations[i-1][1] : 0 }
    // 
    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) {
        int n = stations.size();
        vector&lt;vector&lt;long&gt;&gt; M(n+1, vector&lt;long&gt;(n+1, 0));
        
        M[0][0] = startFuel;
        for (int i = 1; i &lt;= n; i++) {
            if (startFuel &gt;= stations[i-1][0])
                M[i][0] = startFuel;
        }
        
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= i; j++) {
                if (M[i-1][j] &gt;= stations[i-1][0]) {
                    M[i][j] = M[i-1][j];
                }
                if (M[i-1][j-1] &gt;= stations[i-1][0]) {
                    M[i][j] = max(M[i][j], M[i-1][j-1] + stations[i-1][1]);
                }
                    
            }
        }
        for (int t = 0; t &lt;= n; ++t)
            if (M[n][t] &gt;= target) return t;
        return -1;
    }
};
</code></pre>

<p>TODO: space optimization</p>

<h2 id="reference">Reference</h2>

<ul>
<li><a href="https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf">背包九讲</a></li>
<li><a href="https://www.youtube.com/watch?v=ZKAILBWl08g">https://www.youtube.com/watch?v=ZKAILBWl08g</a></li>
</ul>


  <a href="/tags/dynamic-programming/">Dynamic Programming</a></a>&nbsp;&nbsp;&nbsp;

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
