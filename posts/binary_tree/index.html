<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Binary Tree - PINEAL.ME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://pineal.github.com/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.51f9758ebedaebb8122900b7464b612d113097d9e170af8375c7cb311bb6a003.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-posts">
      <a href="/posts/">
        <span>Posts</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-posts">
      <a href="/posts/">
        <span>Posts</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>



    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Binary Tree</h1>
<div class="content">
  

<h2 id="intro">Intro</h2>

<h3 id="concepts">Concepts</h3>

<ol>
<li><p>Full Binary Tree: 全部都填满的树。</p></li>

<li><p>Complete Binary Tree: 除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。</p></li>

<li><p>Balanced Binary Tree: 左右子树的高度最多差1. Height of the tree: $O(log(n))$</p></li>

<li><p>Binary Search Tree: Recursively, Leftsubtree is smaller than root and righ subtree is larger than root. Inorder traverse is increasing.</p></li>
</ol>

<h2 id="traverse">Traverse</h2>

<h3 id="example">Example</h3>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png" alt="example" /></p>

<ul>
<li>Preorder: 8-&gt;3-&gt;1-&gt;6-&gt;4-&gt;7-&gt;10-&gt;14-&gt;13</li>
<li>Inorder:  1-&gt;3-&gt;4-&gt;6-&gt;7-&gt;8-&gt;10-&gt;13-&gt;14</li>
<li>Postorder: 1-&gt;4-&gt;7-&gt;6-&gt;3-&gt;13-&gt;14-&gt;10-&gt;8</li>
<li>Levelorder: 8-&gt;3-&gt;10-&gt;1-&gt;6-&gt;14-&gt;4-&gt;7-&gt;13</li>
</ul>

<h3 id="traverse-recursively">Traverse Recursively</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">helper</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">rst</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">){</span>
<span class="c1">//      rst.emplace_back(root -&gt; val);  If it is PreOder
</span><span class="c1"></span>        <span class="n">helper</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
<span class="c1">//      rst.emplace_back(root -&gt; val);  If it is InOrder
</span><span class="c1"></span>        <span class="n">helper</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
<span class="c1">//      rst.emplace_back(root -&gt; val);  If it is PostOrder
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">DFS_Traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write your code here
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">;</span>
    <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rst</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="preorder-iterative">Preorder iterative</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">pushleft</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">pushleft</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="n">pushleft</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="inorder-iterative">Inorder Iterative</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">pushleft</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">pushleft</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="n">pushleft</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="postorder-iterative-i">Postorder iterative I</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">postorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">s1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s2</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="n">s1</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s1</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s2</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s2</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="postorder-iterative-ii">Postorder iterative II</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">postorderII</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">||</span> <span class="n">prev</span> <span class="o">==</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="bfs-level-order">BFS level order</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">rst</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">nodes</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">nodes</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">level</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="n">nodes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>    
        <span class="p">}</span>
        <span class="n">rst</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="n">rst</span><span class="p">;</span>    
<span class="p">}</span>
</code></pre></div>
<h3 id="morris-traverse-todo">Morris Traverse(TODO)</h3>

<h2 id="binary-tree-iterator">Binary Tree Iterator</h2>

<h3 id="implementation">Implementation</h3>

<p><a href="https://github.com/pineal/-O_O-/blob/d600d536acf50c6d3299e99b200a4c247b79ece7/Binary_Tree/Binary_Tree_Iterator.cpp">Link</a></p>

<h3 id="bst-iterator">BST iterator</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">BSTIterator</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BSTIterator</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/** @return whether we have a next smallest number */</span>
    <span class="kt">bool</span> <span class="n">hasNext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/** @return the next smallest number */</span>
    <span class="c1">//which means ascending order
</span><span class="c1"></span>    <span class="c1">//which means inoredr traversal
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">parent</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">parent</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="different-views-of-tree">Different views of tree</h2>

<h3 id="boundary-of-binary-tree">Boundary of Binary Tree</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">boundaryOfBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{};</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">getLeft</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
        <span class="n">getBottom</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
        <span class="n">getBottom</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">);</span>
        <span class="n">getRight</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">left</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">left</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bottom</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">bottom</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">res</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">right</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">right</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>    
    <span class="kt">void</span> <span class="n">getLeft</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">getLeft</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">getLeft</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>    
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">getRight</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">getRight</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="p">}</span> 
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">getRight</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">getBottom</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">getBottom</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">getBottom</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="path-problems">Path problems</h2>

<h3 id="maximum-path-sum-binary-tree-i">Maximum Path Sum Binary Tree I</h3>

<p>Given a binary tree in which each node contains an integer number. Find the maximum possible sum from one leaf node to another leaf node. If there is no such path available, return INT_MIN (C++).</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="kt">int</span> <span class="n">global_max</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
 
  <span class="kt">int</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">global_max</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span>  <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">global_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span> 
      <span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">)</span><span class="o">?</span> <span class="n">right</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">left</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="maximum-path-sum-binary-tree-ii">Maximum Path Sum Binary Tree II</h3>

<p>Given a binary tree in which each node contains an integer number. Find the maximum possible sum from any node to any node <strong>(the start node and the end node can be the same)</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">global_max</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>    
    <span class="k">return</span> <span class="n">global_max</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">global_max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
    <span class="c1">//left = (left &lt; 0)? 0 : left;
</span><span class="c1"></span>    <span class="c1">//right = (right &lt; 0)? 0 : right; 
</span><span class="c1"></span>    <span class="n">global_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">global_max</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="maximum-path-sum-binary-tree-iii">Maximum Path Sum Binary Tree III</h3>

<p>Given a binary tree in which each node contains an integer number.
Find the maximum possible subpath sum<strong>(both the starting and ending node of the subpath should be on the same path from root to one of the leaf nodes, and the subpath is allowed to contain only one node)</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">global_max</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">global_max</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">global_max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">global_max</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">global_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">global_max</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="lca-problems">LCA problems</h2>

<h3 id="lca-i">LCA I</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">?</span> <span class="nl">left</span> <span class="p">:</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="lca-of-bst">LCA of BST</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">// p, q are in two sides or root is one of p, q
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">//p,q are smaller than root =&gt; both in left side
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="c1">//both in right side
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>            
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="lca-ii">LCA II</h3>

<p>Give the treenode with parent pointer.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//class TreeNodeP {
</span><span class="c1">// public:
</span><span class="c1">//  int value;
</span><span class="c1">//  TreeNodeP* left;
</span><span class="c1">//  TreeNodeP* right;
</span><span class="c1">//  TreeNodeP* parent;
</span><span class="c1">//  TreeNodeP(int v, TreeNodeP* p) 
</span><span class="c1">//      : value(v), left(NULL), right(NULL), parent(p) {}
</span><span class="c1">//};
</span><span class="c1"></span>
<span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
 <span class="kt">int</span> <span class="n">path_length</span><span class="p">(</span><span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">node</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
     <span class="n">length</span><span class="o">++</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
 <span class="p">}</span>
 
 <span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">llc</span><span class="p">(</span><span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">small</span><span class="p">,</span> <span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">large</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">large</span> <span class="o">=</span> <span class="n">large</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
     <span class="n">diff</span><span class="o">--</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">large</span> <span class="o">!=</span> <span class="n">small</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">large</span> <span class="o">=</span> <span class="n">large</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
     <span class="n">small</span> <span class="o">=</span> <span class="n">small</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">large</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">LCA</span><span class="p">(</span><span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNodeP</span><span class="o">*</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">path_length</span><span class="p">(</span><span class="n">one</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">path_length</span><span class="p">(</span><span class="n">two</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">llc</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">l2</span> <span class="o">-</span> <span class="n">l1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">llc</span><span class="p">(</span><span class="n">two</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
<span class="p">};</span>
</code></pre></div>
<h3 id="lca-iii">LCA III</h3>

<p>Given two nodes in a binary tree, find their lowest common ancestor (the given two nodes are not guaranteed to be in the binary tree). Return null If any of the nodes is not in the tree. There is no parent pointer for the nodes in the binary tree. The given two nodes are not guaranteed to be in the binary tree.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">flag1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">flag2</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">solve</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flag1</span> <span class="o">&amp;&amp;</span> <span class="n">flag2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">findLCA</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span><span class="n">flag1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span><span class="n">flag2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
    <span class="n">traversal</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">findLCA</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">one</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span>  <span class="n">findLCA</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span>  <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span> <span class="n">findLCA</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="lca-iv">LCA IV</h3>

<p>Give k nodes, find their CLA.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="n">LCA</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span> <span class="n">LCA</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span> <span class="n">LCA</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">left</span><span class="o">?</span> <span class="nl">left</span> <span class="p">:</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="check-if-cousins">Check if cousins</h3>

<p><a href="https://www.geeksforgeeks.org/check-two-nodes-cousins-binary-tree/">Geeksforgeeks source</a></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="nf">checkIfCousins</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="kt">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//return target&#39;node level
</span><span class="c1">//return -1 is not found
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">helper</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">one</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">Two</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">one</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">level</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="serialize-and-deserialize-binary-tree">Serialize and deserialize binary tree</h2>

<h3 id="reconstruct-binary-tree-with-preorder-and-inorder">Reconstruct Binary Tree With Preorder And Inorder</h3>

<p>一棵树需要什么信息？需要知道什么是根，左子树和右子树分别又是什么。</p>

<p>那么从这两种遍历之中可以获取什么信息？</p>

<p>先序遍历： root | left subtree | right subtree</p>

<p>中序遍历： left subtree | root | right subtree</p>

<p>先序遍历的最左边，一定是根，但是无法找到左子树和右子树的分界点；但是可以通过找到根，从而从中序遍历中找到这个分界。</p>

<p>解题步骤：</p>

<ol>
<li><p>leftmost of preOrder must be root</p></li>

<li><p>find position of root in inOrder =&gt; need a hashtable to pre-store indices</p></li>

<li><p>in inorder: left side of root is left subtree</p></li>

<li><p>in inorder: right side of root is right subtree</p></li>

<li><p>recursively solve the problem on left subtree and right subtree</p></li>
</ol>
<div class="highlight"><pre class="chroma">  TreeNode* reconstruct(vector&lt;int&gt; in, vector&lt;int&gt; pre) {
    unordered_map&lt;int, int&gt; table;
    for (int i = 0; i &lt; in.size(); i++) {
      table[in[i]] = i;
    }
    
    return helper(in, 0, in.size() - 1, pre, 0, table);
  }
  
  TreeNode* helper(const vector&lt;int&gt; &amp; in, int in_left, int in_right, 
                   const vector&lt;int&gt; &amp; pre, int pre_left,
                    unordered_map&lt;int, int&gt; table) {
                      
    if (in_left &gt; in_right) {
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(pre[pre_left]);
    int index = table[root -&gt; value];
    root -&gt; left = helper(in, in_left, index - 1, pre, pre_left + 1, table);
    root -&gt; right = helper(in, index + 1, in_right, pre, pre_left + index - in_left + 1, table);
    return root;                  
	}</pre></div>
<h3 id="reconstruct-with-level-order">Reconstruct with level order</h3>

<p>level order 的第一个元素，一定是root。通过inorder找到root的位置，然后根据index的关系，分割左右子树。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="n">reconstruct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">table</span><span class="p">[</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="n">helper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">];</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">right</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">left</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">right</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
    <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="reconstruct-binary-search-tree-with-postorder-traversal">Reconstruct Binary Search Tree With Postorder Traversal</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Solution</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">TreeNode</span><span class="o">*</span> <span class="n">reconstruct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Post order -&gt; [leftsubtree][rightsubtree]root =&gt; determine the position of root
</span><span class="c1"></span>    <span class="c1">//In   order -&gt; [left]root[right] =&gt;recursively find left and right parts
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">(</span><span class="n">post</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">in</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">table</span><span class="p">[</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="n">TreeNode</span><span class="o">*</span> <span class="n">helper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">post</span><span class="p">,</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">table</span><span class="p">,</span>
                    <span class="kt">int</span> <span class="n">post_right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_right</span><span class="p">)</span> <span class="p">{</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">in_left</span> <span class="o">&gt;</span> <span class="n">in_right</span><span class="p">){</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">post</span><span class="p">[</span><span class="n">post_right</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="p">];</span>
    
    <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">post_right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in_right</span><span class="p">);</span>
    <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">post_right</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">in_right</span> <span class="o">-</span> <span class="n">index</span><span class="p">),</span> <span class="n">in_left</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">Codec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="c1">// Encodes a tree to a single string.
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">order</span><span class="p">;</span>
        <span class="n">inorderDFS</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">order</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">inorderDFS</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">order</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">//burn the int into 4 chars
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">inorderDFS</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
        <span class="n">inorderDFS</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Decodes your encoded data to tree.
</span><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kr">inline</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">reconstruct</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">//using pos to check whether buffer ends is better than using char* directly.
</span><span class="c1"></span>        
        <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">minValue</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">maxValue</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">minValue</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">reconstruct</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">maxValue</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="create-a-doubly-linked-list-from-a-ternary-tree">Create a Doubly Linked List from a Ternary Tree</h3>

<p><a href="https://www.geeksforgeeks.org/create-doubly-linked-list-ternary-ree/">Question source</a></p>

<h2 id="faq">FAQ</h2>

<h3 id="difference-between-dfs-and-bfs">Difference between DFS and BFS</h3>

<p>DFS using stacks, and BFS using queues if Non-Recursion</p>

<h3 id="difference-between-recursion-and-non-recursion">Difference between Recursion and Non-Recursion</h3>

<p>Recursion is dangerous when memory resource is limited: stack may overflow;
However Non-Recursion method occupies more space</p>

</div>
</div>


        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.linkedin.com/in/hesenzhang//">about me</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>


  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.bf1e1f7ae8e03db5f012356e825843facdff51c0a559cb0d27fe2bbe1db405c2.js"></script>
  

  
  
  
    
      
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-141209571-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-141209571-1');
</script>
    
  


</body>

</html>
