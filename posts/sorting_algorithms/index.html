<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sorting Algorithms - PINEAL.ME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://pineal.github.com/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.51f9758ebedaebb8122900b7464b612d113097d9e170af8375c7cb311bb6a003.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-posts">
      <a href="/posts/">
        <span>Posts</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-posts">
      <a href="/posts/">
        <span>Posts</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>



    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Sorting Algorithms</h1>
<div class="content">
  

<p>假设这里的排序都是升序。</p>

<h2 id="merge-sort">Merge Sort:</h2>

<p>归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// merge part
</span><span class="c1"></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">;</span>
	  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter1</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">iter2</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	  <span class="k">while</span> <span class="p">(</span><span class="n">iter1</span> <span class="o">!=</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="n">iter2</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
	  	<span class="k">if</span> <span class="p">(</span><span class="n">iter1</span> <span class="o">==</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
		  	<span class="n">rst</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">iter2</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		  	<span class="k">break</span><span class="p">;</span>
		  <span class="p">}</span>
		  <span class="k">if</span> <span class="p">(</span><span class="n">iter2</span> <span class="o">==</span> <span class="n">B</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
		  	<span class="n">rst</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">rst</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">iter1</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		  	<span class="k">break</span><span class="p">;</span>
		  <span class="p">}</span>
		  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iter1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">iter2</span><span class="p">)</span> <span class="p">{</span>
			  <span class="n">rst</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter1</span><span class="p">);</span>
			  <span class="n">iter1</span><span class="o">++</span><span class="p">;</span>
		  <span class="p">}</span>
		  <span class="k">else</span> <span class="p">{</span>
			  <span class="n">rst</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter2</span><span class="p">);</span>
			  <span class="n">iter2</span><span class="o">++</span><span class="p">;</span>
		  <span class="p">}</span>
	  <span class="p">}</span>
	  <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
  <span class="p">}</span>

<span class="c1">// key part of merge sort, recursive function
</span><span class="c1"></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		  <span class="n">rst</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
		  <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
	  <span class="p">}</span>
	  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leftArr</span> <span class="o">=</span> <span class="n">MSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightArr</span> <span class="o">=</span> <span class="n">MSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	  <span class="n">rst</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">leftArr</span><span class="p">,</span> <span class="n">rightArr</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
  <span class="p">}</span>
<span class="c1">// driver for merge sort
</span><span class="c1"></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
	  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rst</span><span class="p">;</span>
	  <span class="n">rst</span> <span class="o">=</span> <span class="n">MSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	  <span class="k">return</span> <span class="n">rst</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>
<p>复杂度分析： $O(nlog(n))$</p>

<p>画出递归树，一共 $log(n)$ 层, 每一层是 $O(n)$ 的复杂度.</p>

<p>Demo: GeeksforGeeks</p>

<h2 id="quick-sort">Quick Sort:</h2>

<p>快速排序的核心的思想为是 <strong>partition</strong>. 这个思想在很多类型的问题中都会用到，会在后文举例说明。</p>

<p>快速排序的基本操作为：</p>

<ol>
<li>选取一个pivot。</li>
<li>所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边。</li>
<li>分割数组：对pivot两边的数组递归重复以上步骤，直到不能分割。</li>
</ol>

<p>具体有哪些实现呢。
先来看第一种方法。这是一个textbook的解法。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"> <span class="kt">int</span> <span class="nf">median</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
   <span class="c1">// arr[left] &lt;= arr[center] &lt;= arr[right]
</span><span class="c1"></span>   <span class="kt">int</span> <span class="n">center</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">center</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">center</span><span class="p">]);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>  <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">center</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">center</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
   <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">center</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">//hide pivot
</span><span class="c1"></span>   <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
 <span class="p">}</span>

 <span class="kt">void</span> <span class="nf">QSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">//   if (left &gt;= right) return;
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">CutOff</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
     <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
     <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">for</span><span class="p">(;;){</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">){}</span>
       <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">--</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">){}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
       <span class="k">else</span>  <span class="k">break</span><span class="p">;</span>
     <span class="p">}</span>
<span class="c1">//   if (left + 1 != right){
</span><span class="c1"></span>       <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">//restore pivot
</span><span class="c1">//   }  
</span><span class="c1"></span>     <span class="n">QSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
     <span class="n">QSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span><span class="p">{</span>
     <span class="n">insertion_Sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
   <span class="p">}</span>
 <span class="p">}</span>

 <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
   <span class="n">QSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>
<p>另一个解法。基本思想是一样的。每次都要保持所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边这个条件。
实现的过程为，选取两块挡板，分别从数组的头和尾往中间靠拢，直到挡板相遇。在每一次的循环中，保证第一块挡板左边的数都小于pivot，第二块挡板右边的数都大于pivot。</p>

<p>事实上根据上面这个general rule来分，两个挡板指向的两个数只有四种情况：</p>

<ol>
<li><p>$$a[i] &lt; pivot, a[j] &gt; pivot$$</p></li>

<li><p>$$a[i] &lt; pivot, a[j] &lt; pivot$$</p></li>

<li><p>$$a[i] &gt; pivot, a[j] &gt; pivot$$</p></li>

<li><p>$$a[i] &gt;= pivot, a[j] &lt;= pivot$$</p></li>
</ol>

<p>那么对应刚才的rule该做着么呢？</p>

<ol>
<li><p>满足条件：移动挡板i++， j&ndash;</p></li>

<li><p>满足前半个条件，移动挡板i++，继续检查条件</p></li>

<li><p>满足后半个条件，移动挡板j&ndash;，继续检查条件</p></li>

<li><p>不满足任何条件，但是一旦交换两个挡板上的数，即可让条件满足</p></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pivot_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span>  <span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">left_bound</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right_bound</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//hide the pivot in the rightmost
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="c1">//three regions:
</span><span class="c1"></span>    <span class="c1">//1. [0, leftbound - 1] : all elements smaller than pivot should be here
</span><span class="c1"></span>    <span class="c1">//2. [leftbound, rightbound]: to be discovered, scan the element in a[leftbound], and move leftbound every step
</span><span class="c1"></span>    <span class="c1">//3. [rightbound + 1, array.size() - 1] all elements bigger than pivot should be here
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">left_bound</span> <span class="o">&lt;=</span> <span class="n">right_bound</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//check two
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">left_bound</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// obey all three rules, move leftbound
</span><span class="c1"></span>        <span class="o">++</span><span class="n">left_bound</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">right_bound</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">right_bound</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//array[left_bound] &gt; pivot &amp;&amp; array[right_bound &lt; pivot]
</span><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">left_bound</span><span class="o">++</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right_bound</span><span class="o">--</span><span class="p">]);</span>      
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//restore the pivot to the original position
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">left_bound</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="c1">//partition and recursion
</span><span class="c1"></span>    <span class="n">QuickSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">left_bound</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">left_bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">quickSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>
<p>这样的解法可以归结为一种类型。比如一堆数中只有两种，三种四种数，那么就可以对应个数的挡板将数分割成相应区域，每次检查条件是否满足。Eg: Sort colors。这样的做法复杂度只需要$O(n)$.</p>

<p>Demo: GeeksforGeeks</p>

<h3 id="partition-extension-i-sort-colors">Partition Extension I: Sort Colors</h3>

<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">sortColors</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">//explorer
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">two</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//Three seperator Four regions
</span><span class="c1"></span>    <span class="c1">//[0, zero)     0
</span><span class="c1"></span>    <span class="c1">//[zero, one]   1
</span><span class="c1"></span>    <span class="c1">//(two, end]    2
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">one</span> <span class="o">&lt;=</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">one</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">one</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">++</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">one</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">one</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">one</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">two</span><span class="o">--</span><span class="p">]);</span>
            <span class="c1">//don&#39;t move &#39;one&#39;:
</span><span class="c1"></span>            <span class="c1">//you don&#39;t know what is swaped from &#39;two&#39;
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="follow-up-i-four-colors">Follow up I: four colors</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rainbowSortII</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">one</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">one</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">one</span><span class="o">++</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">zero</span><span class="o">++</span><span class="p">]);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">one</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">other</span><span class="o">--</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">one</span><span class="p">]);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="n">one</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>
   <span class="p">}</span>
   <span class="kt">int</span> <span class="n">two</span> <span class="o">=</span> <span class="n">one</span><span class="p">,</span> <span class="n">three</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">two</span> <span class="o">&lt;=</span> <span class="n">three</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">two</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">three</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">two</span><span class="o">++</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">three</span><span class="o">--</span><span class="p">]);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">two</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">two</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="n">three</span><span class="o">--</span><span class="p">;</span>
     <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>
<h3 id="follow-up-ii-k-colors">Follow up II: k colors</h3>

<p>TODO: couting sort.</p>

<h3 id="partition-extension-ii-kth-smallest-largest-element-in-an-unsorted-array">Partition Extension II: Kth smallest/largest element in an unsorted array</h3>

<p>quick sort partition 思想的另一经典应用。
<a href="https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/">https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/</a></p>

<h2 id="wiggle-sort">Wiggle Sort</h2>

<p>$nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]&hellip;.$</p>

<p>这个时间复杂度优化到了O(n)。下面那个做法是通用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>        
<span class="p">}</span>
</code></pre></div>
<h3 id="follow-up-wiggle-sort-ii">Follow up: Wiggle Sort II</h3>

<p>$nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]&hellip;$</p>

<p>根据这个性质，我们可以确定一种排法一定可以成立：把小的那一半排在偶数位，把大的那一半排在奇数位。这个是通用的。
 时间复杂度 $ O(nlog(n)) $.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">wiggleSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">copy</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">copy</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span> <span class="n">copy</span><span class="p">[</span><span class="n">left</span><span class="o">--</span><span class="p">]</span> <span class="o">:</span> <span class="n">copy</span><span class="p">[</span><span class="n">right</span><span class="o">--</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>传说中$O(n)$ 的解法。</p>

<h2 id="sort-in-specified-order">Sort In Specified Order</h2>

<p>A1 = {2, 1, 2, 5, 7, 1, 9, 3},</p>

<p>A2 = {2, 1, 3},</p>

<p>A1 is sorted to {2, 2, 1, 1, 3, 5, 7, 9}</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">helper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">A1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">A2</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// Write your solution here.
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">A1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||||</span> <span class="n">A2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">sort</span><span class="p">(</span><span class="n">A1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">A1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
       <span class="k">return</span> <span class="n">A1</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">t</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">A2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
           <span class="n">swap</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">A1</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
           <span class="n">j</span><span class="o">++</span><span class="p">;</span>
           <span class="n">k</span><span class="o">--</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
           <span class="n">j</span><span class="o">++</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="k">else</span> <span class="p">{</span>
           <span class="n">k</span><span class="o">--</span><span class="p">;</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="c1">//sort the [0, j) in specified order
</span><span class="c1"></span>   <span class="c1">//[2 1 3 4]
</span><span class="c1"></span>   <span class="c1">//2 1 2 1 4 3 =&gt; 2 2 1 1 3 4
</span><span class="c1"></span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">A1</span><span class="p">[</span><span class="n">min_index</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">[</span><span class="n">A1</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span> <span class="p">{</span>
               <span class="n">min_index</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
           <span class="p">}</span>
       <span class="p">}</span>
       <span class="n">swap</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A1</span><span class="p">[</span><span class="n">min_index</span><span class="p">]);</span>
   <span class="p">}</span>

   <span class="c1">//sort the (k, n) part in ascending order
</span><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">A1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
   <span class="k">return</span> <span class="n">A1</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>
<h2 id="insertion-sort">Insertion Sort:</h2>

<p>插入排序。假设一个长度为N的数组$A[]$，总体过程为，从 index 为 1 开始到 N-1，使得 $A[0,index]$ 是一个排好序的数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">insertion_sort</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">temp</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span> <span class="c1">//实际比较的是j-1
</span><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">//全部往后移一位腾出位置等插入
</span><span class="c1"></span>      <span class="p">}</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>    <span class="c1">//插入到腾出来的位置
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>复杂度：
$O(n^2)$</p>

<h2 id="selection-sort">Selection Sort:</h2>

<p>选择排序。假设一个长度为N的数组$A[]$，总体过程为，从index为0开始到N-1，使得$A[0,index]$是一个排好序的数组。</p>

<p>怎么跟插入排序这么像呢？是挺像的，但是具体的过程是有区别。这区别就是“插入”和“选择”的区别。</p>

<p>插入排序是每次往前面那些已经排序好的数里“插入”进去，而选择排序则是，每次从这个数后面那些没排好序的数里“选择”到最小的，和这个数交换。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">selection_sort</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">//len - 1即可，最后一次交换在倒数第一个和倒数第二个之间进行
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
      <span class="c1">//找到未排序的数组中最小的数的index
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]){</span>
          <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
      <span class="p">}</span>        
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>复杂度分析：
$O(n^2)$的复杂度。实际上是冒泡排序的一个优化，虽然最坏时间复杂度上是一样的。</p>

<p>附上冒泡排序代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>


        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.linkedin.com/in/hesenzhang//">about me</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>


  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.bf1e1f7ae8e03db5f012356e825843facdff51c0a559cb0d27fe2bbe1db405c2.js"></script>
  

  
  
  
    
      
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-141209571-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-141209571-1');
</script>
    
  


</body>

</html>
