<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Shortest Path</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Shortest Path">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Shortest Path">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.github.com/posts/shortest_path_problems/">
	<meta name="og:site_name" content="Shortest Path">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="BFS ">
	<link rel="stylesheet" type="text/css" href="https://pineal.github.com/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.github.com/" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.github.com/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.github.com/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.github.com/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Shortest Path</h1>
  <aside> <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#maze-i">Maze I</a></li>
<li><a href="#maze-ii">Maze II</a></li>
<li><a href="#maze-iii">Maze III</a></li>
<li><a href="#leetcode-317-shortest-distance-from-all-buildings">Leetcode 317: Shortest Distance from All Buildings</a></li>
<li><a href="#best-meeting-point">Best Meeting Point</a></li>
<li><a href="#dijkstra">Dijkstra</a></li>
<li><a href="#a-star">A star</a></li>
</ul></li>
</ul>
</nav></aside>
  

<h2 id="maze-i">Maze I</h2>

<pre><code class="language-cpp">bool hasPath(vector&lt;vector&lt;int&gt;&gt; &amp; maze, vector&lt;int&gt; &amp; start, vector&lt;int&gt; &amp; dest) {
    const vector&lt;int&gt; dx = {0, -1, 1, 0};
    const vector&lt;int&gt; dy = {1, 0, 0, -1};
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.emplace(start[0], start[1]);
    maze[start[0]][start[1]] = 2;
    int m = maze.size();
    int n = maze.front().size();
    while (!q.empty()) {
        auto cur = q.front();
        q.pop();
        int x = cur.first;
        int y = cur.second;
        if (x == dest[0] &amp;&amp; y == dest[1]) {
            return true;
        }

        for (int i = 0; i &lt; 4; i++) {
            int xx = x;
            int yy = y;
            while (xx &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; maze[xx][yy] != 1) {
                xx += dx[i];
                yy += dy[i];
            }
            xx -= dx[i];
            yy -= dy[i];
            if (maze[xx][yy] == 0) {
                maze[xx][yy] = 2;
                q.emplace(xx, yy);
            }
        }
    }
    return false;
}

</code></pre>

<h2 id="maze-ii">Maze II</h2>

<pre><code class="language-cpp">struct Position {
    int x, y, d;
    Position(int x, int y, int d): x(x), y(y), d(d) {}
};

class Solution {
public:
    int shortestDistance(vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;int&gt;&amp; start, vector&lt;int&gt;&amp; dest) {
        if (maze.empty()) {
            return -1;
        }
        auto cmp = [](Position &amp; p1, Position &amp; p2) {return p1.d &gt; p2.d;};
        priority_queue&lt;Position, vector&lt;Position&gt;, decltype(cmp)&gt; pq(cmp);
        pq.emplace(Position(start[0], start[1], 0));
        
        int m = maze.size();
        int n = maze.front().size();
        
        vector&lt;vector&lt;int&gt;&gt; dis(m, vector&lt;int&gt;(n, INT_MAX));
        const vector&lt;int&gt; dx = {0, 1, -1, 0};
        const vector&lt;int&gt; dy = {1, 0, 0, -1};
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            int x = p.x;
            int y = p.y;
            int d = p.d;
            if (x == dest[0] &amp;&amp; y == dest[1]) {
                return d;
            }
            dis[x][y] = d;
            for (int i = 0; i &lt; 4; i++) {
                int nx = x;
                int ny = y;
                int nd = d;
                while (nx + dx[i] &lt; m &amp;&amp; nx + dx[i] &gt;= 0 &amp;&amp; ny + dy[i] &lt; n &amp;&amp; ny + dy[i] &gt;= 0 
                       &amp;&amp; maze[nx + dx[i]][ny + dy[i]] == 0) {
                    nx += dx[i];
                    ny += dy[i];
                    nd++;
                }
                if (dis[nx][ny] &gt; nd) {
                        dis[nx][ny] = nd;
                        pq.emplace(Position(nx, ny, nd));
                }
            }
        }
        return -1;   
    }
};
</code></pre>

<h2 id="maze-iii">Maze III</h2>

<pre><code class="language-cpp">struct State
{
    int x;
    int y;
    int d;
    State (int x, int y, int d) : x(x), y(y), d(d) {}
};

const vector&lt;int&gt; dx = {1, -1, 0, 0};
const vector&lt;int&gt; dy = {0, 0, -1, 1};
const string dirs = &quot;dulr&quot;;
    
class Solution {
public:
    string findShortestWay(vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;int&gt;&amp; ball, vector&lt;int&gt;&amp; hole) {
        auto cmp = [](State &amp; s1, State &amp; s2) {
            return s1.d &gt; s2.d;  
        };
        priority_queue&lt;State, vector&lt;State&gt;, decltype(cmp)&gt; pq(cmp);
        pq.emplace(ball[0], ball[1], 0);
        int m = maze.size();
        int n = maze.front().size();
        //dis[x][y]=&gt;maintain the shortest distance to the source so far
        vector&lt;vector&lt;int&gt;&gt; dis(m, vector&lt;int&gt;(n, INT_MAX));
        //dir[x][y]=&gt;maintain the lexicographically smallest way from the source so far
        vector&lt;vector&lt;string&gt;&gt; way(m, vector&lt;string&gt;(n));
        while(!pq.empty()) {
            auto state = pq.top();
            pq.pop();
            int x = state.x;
            int y = state.y;
            int d = state.d;
            if (d &gt; dis[x][y]) {
                continue;
            }
            string path = way[x][y];
            dis[x][y] = d;
            if (x == hole[0] &amp;&amp; y == hole[1]) {
                return way[x][y];
            }
            for (int i = 0; i &lt; 4; i++) {
                int nx = x;
                int ny = y;
                int nd = d;
                string path = way[x][y] + dirs[i]; 
                while (nx + dx[i] &lt; m &amp;&amp; nx + dx[i] &gt;= 0 &amp;&amp; ny + dy[i] &lt; n &amp;&amp; ny + dy[i] &gt;= 0 
                       &amp;&amp; maze[nx + dx[i]][ny + dy[i]] == 0) {
                    nx += dx[i];
                    ny += dy[i];
                    nd++;
                    if (nx == hole[0] &amp;&amp; ny == hole[1]) {
                        break;
                    }
                }
                if (nd &lt; dis[nx][ny]) {
                    dis[nx][ny] = nd;
                    way[nx][ny] = path;
                    pq.emplace(nx, ny, nd);
                }
                if (nd == dis[nx][ny]) {
                    if (path &lt; way[nx][ny]) {
                        way[nx][ny] = path;
                    }
                }
            }
        }
        return &quot;impossible&quot;;
    }
};
</code></pre>

<h2 id="leetcode-317-shortest-distance-from-all-buildings">Leetcode 317: Shortest Distance from All Buildings</h2>

<p>找到一个点，从他开始到所有的buildings的距离最短的和，中间有障碍物。对每个点做BFS，然后加起来求一个最小值。这样的时间复杂度是 $O(m*n)[BFS] * O(m*n)[matrix] = O(m^2*n^2)$。优化：从building开始搜。那么时间复杂度为$O(k*m*n)$。 $k$ 是 building 的个数。</p>

<pre><code class="language-cpp">class Solution {
public:
    int shortestDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int res = INT_MAX;
        
        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dis(grid.size(), vector&lt;pair&lt;int, int&gt;&gt;(grid[0].size()));    
        //dis[i][j].first =&gt; total distance from k buildings to grid[i][j]
        //dis[i][j].second =&gt; num of times search from k buildings and visited to grid[i][j] successfully (avoid dead end)
        int m = grid.size();
        int n = grid[0].size();
        int num_buildings = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                    num_buildings++;
                }
            }
        }
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dis[i][j].second == num_buildings) {
                    res = min(res, dis[i][j].first);
                }
            }
        }
        return res == INT_MAX? -1 : res;
    }
    
    
    void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp; grid, vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &amp; dis, int i, int j) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&lt;deque&lt;bool&gt;&gt; visited(m, deque&lt;bool&gt;(n, false));
        
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to building in grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y].first += level;
                    dis[x][y].second++;
                }
                for (const auto &amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &lt; m &amp;&amp; x_prime &gt;= 0 &amp;&amp; y_prime &lt; n &amp;&amp; y_prime &gt;= 0 &amp;&amp; 
                        grid[x_prime][y_prime] == 0 &amp;&amp;
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
        
    }
};
</code></pre>

<h2 id="best-meeting-point">Best Meeting Point</h2>

<p>和上题一样的做法，只是可以在人所在的位置。做BFS标记visited的时候要注意。</p>

<pre><code class="language-cpp">class Solution {
public:
    int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int res = INT_MAX;        
        vector&lt;vector&lt;int&gt;&gt; dis(grid.size(), vector&lt;int&gt;(grid[0].size()));    
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                }
            }
        }
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                    res = min(res, dis[i][j]);
            }
        }
        return res == INT_MAX? -1 : res;        
    }
    void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp; grid, vector&lt;vector&lt;int&gt;&gt; &amp; dis, int i, int j) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&lt;deque&lt;bool&gt;&gt; visited(m, deque&lt;bool&gt;(n, false));
        visited[i][j] = true;
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y] += level;
                }
                for (const auto &amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &lt; m &amp;&amp; x_prime &gt;= 0 &amp;&amp; y_prime &lt; n &amp;&amp; y_prime &gt;= 0 &amp;&amp; 
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
    }    
};
</code></pre>

<p>但超时啦。
答案里给的方法是算出median。并不适用有obstacle的情况（是嘛？）。</p>

<pre><code class="language-cpp">// Time:  O(mn)
// Space: O(m+n)
class Solution {
public:
    int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        vector&lt;int&gt; x, y;
        for (int i = 0; i &lt; grid.size(); ++i) {
            for (int j = 0; j &lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    x.emplace_back(i);
                    y.emplace_back(j);
                }
            }
        }
        nth_element(x.begin(), x.begin() + x.size() / 2, x.end());
        nth_element(y.begin(), y.begin() + y.size() / 2, y.end());
        const int mid_x = x[x.size() / 2];
        const int mid_y = y[y.size() / 2];
        int sum = 0;
        for (int i = 0; i &lt; grid.size(); ++i) {
            for (int j = 0; j &lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    sum += abs(mid_x - i) + abs(mid_y - j);
                }
            }
        }
        return sum;
    }
};
</code></pre>

<p><a href="https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations">数学证明参考链接</a></p>

<ul>
<li>nth_element()
把按 comparator 排序的有第n个数放在 n 的位置，前面的都比它“小”， 后面的都比它“大”。 但其他并不保证有序，时间复杂度 $O(n)$ 比 sort 好一些。</li>
</ul>

<h2 id="dijkstra">Dijkstra</h2>

<p><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/">https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/</a></p>

<p><a href="https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/">https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/</a></p>

<p><a href="https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/">https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/</a></p>

<h2 id="a-star">A star</h2>

<p><a href="https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp">https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp</a></p>


  <a href="/tags/bfs/">BFS</a></a>&nbsp;&nbsp;&nbsp;

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
