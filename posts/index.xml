<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on PINEAL.ME</title>
    <link>https://pineal.github.com/posts/</link>
    <description>Recent content in Posts on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Mar 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sliding Window Problems</title>
      <link>https://pineal.github.com/posts/sliding_windows/</link>
      <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sliding_windows/</guid>
      <description>

&lt;h1 id=&#34;sliding-window-problems&#34;&gt;Sliding Window Problems&lt;/h1&gt;

&lt;h3 id=&#34;719-find-k-th-smallest-pair-distance&#34;&gt;719. Find K-th Smallest Pair Distance&lt;/h3&gt;

&lt;p&gt;Binary Search + Sliding Window&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-window-substring/&#34;&gt;76. Minimum Window Substring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-size-subarray-sum/&#34;&gt;209. Minimum Size Subarray Sum&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sliding-window-maximum/&#34;&gt;239. Sliding Window Maximum&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/&#34;&gt;340. Longest Substring with At Most K Distinct Characters&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/&#34;&gt;159. Longest Substring with At Most Two Distinct Characters&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/substring-with-concatenation-of-all-words/&#34;&gt;30. Substring with Concatenation of All Words&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-substring-without-repeating-characters/&#34;&gt;3. Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Extended Kalman Filter</title>
      <link>https://pineal.github.com/posts/extended_kalman_filter/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/extended_kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;review-of-kalman-filter&#34;&gt;Review of Kalman filter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pineal.github.io/2015/03/Kalman-Filter/]&#34;&gt;Previous post on basic kalman filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ilectureonline.com/lectures/subject/SPECIAL%20TOPICS/26/190&#34;&gt;iLecture lessons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Distribution of Gausion is not Gaussian, it becomes non-linear&lt;/p&gt;

&lt;p&gt;Extented Kalman filter uses a linear approximation of h(x)
Here we use first order taylor expansion to&lt;/p&gt;

&lt;p&gt;Given a function f(x), a taylor series expansion could be expressed:&lt;/p&gt;

&lt;p&gt;$$f(x) \approx \frac{\partial{f(\mu)} }{\partial{x}}(x - \mu)$$&lt;/p&gt;

&lt;h2 id=&#34;multivariate-taylor-series&#34;&gt;Multivariate Taylor Series&lt;/h2&gt;

&lt;h2 id=&#34;design-kalman-filter-for-1d-tracking-problem&#34;&gt;Design Kalman Filter for 1D tracking problem&lt;/h2&gt;

&lt;p&gt;We need to define two linear functions:
1. state transition function
2. measurement function&lt;/p&gt;

&lt;h3 id=&#34;state-transition-function&#34;&gt;State transition function&lt;/h3&gt;

&lt;p&gt;$$ x&amp;rsquo; = F * x + noise $$&lt;/p&gt;

&lt;p&gt;where,&lt;/p&gt;

&lt;p&gt;$$F = \begin{pmatrix}
        1 &amp;amp; \Delta{t} &lt;br /&gt;
        0 &amp;amp; 1
     \end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;$$x = \begin{pmatrix} p \ v\end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;postion $p$ is linear motion model, calculation is:&lt;/p&gt;

&lt;p&gt;$$p&amp;rsquo; = p + v * \Delta{t}$$&lt;/p&gt;

&lt;p&gt;Thus We can express it in a matrix form:&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;h1 id=&#34;begin-pmatrix-p-v-end-pmatrix&#34;&gt;\begin{pmatrix} p&amp;rsquo; \ v&amp;rsquo; \end{pmatrix}&lt;/h1&gt;

&lt;p&gt;\begin{pmatrix}
        1 &amp;amp; \Delta{t} &lt;br /&gt;
        0 &amp;amp; 1
     \end{pmatrix}
\begin{pmatrix} p \ v\end{pmatrix}
$$&lt;/p&gt;

&lt;h3 id=&#34;measurement-update-function&#34;&gt;Measurement Update function&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Cache Design</title>
      <link>https://pineal.github.com/posts/cache_design/</link>
      <pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/cache_design/</guid>
      <description>

&lt;h1 id=&#34;cache-design&#34;&gt;Cache Design&lt;/h1&gt;

&lt;h2 id=&#34;lru&#34;&gt;LRU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1-SMH7LNov8UM8BuCKMJGTQ523GnK5Td02qqX-E0LWQk/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;lfu&#34;&gt;LFU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1B_BeXdSxWUKpag_fWd_4laL8HVRmXZ5KU8prgOWIxB8/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>少年常戚戚</title>
      <link>https://pineal.github.com/posts/%E5%B0%91%E5%B9%B4%E5%B8%B8%E6%88%9A%E6%88%9A/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E5%B0%91%E5%B9%B4%E5%B8%B8%E6%88%9A%E6%88%9A/</guid>
      <description>&lt;p&gt;我为什么要离开 &lt;br/&gt;
你为什么不留下 &lt;br/&gt;
就像是络腮胡的最北端 &lt;br/&gt;
若隐若现 &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;我费尽全力为你练习&lt;br/&gt;
却被你嘲笑不够有趣&lt;br/&gt;
愤愤不平&lt;br/&gt;
毕竟全中国也不会有几个&lt;br/&gt;
广场舞十级&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;想跟无耻的自己打一场群架&lt;br/&gt;
可惜敌军太过怯懦&lt;br/&gt;
友军狐假虎威&lt;br/&gt;
司令害怕三个地雷&lt;br/&gt;
还有一对炸弹&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;九十年代的汽车都有个喇叭&lt;br/&gt;
喇叭会响&lt;br/&gt;
倒车请注意&lt;br/&gt;
倒车请注意&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;为什么这锅肉散发着资本主义的&lt;br/&gt;
腐朽气息&lt;br/&gt;
哦&lt;br/&gt;
我用僵尸丹炖的&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Problems with Parentheses</title>
      <link>https://pineal.github.com/posts/problem_with_parentheses/</link>
      <pubDate>Sat, 10 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/problem_with_parentheses/</guid>
      <description>

&lt;h1 id=&#34;括号问题&#34;&gt;括号问题&lt;/h1&gt;

&lt;p&gt;对括号的处理，最经典的做法是对左右括号计数，因为一定会成对。也可以用栈的性质，来配对。&lt;/p&gt;

&lt;h3 id=&#34;生成所有的括号&#34;&gt;生成所有的括号&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; generateParenthesis(int n) {
        vector&amp;lt;string&amp;gt; rst;
        string cur;
        dfs(cur, rst, 0, 0, n);
        return rst;
    }

    void dfs(string &amp;amp; cur, vector&amp;lt;string&amp;gt; &amp;amp; rst, int l, int r, int n) {
        if (l + r == 2 * n) {
            rst.emplace_back(cur);
            return;
        }

        if (l &amp;lt; n) {
            cur += &#39;(&#39;;
            dfs(cur, rst, l + 1, r, n);
            cur.pop_back();
        }

        if (r &amp;lt; l) {
            cur += &#39;)&#39;;
            dfs(cur, rst, l, r + 1, n);
            cur.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;验证合法的括号&#34;&gt;验证合法的括号&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    bool isValid(string s) {
        stack&amp;lt;char&amp;gt; st;
        for (auto c : s)
            if (!st.empty() &amp;amp;&amp;amp;
                ((c == &#39;)&#39; &amp;amp;&amp;amp; st.top() == &#39;(&#39;) ||
                 (c == &#39;}&#39; &amp;amp;&amp;amp; st.top() == &#39;{&#39;) ||
                 (c == &#39;]&#39; &amp;amp;&amp;amp; st.top() == &#39;[&#39;))
               ) {
                st.pop();    
               }
            else {
                st.push(c);
            }
        return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Kth Problems</title>
      <link>https://pineal.github.com/posts/kth_problems/</link>
      <pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kth_problems/</guid>
      <description>

&lt;h1 id=&#34;kth-problems&#34;&gt;Kth Problems&lt;/h1&gt;

&lt;p&gt;套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).&lt;/p&gt;

&lt;h3 id=&#34;merge-k-sorted-lists&#34;&gt;Merge k Sorted Lists&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
//Time O(nlogk)
//Space O(n)
//provides greater
struct Cmp {
  bool operator() (ListNode* n1, ListNode* n2) {
    return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;
  }
};

class Solution {
public:
  ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
    //min_heap needs a greater comparator
    //Method 1: redefine functor
    //priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, Cmp&amp;gt; min_heap;
    //Method 2: Lambda
    auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;};
    priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp);
    //maintain the min_heap of size k instead of all nodes
    // klogn =&amp;gt; nlogk
    for (int i = 0; i &amp;lt; lists.size(); i++) {
      if (lists[i]) {
        min_heap.emplace(lists[i]);
      }
    }

    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (!min_heap.empty()) {
      ListNode* temp = min_heap.top();
      cur -&amp;gt; next = temp;
      min_heap.pop();
      if (temp -&amp;gt; next) {
        min_heap.emplace(temp -&amp;gt; next);
      }
      cur = cur -&amp;gt; next;
    }
    return dummy -&amp;gt; next;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-number-in-sorted-matrix&#34;&gt;Kth Smallest Number In Sorted Matrix&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class Cell {
public:
    int row;
    int col;
    int value;
    Cell(int _row, int _column, int _value) {
        row = _row;
        col = _column;
        value = _value;
    }

    bool operator &amp;lt; (const Cell &amp;amp; c) const {
        return value &amp;lt;= c.value;
    }

    bool operator &amp;gt; (const Cell &amp;amp; c) const {
        return value &amp;gt; c.value;
    }
};

int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; m, int k) {
    priority_queue&amp;lt;Cell, vector&amp;lt;Cell&amp;gt;, greater&amp;lt;Cell&amp;gt;&amp;gt; min_heap;
    min_heap.emplace(Cell(0, 0, m[0][0]));
    size_t num_row = m.size();
    size_t num_col = m[0].size();
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(num_row, vector&amp;lt;bool&amp;gt;(num_col, false));
    visited[0][0] = true;
    for (int i = 0; i &amp;lt; k - 1; i++) {
        Cell c = min_heap.top();
        min_heap.pop();
        if (c.row + 1 &amp;lt; num_row &amp;amp;&amp;amp; visited[c.row + 1][c.col] == false) {
                min_heap.emplace(Cell(c.row + 1, c.col, m[c.row + 1][c.col]));
                visited[c.row + 1][c.col] = true;
        }

        if (c.col + 1 &amp;lt; num_col &amp;amp;&amp;amp; visited[c.row][c.col + 1] == false) {
                min_heap.emplace(Cell(c.row, c.col + 1, m[c.row][c.col + 1]));
                visited[c.row][c.col + 1] = true;
        }
    }
    return min_heap.top().value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-sum-in-two-sorted-arrays&#34;&gt;Kth Smallest Sum In Two Sorted Arrays&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Cell {
public:
  int i;
  int j;
  int sum;
  Cell(int _i, int _j, int _sum) {
    i = _i;
    j = _j;
    sum = _sum;
  }

  bool operator &amp;lt; (const Cell &amp;amp; c) const {
    return sum &amp;lt;= c.sum;
  }

  bool operator &amp;gt; (const Cell &amp;amp; c) const {
    return sum &amp;gt; c.sum;
  }
};

class Solution {
 public:
  int kthSum(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, int k) {
    // Write your solution here
    priority_queue&amp;lt;Cell, vector&amp;lt;Cell&amp;gt;, greater&amp;lt;Cell&amp;gt;&amp;gt; min_heap;
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(a.size(), vector&amp;lt;bool&amp;gt;(b.size(), false));
    visited[0][0] = true;
    min_heap.emplace(Cell(0, 0, a[0] + b[0]));
    for (int i = 0; i &amp;lt; k - 1; i++) {
      Cell cur = min_heap.top();
      min_heap.pop();
      if (cur.i + 1 &amp;lt; a.size() &amp;amp;&amp;amp; !visited[cur.i + 1][cur.j]) {
        int sum = a[cur.i + 1] + b[cur.j];
        min_heap.emplace(Cell(cur.i + 1, cur.j, sum));
        visited[cur.i + 1][cur.j] = true;
      }

      if (cur.j + 1 &amp;lt; b.size() &amp;amp;&amp;amp; !visited[cur.i][cur.j + 1]) {
        int sum = a[cur.i] + b[cur.j + 1];
        min_heap.emplace(Cell(cur.i, cur.j + 1, sum));
        visited[cur.i][cur.j + 1] = true;
      }
    }
    return min_heap.top().sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-with-only-3-5-7-as-factors&#34;&gt;Kth Smallest With Only 3, 5, 7 As Factors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  long kth(int k) {
    // Write your solution here.
    priority_queue&amp;lt;long, vector&amp;lt;long&amp;gt;, greater&amp;lt;long&amp;gt;&amp;gt; min_heap;
    min_heap.emplace(105);
    set&amp;lt;long&amp;gt; visited;
    visited.emplace(105);
    for (int i = 0; i &amp;lt; k - 1; i++) {
      long cur = min_heap.top();
      min_heap.pop();
      if (visited.find(cur * 3) == visited.end()) {
        min_heap.emplace(cur * 3);
        visited.emplace(cur * 3);
      }

      if (visited.find(cur * 5) == visited.end()) {
        min_heap.emplace(cur * 5);
        visited.emplace(cur * 5);
      }      

      if (visited.find(cur * 7) == visited.end()) {
        min_heap.emplace(cur * 7);
        visited.emplace(cur * 7);
      }      
    }

    return min_heap.top();
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-closest-point&#34;&gt;Kth Closest Point&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {
public:
    int x;
    int y;
    int z;
    double dis;
    Point (int _x, int _y, int _z, double _dis) {
        x = _x;
        y = _y;
        z = _z;
        dis = _dis;
    }

    bool operator &amp;lt; (const Point &amp;amp; p1) const {
        return dis &amp;lt;= p1.dis;
    }

    bool operator &amp;gt; (const Point &amp;amp; p1) const {
        return dis &amp;gt; p1.dis;
    }

};

class Solution {
 public:
    vector&amp;lt;int&amp;gt; closest(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, vector&amp;lt;int&amp;gt; c, int k) {
        priority_queue&amp;lt;Point, vector&amp;lt;Point&amp;gt;, greater&amp;lt;Point&amp;gt;&amp;gt; min_heap;
        set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited;
        double d = sqrt(a[0] * a[0] + b[0] * b[0] + c[0] * c[0] + 0.0);
        Point* start = new Point(0,0,0,d);
        min_heap.emplace(*start);
        visited.emplace(vector&amp;lt;int&amp;gt;{0,0,0});
        for (int i = 0; i &amp;lt; k - 1; i++) {
            Point p = min_heap.top();
            min_heap.pop();
            if (p.x + 1 &amp;lt; a.size()) {
                double d = sqrt(a[p.x + 1] * a[p.x + 1] + b[p.y] * b[p.y] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x + 1,p.y,p.z,d);
                if (visited.find({p.x + 1,p.y,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x + 1, p.y, p.z};
                    visited.emplace(v);
                }
            }
            if (p.y + 1 &amp;lt; b.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y + 1] * b[p.y + 1] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x,p.y + 1,p.z,d);
                if (visited.find({p.x,p.y + 1,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y + 1,p.z};
                    visited.emplace(v);
                }
            }

            if (p.z + 1 &amp;lt; c.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y] * b[p.y] + c[p.z + 1] * c[p.z + 1] + 0.0);
                Point* temp = new Point(p.x,p.y,p.z + 1,d);
                if (visited.find({p.x,p.y,p.z + 1}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y,p.z + 1};
                    visited.emplace(v);
                }
            }      
        }

        Point rst = min_heap.top();
        return {a[rst.x], b[rst.y], c[rst.z]};
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;visited尽量用bool数组表示，二维三维都可。不要存放node类的class，地址不一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gragh practice</title>
      <link>https://pineal.github.com/posts/graph_practices/</link>
      <pubDate>Wed, 12 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/graph_practices/</guid>
      <description>

&lt;h1 id=&#34;graph&#34;&gt;Graph&lt;/h1&gt;

&lt;p&gt;Leetcode 里现有的图论的题比较简单，都有套路。八个题七个BFS一个DFS。&lt;/p&gt;

&lt;p&gt;后半部分把图里的搜索的题目也放了进来。&lt;/p&gt;

&lt;p&gt;BFS Direct Graphs - Topological Sorting&lt;/p&gt;

&lt;p&gt;Course Schedule&lt;/p&gt;

&lt;p&gt;用两个个hashmap记录所有的入度和出度。&lt;/p&gt;

&lt;p&gt;用一个zeroInDegree的队列做BFS，没有入度意味着起点&lt;/p&gt;

&lt;p&gt;在BFS过程中，不断的删除孩子的入度，然后把父亲节点从出度中删掉，这样就把这个点和所有和他连接的孩子的边都删掉了。&lt;/p&gt;

&lt;p&gt;最后判断如果出度中还有点，说明还有边存在着。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//BFS
class Solution {
	public:
		bool canFinish(int numCourses, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;amp; pres) {
			queue&amp;lt;int&amp;gt; zeroInDegree;

			unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; inDegree;
			unordered_map&amp;lt;int, unordered_set&amp;lt;int&amp;gt;&amp;gt; outDegree;

			for (int i = 0; i &amp;lt; pres.size(); i++) {
				inDegree[pres[i].first].emplace(pres[i].second);
				outDegree[pres[i].second].emplace(pres[i].first);
			}

			for (int i = 0; i &amp;lt; numCourses; i++) {
				if (!inDegree.count(i)) {
					zeroInDegree.push(i);
				}
			}

			while (!zeroInDegree.empty()) {
				int parent = zeroInDegree.front();
				zeroInDegree.pop();
				//for each child has a edge from parent
				for (auto child : outDegree[parent]) {
					//remove edge
					inDegree[child].erase(parent);
					//if this child has no edge, add to queue
					if (inDegree[child].empty()) {
						zeroInDegree.push(child);
					}
				}
				outDegree.erase(parent);
			}

			//if still exist edges in the graph, return false
			if (!outDegree.empty()) {
				return false;
			}
			return true;   
		}
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Course Schedule II&lt;/p&gt;

&lt;p&gt;BFS的过程中顺便记录弹出的顺序就行了。&lt;/p&gt;

&lt;p&gt;Alien Dictionary&lt;/p&gt;

&lt;p&gt;每个字母就是一个节点，根据排好序的词，找到第一个不想等的字母，找到关系，建立direct graph.&lt;/p&gt;

&lt;p&gt;剩下的跟 Course Schedule ii 无异，BFS就行。&lt;/p&gt;

&lt;p&gt;BFS Undirected Graphs&lt;/p&gt;

&lt;p&gt;Clone Graph&lt;/p&gt;

&lt;p&gt;用一个hashmap来记录orignal graph 与 copied graph 之间的节点的一一对应的关系。&lt;/p&gt;

&lt;p&gt;用BFS遍历原图。做两件事：加没有遇到过的点到copied graph里，把coped graph里的节点按照 orignal graph 的连接关系连接－也就是加到neighbor里面。&lt;/p&gt;

&lt;p&gt;Graph Valid Tree&lt;/p&gt;

&lt;p&gt;給一堆边来表示graph，问是不是valid tree。区别就在于 树里面 不可能有环。 那么如何探测图里面的环？遍历一下就行，如果是树，那么每个点只会被访问一次，如果有环，则会被访问多次。&lt;/p&gt;

&lt;p&gt;Undirected graph 没有入度和出度一说，所有的边都是度。第一步建图，只需一个map, 记录点和对应的边。&lt;/p&gt;

&lt;p&gt;然后从任意点开始做bfs，要用一个set或者vector来记录访问过的点，再次访问的话就判断不是树。&lt;/p&gt;

&lt;p&gt;弹出一个父亲：在孩子节点上删除父亲到孩子的边，将孩子压入队列，然后删除该父亲。&lt;/p&gt;

&lt;p&gt;最后要加一个判断，看是否所有的点都访问过。不然有可能是两个不连接的图。那也不符合题意。&lt;/p&gt;

&lt;p&gt;Number of Connected Components in an Undirected Graph&lt;/p&gt;

&lt;p&gt;需要有一个visited 的数组来记录是否被访问过。遍历每一个点，对每一个没访问过的点(还存在在只由条件给的edge构造的graph中) 做BFS。BFS过程中删点和边，同时记录访问。BFS完 counter 加一。 最后要注意，因为条件给的是边，所以有的单个的点可以不在这个边的集合上，所以要再遍历一遍visited看看没有被访问过的就是单个的点。单个的点也是graph啊。这就是这个visited的意义所在。&lt;/p&gt;

&lt;p&gt;Minimum Height Trees&lt;/p&gt;

&lt;p&gt;最多最多只有两个 MHT 在图里。这道题才真正需要degree。首先需要明白，最大的MHT只能是两个node。证明的话用反证法，假设有3个，那么必然可以变到1个。&lt;/p&gt;

&lt;p&gt;那么就可以用这么一个做法，每次把叶子都剥下来，直到剩下的节点数小于等于2。用degree来记录每个点的度数。那么度数为1就是叶子节点。把叶子剥下来就意味着度数为0，但是要区别最后剩下的点而不是不要的点，我们把这些剥下来的点度数设为-1。然后总数-1。对他们的父节点也要减掉度数。循环直到剩下的点小于等于2。&lt;/p&gt;

&lt;p&gt;再用一次循环找到度数为0 或者 为 1的点，那么就是剩下来的结果。&lt;/p&gt;

&lt;p&gt;DFS&lt;/p&gt;

&lt;p&gt;Reconstruct Itinerary&lt;/p&gt;

&lt;p&gt;一笔画问题。注意要用一个hashmap来表示graph，虽然这个graph是有向的，但是不需要入度出度。key是string, value需要一个multiset 因为同一个出发地可能有好几张同一个目的地的机票。&lt;/p&gt;

&lt;p&gt;用一个while 循环对当前的点做DFS。每到一个点就往所有的孩子递归，每一次删除对应的边，直到当前节点已经没有出去的边。跳出循环后加入该点－意味着没边可以走了，就开始往回弹栈，把点压入答案中。&lt;/p&gt;

&lt;p&gt;BFS Shortest distance&lt;/p&gt;

&lt;p&gt;图给的是基本上邻接表，所以最短路径本来用dijkstra做的可以简化为BFS，因为路径间的权重都是1。&lt;/p&gt;

&lt;p&gt;Walls and Gates&lt;/p&gt;

&lt;p&gt;最基础的BFS找路径。&lt;/p&gt;

&lt;p&gt;Word Ladder ／ Word Ladder II（TODO）&lt;/p&gt;

&lt;p&gt;可以抽象成图的问题。难点在时间复杂度的优化上。&lt;/p&gt;

&lt;p&gt;如何找到符合要求的neighbor？&lt;/p&gt;

&lt;p&gt;遍历在dict里其余所有word，和当前的比较，那么是O(nk)的复杂度，算上BFS，总的复杂度能达到O(n^2k)。&lt;/p&gt;

&lt;p&gt;k是word的长度。&lt;/p&gt;

&lt;p&gt;依次替换当前word里的字母，找dict里是否存在，在替换回来。那么是O(26*k)的复杂度，总的复杂度可以优化到O(nk).&lt;/p&gt;

&lt;p&gt;如何求出具体路径？用一个hashmap来记录每层的word，key是从头开始的距离，value是所有这些距离的词。然后做DFS即可。注意用一个visited去重。&lt;/p&gt;

&lt;p&gt;还能优化吗？TODO：双端BFS。&lt;/p&gt;

&lt;p&gt;Surrounded Regions&lt;/p&gt;

&lt;p&gt;标记法。&lt;/p&gt;

&lt;h2 id=&#34;search-in-gragh&#34;&gt;Search In Gragh&lt;/h2&gt;

&lt;h3 id=&#34;leetcode-317-shortest-distance-from-all-buildings&#34;&gt;Leetcode 317: Shortest Distance from All Buildings&lt;/h3&gt;

&lt;p&gt;找到一个点，从他开始到所有的buildings的距离最短的和，中间有障碍物。对每个点做BFS，然后加起来求一个最小值。这样的时间复杂度是 $O(m*n)[BFS] * O(m*n)[matrix] = O(m^2*n^2)$。优化：从building开始搜。那么时间复杂度为$O(k*m*n)$。 $k$ 是 building 的个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int shortestDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        int res = INT_MAX;
        
        vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dis(grid.size(), vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;(grid[0].size()));    
        //dis[i][j].first =&amp;gt; total distance from k buildings to grid[i][j]
        //dis[i][j].second =&amp;gt; num of times search from k buildings and visited to grid[i][j] successfully (avoid dead end)
        int m = grid.size();
        int n = grid[0].size();
        int num_buildings = 0;
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                    num_buildings++;
                }
            }
        }
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (dis[i][j].second == num_buildings) {
                    res = min(res, dis[i][j].first);
                }
            }
        }
        return res == INT_MAX? -1 : res;
    }
    
    
    void bfs(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; grid, vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; &amp;amp; dis, int i, int j) {
        queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&amp;lt;deque&amp;lt;bool&amp;gt;&amp;gt; visited(m, deque&amp;lt;bool&amp;gt;(n, false));
        
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to building in grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &amp;lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y].first += level;
                    dis[x][y].second++;
                }
                for (const auto &amp;amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &amp;lt; m &amp;amp;&amp;amp; x_prime &amp;gt;= 0 &amp;amp;&amp;amp; y_prime &amp;lt; n &amp;amp;&amp;amp; y_prime &amp;gt;= 0 &amp;amp;&amp;amp; 
                        grid[x_prime][y_prime] == 0 &amp;amp;&amp;amp;
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
        
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Best Meeting Point&lt;/p&gt;

&lt;p&gt;和上题一样的做法，只是可以在人所在的位置。做BFS标记visited的时候要注意。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minTotalDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        int res = INT_MAX;        
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dis(grid.size(), vector&amp;lt;int&amp;gt;(grid[0].size()));    
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                }
            }
        }
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                    res = min(res, dis[i][j]);
            }
        }
        return res == INT_MAX? -1 : res;        
    }
    void bfs(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; grid, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; dis, int i, int j) {
        queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&amp;lt;deque&amp;lt;bool&amp;gt;&amp;gt; visited(m, deque&amp;lt;bool&amp;gt;(n, false));
        visited[i][j] = true;
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &amp;lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y] += level;
                }
                for (const auto &amp;amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &amp;lt; m &amp;amp;&amp;amp; x_prime &amp;gt;= 0 &amp;amp;&amp;amp; y_prime &amp;lt; n &amp;amp;&amp;amp; y_prime &amp;gt;= 0 &amp;amp;&amp;amp; 
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
    }    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但超时啦。
答案里给的方法是算出median。并不适用有obstacle的情况（是嘛？）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Time:  O(mn)
// Space: O(m+n)

class Solution {
public:
    int minTotalDistance(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
        vector&amp;lt;int&amp;gt; x, y;
        for (int i = 0; i &amp;lt; grid.size(); ++i) {
            for (int j = 0; j &amp;lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    x.emplace_back(i);
                    y.emplace_back(j);
                }
            }
        }
        nth_element(x.begin(), x.begin() + x.size() / 2, x.end());
        nth_element(y.begin(), y.begin() + y.size() / 2, y.end());
        const int mid_x = x[x.size() / 2];
        const int mid_y = y[y.size() / 2];
        int sum = 0;
        for (int i = 0; i &amp;lt; grid.size(); ++i) {
            for (int j = 0; j &amp;lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    sum += abs(mid_x - i) + abs(mid_y - j);
                }
            }
        }
        return sum;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations&#34;&gt;数学证明参考链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nth_element()
把按 comparator 排序的有第n个数放在 n 的位置，前面的都比它“小”， 后面的都比它“大”。 但其他并不保证有序，时间复杂度 $O(n)$ 比 sort 好一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;leetcode-407-trapping-rain-water-ii&#34;&gt;Leetcode 407: Trapping Rain Water II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int trapRainWater(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; heightMap) {
        if (heightMap.empty()) {
            return 0;
        }
        int rst = 0;
        int m = heightMap.size();
        int n = heightMap[0].size();

        auto cmp = [&amp;amp;heightMap](const pair&amp;lt;int, int&amp;gt; &amp;amp; a, const pair&amp;lt;int, int&amp;gt; &amp;amp; b) {
            return heightMap[a.first][a.second] &amp;gt; heightMap[b.first][b.second]; 
        };
        
        priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp);
        vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(m, vector&amp;lt;bool&amp;gt;(n, false));
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        
        //start with boundary
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                if(!(i==0 || i==m-1 || j==0 || j==n-1)) continue;
                min_heap.emplace(i, j);
                visited[i][j] = 1;
            }
        }
        
        int max_h = 0;
        int x, y;
        while (!min_heap.empty()) {
            x = min_heap.top().first;
            y = min_heap.top().second;
            max_h = max(heightMap[x][y], max_h);
            min_heap.pop();
            for (auto dir : dirs) {
              int x_n = x + dir.first;
              int y_n = y + dir.second;
              if (x_n &amp;gt; 0 &amp;amp;&amp;amp; x_n &amp;lt; m - 1 &amp;amp;&amp;amp; y_n &amp;gt; 0 &amp;amp;&amp;amp; y_n &amp;lt; n - 1 &amp;amp;&amp;amp; !visited[x_n][y_n]) {
                visited[x_n][y_n] = true;
                rst += max(0, (max_h - heightMap[x_n][y_n]));
                min_heap.emplace(x_n, y_n);
              }              
            }
        }
        return rst;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Skyline&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data Structures for Disjoint Sets</title>
      <link>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</guid>
      <description>

&lt;h1 id=&#34;disjoint-sets&#34;&gt;Disjoint Sets&lt;/h1&gt;

&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;make_set(x)
将一个vertex变成一个disjoint&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;union(x, y)
将包含vertex x 的 set 和 包含vertex y 的 set 并起来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find_set(x)
返回一个指针，指向包含这个vertex 的唯一的 set&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;简单的应用&#34;&gt;简单的应用&lt;/h2&gt;

&lt;p&gt;最基本的应用是来确定一个 undirected graph 中的 connected components.&lt;/p&gt;

&lt;p&gt;连接components:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connected_component(G)
    for each vertex v in G
        make_set(v)
    for each edge(u, v) e in G
        if (find_set(u) != find_set(v))
            union(u, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断两个vertices是否连接在同一component中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;same_component(u, v)
    if find_set(u) == find_set(v)
        return true
    else
        return false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;并查集森林-disjoint-set-forest&#34;&gt;并查集森林 (Disjoint-Set Forest)&lt;/h2&gt;

&lt;p&gt;除了可以用链表来实现 disjoint-set， disjoint-set forest是一种比链表实现更快的实现。我们将sets表示为rooted trees。 每一个 node 包括一个 vertex，每一棵树代表一个set. 所有的node都指向各自的parent. 在树中那个指向自己的显然就是tree root。这种数据结构高效的原因是用了
以下两种技巧：&amp;rdquo;union by rank&amp;rdquo;, &amp;ldquo;path compression&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;union-by-rank&#34;&gt;Union By Rank&lt;/h3&gt;

&lt;p&gt;为每个node维护一个变量rank。 rank代表这这个node的高度的上限。在并集的过程中，我们依据rank的高低，把低rank的root指向高rank的root。&lt;/p&gt;

&lt;h3 id=&#34;path-compression&#34;&gt;Path compression&lt;/h3&gt;

&lt;p&gt;路径压缩并不改变任何rank，只是把tree中的所有node都指向这颗树的root。这个过程在find_set这个操作中实现。&lt;/p&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;make_set(x)
x.p = x
x.rank = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;union(x, y)
    link(find_set(x), find_set(y))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;link(x,y)
    if x.rank &amp;gt; y.rank
        y.p = x
    else if x.rank &amp;lt; y.rank
        x.p = y
    else
        x.p = y
        y.rank = y.rank + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;find_set(x)
    if x != x.p
        x.p = find_set(x.p)
    return x.p
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h3&gt;

&lt;p&gt;时间复杂度为 O(m alpha(n))
TODO: 分析&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;h2 id=&#34;detect-cycle-in-a-undirected-graph&#34;&gt;Detect Cycle in a undirected graph&lt;/h2&gt;

&lt;p&gt;图的相关数据结构表示和函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct Edge_t {
	int src;
	int dest;
} Edge;

typedef struct Graph_t {
	int V, E;
	Edge* edges;
} Graph;

Graph* build_graph(int V, int E) {
	Graph* graph = (Graph*)malloc(sizeof(Graph));
	graph-&amp;gt;V = V;
	graph-&amp;gt;E = E;
	graph-&amp;gt;edges = (Edge*)malloc(E * sizeof(Edge));
	return graph;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Disjoint-Set的相关数据结构和函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct disjoint_set_t {
	int parent;
	int rank;
}Disjoint_Set;

int find_set(Disjoint_Set allsets[], int x) {
	if (allsets[x].parent != x) {
		allsets[x].parent = find_set(allsets, allsets[x].parent);
	}
	return allsets[x].parent;
}

void union_set(Disjoint_Set allsets[], int x, int y) {

	int xroot = find_set(allsets, x);
	int yroot = find_set(allsets, y);

	if (allsets[xroot].rank &amp;gt; allsets[yroot].rank) {
		allsets[yroot].parent = xroot;
	} else if (allsets[xroot].rank &amp;lt; allsets[yroot].rank) {
		allsets[xroot].parent = yroot;
	} else {
		allsets[xroot].parent = yroot;
		allsets[yroot].rank++;
	}
}

bool is_cycle(Graph* graph) {
	int V = graph-&amp;gt;V;
	int E = graph-&amp;gt;E;

	Disjoint_Set* allsets = (Disjoint_Set*)malloc(V * sizeof(Disjoint_Set));
	for (int v = 0;  v &amp;lt; V; v++) {
		allsets[v].parent = v;
		allsets[v].rank = 0;
	}

	for (int e = 0; e &amp;lt; E; e++) {
		int x = find_set(allsets, graph-&amp;gt;edges[e].src);
		int y = find_set(allsets, graph-&amp;gt;edges[e].dest);

	if(x == y) {
	return true;
	}
	union_set(allsets, x, y);
	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main函数测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main () {

	int V = 3;
	int E = 3;

	Graph* graph = build_graph(V, E);
	graph-&amp;gt;edges[0].src = 0;
	graph-&amp;gt;edges[0].dest = 1;
	graph-&amp;gt;edges[1].src = 1;
	graph-&amp;gt;edges[1].dest = 2;
	graph-&amp;gt;edges[2].src = 0;
	graph-&amp;gt;edges[2].dest = 2;
	if (is_cycle(graph)) {
		printf(&amp;quot;Cycle detected.&amp;quot;);
	} else {
		printf(&amp;quot;No cycle detected.&amp;quot;);
	}
	return 0;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;leetcode-305-number-of-islands-ii&#34;&gt;LeetCode 305 Number of Islands II&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://pineal.github.com/posts/bit_manipulation/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/bit_manipulation/</guid>
      <description>

&lt;h1 id=&#34;summary-of-basic-bit-manipulation&#34;&gt;Summary of Basic Bit Manipulation&lt;/h1&gt;

&lt;h2 id=&#34;count-1-in-binary&#34;&gt;Count 1 in Binary&lt;/h2&gt;

&lt;p&gt;数的二进制表示中有多少位1. 有两种方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每次把各位的数和 1 做 &amp;amp; 运算，然后计数，右移进行下一位。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        for (int i = 0; i &amp;lt; sizeof(int)*8; i++) {
            counter += num &amp;amp; 1;
            num &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;把 num 和 num - 1 做 &amp;amp; 运算， 直到num为0，有多少次运算就有多少个1. 因为每次“&amp;amp;”都会去掉num最右边的1.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        while (num) {
            num &amp;amp;= num - 1;
            counter++;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用法判断是不是2的整数次幂很容易，因为2的整数次幂必然只有1个bit的1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkPowerOf2(int n) {
    // write your code here
    return n &amp;gt; 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flip-bits&#34;&gt;Flip Bits&lt;/h2&gt;

&lt;p&gt;用到了xor的性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param a, b: Two integer
     *return: An integer
     */
    int bitSwapRequired(int a, int b) {
        // write your code here
        int counter = 0;
        int c = a^b;
        for (int i = 0; i &amp;lt; 32; i++) {
            counter += c &amp;amp; 1;
            c &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-b-problem&#34;&gt;A + B problem&lt;/h2&gt;

&lt;p&gt;这题。
         主要利用异或运算来完成。
         异或运算有一个别名叫做：不进位加法。
         那么a ^ b就是a和b相加之后，该进位的地方不进位的结果。
         然后下面考虑哪些地方要进位，自然是a和b里都是1的地方。
         a &amp;amp; b就是a和b里都是1的那些位置，a &amp;amp; b &amp;lt;&amp;lt; 1 就是进位
         之后的结果。所以：a + b = (a ^ b) + (a &amp;amp; b &amp;lt;&amp;lt; 1)
         。令a&amp;rsquo; = a ^ b, b&amp;rsquo; = (a &amp;amp; b) &amp;lt;&amp;lt; 1
         可以知道，这个过程是在模拟加法的运算过程，进位不可能
         一直持续，所以b最终会变为0。因此重复做上述操作就可以
         求得a + b的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
       while (b != 0) {
            int _a = a ^ b;
            int _b = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
            a = _a;
            b = _b;
        }
        return a;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-bits&#34;&gt;Update Bits&lt;/h2&gt;

&lt;p&gt;Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.&lt;/p&gt;

&lt;p&gt;把一个数的 ［j， i］ 之间的bits 用另一个数去填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int right_part = n &amp;amp; ((1 &amp;lt;&amp;lt; i) - 1);
        // The behavior of right shift &amp;gt;= 32 is undefined in C++.
        int left_part = j &amp;gt;= 31 ? 0 : (n &amp;gt;&amp;gt; (j + 1)) &amp;lt;&amp;lt; (j + 1);
        return left_part | (m &amp;lt;&amp;lt; i) | right_part;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用一个 mask 把 i 右边的数给取出来。
左边的数要这么取：先把bits右移 j + 1位，然后再左移 j + 1位，这样右边的数就都清空了。
最后一步把 m 左移后再把左边部分和右边部分用 ｜ 粘起来。
这种思想还可以用来做高地位互换等。把前一半的数右移，把后一半的数左移，然后 ｜ 起来。&lt;/p&gt;

&lt;h2 id=&#34;swap-two-variables&#34;&gt;swap two variables&lt;/h2&gt;

&lt;p&gt;如何不用第三个临时变量来交换两个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(int &amp;amp;a, int &amp;amp;b){
	if (a != b){
		  a ^= b;
      b ^= a;
      a ^= b;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;abs&#34;&gt;abs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//取符号位
	int a = -100;
	int i = a &amp;gt;&amp;gt; 31;
	//i = 0 正数
	if(i == 0){
		printf(&amp;quot;%d\n&amp;quot;,a);
	}
	//i = 1 负数
	else{
		printf(&amp;quot;%d\n&amp;quot;,~a + 1);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-complement&#34;&gt;Number Complement&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int findComplement(int num) {
        unsigned mask = ~0;
        while (num &amp;amp; mask) mask &amp;lt;&amp;lt;= 1;
        return ~mask &amp;amp; ~num;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://pineal.github.com/posts/sorting_algorithms/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sorting_algorithms/</guid>
      <description>

&lt;p&gt;假设这里的排序都是升序。&lt;/p&gt;

&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort:&lt;/h2&gt;

&lt;p&gt;插入排序。假设一个长度为N的数组A[]，总体过程过程为，从index为1开始到N-1，使得A[0,index]是一个排好序的数组。&lt;/p&gt;

&lt;p&gt;具体过程为，把A[index]从index到0逐一比较（这里的顺序一定要从后往前，因为已经是排好序的了），找到第一个比他小的数，然后插到这个数的后面，当然原来位置及以后的数都要往后挪一位。实际代码中是在for循环中加入找到这个小数的条件，每次都往后挪，循环完了才插入。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;p&gt;| Original | 34  8  64  51  32  21 | Position Moved |
| &amp;ndash; | &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash; | &amp;ndash; |
| after i = 1 | 8  34  64  51  32  21 | 1 |
| after i = 2 | 8  34  64  51  32  21 | 0 |
| after i = 3 | 8  34  51  64  32  21 | 1 |
| after i = 4 | 8  32  34  51  64  21 | 3 |
| after i = 5 | 8  21  32  34  51  64 | 4 |&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void insertion_sort(T arr[], int len){
  for (int i = 1; i &amp;lt; len; i++){
    int temp = arr[i];
      for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1]&amp;gt;temp; j--){ //实际比较的是j-1
        arr[j] = arr[j-1];  //全部往后移一位腾出位置等插入
      }
    arr[j] = temp;    //插入到腾出来的位置
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析：&lt;/p&gt;

&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort:&lt;/h2&gt;

&lt;p&gt;选择排序。假设一个长度为N的数组A[]，总体过程过程为，从index为0开始到N-1，使得A[0,index]是一个排好序的数组。&lt;/p&gt;

&lt;p&gt;怎么跟插入排序这么像呢？&lt;/p&gt;

&lt;p&gt;是挺像的，但是具体的过程是有区别。这区别就是“插入”和“选择”的区别。&lt;/p&gt;

&lt;p&gt;插入排序是每次往前面那些已经排序好的数里“插入”进去，而选择排序则是，每次从这个数后面那些没排好序的数里“选择”到最小的，和这个数交换。&lt;/p&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;p&gt;| Original | 34  8  64  51  32  21 | Position Moved |
| &amp;ndash; | &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash;  &amp;ndash; | &amp;ndash; |
| after i = 1 | 8  34  64  51  32  21 | 1 |
| after i = 2 | 8  21  64  51  32  34 | 4 |
| after i = 3 | 8  21  32  51  64  34 | 2 |
| after i = 4 | 8  21  32  34  64  51 | 2 |
| after i = 5 | 8  21  32  34  51  64 | 1 |&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void selection_sort(T arr[], int len){
  for (int i = 0; i &amp;lt; len - 1; i++){  //len - 1即可，最后一次交换在倒数第一个和倒数第二个之间进行
    int min_index = i;
    for (int j = i + 1; j &amp;lt; len; j++){
      //找到未排序的数组中最小的数的index
      if (arr[j]&amp;lt;arr[min_index]){
          min_index = j;
      }        
    }
    swap(arr[i], arr[min_index]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附上冒泡排序代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(int arr[], int n) {
    int i, j;
    for (i = 0; i &amp;lt; n - 1; i++) {
        for (j = 0; j &amp;lt; n - 1 - i; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析：
$O(n^2)$的复杂度。实际上是冒泡排序的一个优化，虽然最坏时间复杂度上是一样的。&lt;/p&gt;

&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort:&lt;/h2&gt;

&lt;p&gt;归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//Merge part
  vector&amp;lt;int&amp;gt; merge(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
	  vector&amp;lt;int&amp;gt; rst;
	  std::vector&amp;lt;int&amp;gt;::iterator iter1 = A.begin(), iter2 = B.begin();
//this is not elegant, may be &amp;amp;&amp;amp; and insert the rest may be better
	  while (iter1 != A.end() || iter2 != B.end()) {
	  	if (iter1 == A.end()) {
		  	rst.insert(rst.end(), iter2, B.end());
		  	break;
		  }
		  if (iter2 == B.end()) {
		  	rst.insert(rst.end(), iter1, A.end());
		  	break;
		  }
		  if (*iter1 &amp;lt; *iter2) {
			  rst.emplace_back(*iter1);
			  iter1++;
		  }
		  else {
			  rst.emplace_back(*iter2);
			  iter2++;
		  }
	  }
	  return rst;
  }

//Key part of Merge sort, recursive function
  vector&amp;lt;int&amp;gt; MSort(vector&amp;lt;int&amp;gt; array, int left, int right) {
	  vector&amp;lt;int&amp;gt; rst;
	  if (left == right) {
		  rst.emplace_back(array[left]);
		  return rst;
	  }
	  int mid = left + (right - left) / 2;
	  vector&amp;lt;int&amp;gt; leftArr = MSort(array, left, mid);
	  vector&amp;lt;int&amp;gt; rightArr = MSort(array, mid + 1, right);
	  rst = merge(leftArr, rightArr);
	  return rst;
  }
//Driver for Merge Sort
  vector&amp;lt;int&amp;gt; mergeSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
	  vector&amp;lt;int&amp;gt; rst;
	  rst = MSort(array, 0, array.size() - 1);
	  return rst;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析： $$O(nlog(n))$$：画出递归树，一共$$log(n)$$层, 每一层是$$O(n)$$的复杂度.&lt;/p&gt;

&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort:&lt;/h2&gt;

&lt;p&gt;快速排序。快速排序是一个比较复杂的问题。基本的思想为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选取一个pivot。&lt;/li&gt;
&lt;li&gt;所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边。&lt;/li&gt;
&lt;li&gt;分割数组：对pivot两边的数组递归重复以上步骤，直到不能分割。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体有哪些实现呢。
先来看第一种方法。这是一个textbook的解法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; int median(vector&amp;lt;int&amp;gt;&amp;amp; arr, int left, int right){
   // arr[left] &amp;lt;= arr[center] &amp;lt;= arr[right]
   int center = left + (right - left)/2;
   if (arr[left] &amp;gt; arr[center]) swap(&amp;amp;arr[left], &amp;amp;arr[center]);
   if (arr[left] &amp;gt; arr[right])  swap(&amp;amp;arr[left], &amp;amp;arr[right]);
   if (arr[center] &amp;gt; arr[right]) swap(&amp;amp;arr[center], &amp;amp;arr[right]);
   swap(&amp;amp;arr[center], &amp;amp;arr[right - 1]); //hide pivot
   return arr[right - 1];
 }

 void QSort(vector&amp;lt;int&amp;gt; &amp;amp; arr, int left, int right) {

//   if (left &amp;gt;= right) return;
   if (left + CutOff &amp;lt;= right){
     int pivot = median(arr, left, right);
     int i = left;
     int j = right - 1;
     for(;;){
      while (arr[++i] &amp;lt; pivot){}
       while (arr[--j] &amp;gt; pivot){}
      if (i &amp;lt; j) swap(&amp;amp;arr[i], &amp;amp;arr[j]);
       else  break;
     }
//   if (left + 1 != right){
       swap(&amp;amp;arr[i], &amp;amp;arr[right - 1]); //restore pivot
//   }  
     QSort(arr, left, i - 1);
     QSort(arr, i + 1, right);
   }
   else{
     insertion_Sort(arr, left, right - left + 1);
   }
 }

 vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
   if (array.size() &amp;lt;= 1) return array;
   QSort(array, 0, array.size() - 1);
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个解法。基本思想是一样的。每次都要保持所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边这个条件。
实现的过程为，选取两块挡板，分别从数组的头和尾往中间靠拢，直到挡板相遇。在每一次的循环中，保证第一块挡板左边的数都小于pivot，第二块挡板右边的数都大于pivot。&lt;/p&gt;

&lt;p&gt;事实上根据上面这个general rule来分，两个挡板指向的两个数只有四种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;a[i] &amp;lt; pivot, a[j] &amp;gt; pivot&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a[i] &amp;lt; pivot, a[j] &amp;lt; pivot&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a[i] &amp;gt; pivot, a[j] &amp;gt; pivot&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a[i] &amp;gt;= pivot, a[j] &amp;lt;= pivot&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么对应刚才的rule该做着么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;满足条件：移动挡板i++， j&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足前半个条件，移动挡板i++，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足后半个条件，移动挡板j&amp;ndash;，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不满足任何条件，但是一旦交换两个挡板上的数，即可让条件满足&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看下代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  void QuickSort(vector&amp;lt;int&amp;gt; &amp;amp; array, int left, int right){
    if (left &amp;gt; right) return;
    int pivot_index = (left + right)/2;
    int pivot =  array[pivot_index];
    int left_bound = left;
    int right_bound = right - 1;
    //hide the pivot in the rightmost
    std::swap(array[pivot_index], array[right]);
    //three regions:
    //1. [0, leftbound - 1] : all elements smaller than pivot should be here
    //2. [leftbound, rightbound]: to be discovered, scan the element in a[leftbound], and move leftbound every step
    //3. [rightbound + 1, array.size() - 1] all elements bigger than pivot should be here
    while (left_bound &amp;lt;= right_bound) {
      //check two
      if (array[left_bound] &amp;lt; pivot) {
      // obey all three rules, move leftbound
        ++left_bound;
      }
      else if (array[right_bound] &amp;gt; pivot) {
        --right_bound;
      }
      else {
        //array[left_bound] &amp;gt; pivot &amp;amp;&amp;amp; array[right_bound &amp;lt; pivot]
        std::swap(array[left_bound++], array[right_bound--]);      
      }
    }
    //restore the pivot to the original position
    std::swap(array[left_bound], array[right]);
    //partition and recursion
    QuickSort(array, left, left_bound - 1);
    QuickSort(array, left_bound + 1, right);
  }

  vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
    QuickSort(array, 0, array.size() - 1);
    return array;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的解法可以归结为一种类型。比如一堆数中只有两种，三种四种数，那么就可以对应个数的挡板将数分割成相应区域，每次检查条件是否满足。Eg: Sort colors。这样的做法复杂度只需要$O(n)$.&lt;/p&gt;

&lt;h3 id=&#34;sort-colors&#34;&gt;Sort Colors&lt;/h3&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int zero = 0;
    int one = 0;    //explorer
    int two = nums.size() - 1;
    //Three seperator Four regions
    //[0, zero)     0
    //[zero, one]   1
    //(two, end]    2
    while (one &amp;lt;= two) {
        if (nums[one] == 0) {   
            swap(nums[one++], nums[zero++]);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums[one], nums[two--]);
            //don&#39;t move &#39;one&#39;:
            //you don&#39;t know what is swaped from &#39;two&#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-i-four-colors&#34;&gt;Follow up I: four colors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; rainbowSortII(vector&amp;lt;int&amp;gt; array) {
   int zero = 0, one = 0, other = array.size() - 1;
   while (one &amp;lt;= other) {
     if (array[one] &amp;lt; 1) {
       swap(array[one++], array[zero++]);
     } else if (array[one] &amp;gt; 1) {
       swap(array[other--], array[one]);
     } else {
       one++;
     }
   }
   int two = one, three = array.size() - 1;
   while (two &amp;lt;= three) {
     if (array[two] == 3 &amp;amp;&amp;amp; array[three] == 2) {
       swap(array[two++], array[three--]);
     } else if (array[two] == 2) {
       two++;
     } else {
       three--;
     }
   }
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-ii-k-colors&#34;&gt;Follow up II: k colors&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&#34;wiggle-sort&#34;&gt;Wiggle Sort&lt;/h2&gt;

&lt;p&gt;nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]&amp;hellip;.&lt;/p&gt;

&lt;p&gt;这个时间复杂度优化到了O(n)。下面那个做法是通用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    for (int i=0; i&amp;lt;(int)nums.size() - 1; i++) {
        if (i % 2 == 0 &amp;amp;&amp;amp; nums[i] &amp;gt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
        if (i % 2 == 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
    }        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-wiggle-sort-ii&#34;&gt;Follow up: Wiggle Sort II&lt;/h3&gt;

&lt;p&gt;nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;&lt;/p&gt;

&lt;p&gt;根据这个性质，我们可以确定一种排法一定可以成立：把小的那一半排在偶数位，把大的那一半排在奇数位。这个是通用的。
 时间复杂度 $ O(nlog(n)) $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    vector&amp;lt;int&amp;gt; copy(nums);
    sort(copy.begin(), copy.end());
    int left = (nums.size() + 1) / 2 - 1;
    int right = nums.size() - 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        nums[i] = (i % 2 == 0)? copy[left--] : copy[right--];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传说中$O(n)$ 的解法。&lt;/p&gt;

&lt;h2 id=&#34;sort-in-specified-order&#34;&gt;Sort In Specified Order&lt;/h2&gt;

&lt;p&gt;A1 = {2, 1, 2, 5, 7, 1, 9, 3}, A2 = {2, 1, 3}, A1 is sorted to {2, 2, 1, 1, 3, 5, 7, 9}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; helper(vector&amp;lt;int&amp;gt; &amp;amp; A1, vector&amp;lt;int&amp;gt; &amp;amp; A2) {
   // Write your solution here.
   if (A1.size() &amp;lt;= 1 || A2.size() == 0) {
       sort(A1.begin(), A1.end());
       return A1;
   }
   map&amp;lt;int, int&amp;gt; t;
   for (int i = 0; i &amp;lt; A2.size(); i++) {
       t.emplace(A2[i], i);
   }

   int j = 0, k = A1.size() - 1;
   while (j &amp;lt;= k) {
       if (t.find(A1[j]) == t.end() &amp;amp;&amp;amp; t.find(A1[k]) != t.end()) {
           swap(A1[j], A1[k]);
           j++;
           k--;
       }
       else if (t.find(A1[j]) != t.end()) {
           j++;
       }
       else {
           k--;
       }
   }

   //sort the [0, j) in specified order
   //[2 1 3 4]
   //2 1 2 1 4 3 =&amp;gt; 2 2 1 1 3 4

   for (int i = 0; i &amp;lt; j; i++) {
       int min_index = i;
       for (int l = i; l &amp;lt; j; l++) {
           if (t[A1[min_index]] &amp;gt; t[A1[l]]) {
               min_index = l;
           }
       }
       swap(A1[i], A1[min_index]);
   }

   //sort the (k, n) part in ascending order
   sort(A1.begin() + k + 1, A1.end());
   return A1;
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Jump Game</title>
      <link>https://pineal.github.com/posts/jump_game/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/jump_game/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/jump-game/&#34;&gt;Jump Game&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/jump-game-ii/&#34;&gt;Jume Game II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两题明眼看是序列形动态规划的题，但是时间复杂度上其实并不好，会出现超时的情况。而用贪心法则能避免。单独拿出来记录一下贪心法。尤其是Jump Game II 的做法非常巧妙。&lt;/p&gt;

&lt;h2 id=&#34;jump-game&#34;&gt;Jump Game&lt;/h2&gt;

&lt;p&gt;动态规划解法，无法被AC, c++的解法会超时。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    bool canJump(vector&amp;lt;int&amp;gt; A) {
        if (A.empty()) {
            return true;
        }

        vector&amp;lt;bool&amp;gt; jumpto(A.size(), false);
        jumpto[0] = true;

        for (int i = 1; i != A.size(); ++i) {
            for (int j = i - 1; j &amp;gt;= 0; --j) {
                if (jumpto[j] &amp;amp;&amp;amp; (j + A[j] &amp;gt;= i)) {
                    jumpto[i] = true;
                    break;
                }
            }
        }

        return jumpto[A.size() - 1];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贪心法的解法，很快。&lt;/p&gt;

&lt;p&gt;维护一个最远能到达的变量，如果当前位置的值超过了这个变量那么更新该变量。从头循环到尾，如果现在的位置超过了最远能到达的位置，那说明到不了最后，返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    bool canJump(vector&amp;lt;int&amp;gt; A) {
        // write you code here

        int reachable = 0;
        for (int i = 0; i &amp;lt; A.size(); ++i){
            if (i &amp;gt; reachable){
                return false;
            }
            reachable = max(reachable, i + A[i]);
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jump-game-ii&#34;&gt;Jump Game II&lt;/h2&gt;

&lt;p&gt;动态规划的和之前的没什么大差别，把维护的数组类型从bool换成了int记录步数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of lists of integers
     * @return: An integer
     */
    int jump(vector&amp;lt;int&amp;gt; A) {
        if (A.empty()) {
            return -1;
        }

        const int N = A.size() - 1;
        vector&amp;lt;int&amp;gt; steps(N, INT_MAX);
        steps[0] = 0;

        for (int i = 1; i != N + 1; ++i) {
            for (int j = 0; j != i; ++j) {
                if ((steps[j] != INT_MAX) &amp;amp;&amp;amp; (j + A[j] &amp;gt;= i)) {
                    steps[i] = steps[j] + 1;
                    break;
                }
            }
        }

        return steps[N];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贪心法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Time:  O(n)
// Space: O(1)

class Solution {
public:
    /**
     * @param A: A list of lists of integers
     * @return: An integer
     */
    int jump(vector&amp;lt;int&amp;gt; A) {
        int jump_count = 0;
        int reachable = 0;
        int curr_reachable = 0;
        for (int i = 0; i &amp;lt; A.size(); ++i) {
            if (i &amp;gt; curr_reachable) {
                // current jumps are not enough,
                // jump one more step, which enlarges curr_reachable to reachable.
                curr_reachable = reachable;
                ++jump_count;
            }
            reachable = max(reachable, i + A[i]);
        }   

        return jump_count;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.kancloud.cn/kancloud/data-structure-and-algorithm-notes/73079&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>https://pineal.github.com/posts/palindrome_partitioning/</link>
      <pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/palindrome_partitioning/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;分隔回文串问题，共有两题，分别是搜索和动归的代表题型。刚碰到的时候理解比较难，单独拿出来看一看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning/&#34;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning-ii/&#34;&gt;Palindrome Partitioning II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;palindrome-partitioning-ii&#34;&gt;Palindrome Partitioning II&lt;/h2&gt;

&lt;p&gt;求最小的分割次数，一维的一个数组，满足动态规划的条件。&lt;/p&gt;

&lt;p&gt;提示：动归字符串时基本上要把f[0]空出来，这样就需要n+1长度的一个数组来记录最优值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minCut(string s) {
        int len = s.size();
        if (len &amp;lt;= 1) return 0;

//用一个矩阵来记录子字符串s[i:j]是否为回文串

        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; mat = vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt;(len, vector&amp;lt;bool&amp;gt;(len, true));

        for (int i = len; i &amp;gt;= 0; --i) {
            for (int j = i; j &amp;lt; len; ++j) {
//                if((i+1&amp;gt;j-1 || isPal[i+1][j-1]) &amp;amp;&amp;amp; s[i]==s[j])
//                    isPal[i][j] = true;                
//很多答案给的是这样的判断方法，个人觉得没有下面的清楚，边界条件实际上就两种，要么i==j要么i和j靠在一起。其他就判断xSx是不是回文串（如果S是的话）              
                if (j == i) {
                    mat[i][j] = true;
                } else if (j == i + 1) {
                    mat[i][j] = (s[i] == s[j]);
                } else {
                    mat[i][j] = ((s[i] == s[j]) &amp;amp;&amp;amp; mat[i + 1][j - 1]);
                }
            }
        }

        vector&amp;lt;int&amp;gt; cut(len + 1, INT_MAX);

// 真正的sequence DP: cut[i]表示到i的minCut
// 到位置i时候，就判断j+1到i是不是一个回文串（到角标就变成了和j , i-1）
// 就找所有比i小的j的位置上能切的minCut + 1（此时条件为上面那个矩阵）
//

        for (int i = 1; i &amp;lt; 1 + len; ++i) {
            for (int j = 0; j &amp;lt; i; ++j) {
                if (mat[j][i - 1]) {
                    cut[i] = min(cut[i], 1 + cut[j]);
                }
            }
        }

        return cut[len];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个&lt;a href=&#34;https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space&#34;&gt;优化的解&lt;/a&gt;以后留着看。&lt;/p&gt;

&lt;h2 id=&#34;palindrome-partitioning&#34;&gt;Palindrome Partitioning&lt;/h2&gt;

&lt;p&gt;这题求的是具体的分隔方法，基本上就是DFS搜索加回溯的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;
        if (s.empty()) return result;

        vector&amp;lt;string&amp;gt; palindromes;
        dfs(s, 0, palindromes, result);

        return result;
    }

private:
    void dfs(string s, int pos, vector&amp;lt;string&amp;gt; &amp;amp;palindromes,
             vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;ret) {

        if (pos == s.size()) {
            ret.push_back(palindromes);
            return;
        }

        for (int i = pos + 1; i &amp;lt;= s.size(); ++i) {
            string substr = s.substr(pos, i - pos);
            if (!isPalindrome(substr)) {
                continue;
            }

            palindromes.push_back(substr);
            dfs(s, i, palindromes, ret);
            palindromes.pop_back();
        }
    }

    bool isPalindrome(string s) {
        if (s.empty()) return false;

        int n = s.size();
        for (int i = 0; i &amp;lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }

        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutations and N-Queens</title>
      <link>https://pineal.github.com/posts/permutations_n_queens/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/permutations_n_queens/</guid>
      <description>

&lt;h1 id=&#34;permutations-and-n-queens&#34;&gt;Permutations and N-Queens&lt;/h1&gt;

&lt;h2 id=&#34;permutation-from-stl-library&#34;&gt;Permutation from STL Library&lt;/h2&gt;

&lt;p&gt;最直接的做法：C++11中的STL中有关于排列的algorithm库可以直接用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/is_permutation&#34;&gt;std::is_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/prev_permutation&#34;&gt;std::prev_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/next_permutation&#34;&gt;std::next_permutation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他有什么用呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Changes the order of the elements in [Begin, end) according to the next permutation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return &lt;em&gt;False&lt;/em&gt; if the elements got the &amp;ldquo;normal&amp;rdquo;(lexicographical) order: that is, ascending order. So, to run through all permutations, you have to sort all elements and start a loop that calls this function as long as these algorithms return true.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution:
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt; nums){
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;

    if (nums.empty()){return {}};
    std::sort(nums.begin(), nums.end());

    do{
        result.emplace_back(nums);
    } while(next_permutation(nums.begin(), nums.end()));
    return result;
    }
};    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation-of-std-next-permutation&#34;&gt;Implementation of std::next_permutation()&lt;/h3&gt;

&lt;p&gt;大致思路为，我们先固定第一个数，然后对右边剩下的数做全排列。什么时候右边剩下的数完成了全排列呢？那就是当这些数变成了降序。然后我们才用第一个数。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation&#34;&gt;留着慢慢消化，反正直接让我写，我是写不出来。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//kan bu dong...
template&amp;lt;class BidirIt&amp;gt;
bool next_permutation(BidirIt first, BidirIt last)
{
    if (first == last) return false;
    BidirIt i = last;
    if (first == --i) return false;

    while (true) {
        BidirIt i1, i2;

        i1 = i;
        //if the elements are in ascending order
        if (*--i &amp;lt; *i1) {
            i2 = last;
            //find the next largest digit
            while (!(*i &amp;lt; *--i2));
            // and put it in front
            std::iter_swap(i, i2);
            //put the remaining digits in ascending order
            std::reverse(i1, last);
            return true;
        }
        //last purmutation
        if (i == first) {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个之后我们可以自己模拟 std::next_permutation()&lt;/p&gt;

&lt;h2 id=&#34;recursion-version-for-permutations&#34;&gt;Recursion Version for Permutations&lt;/h2&gt;

&lt;p&gt;常规的backtracking回溯，用DFS递归就行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permute(vector&amp;lt;int&amp;gt; nums) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (nums.size() == 0) return rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(rst, nums, v);
        return rst;
    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v){
        if (v.size() == nums.size()){
            rst.emplace_back(v);
            return ;
        }

        for (int i = 0; i &amp;lt; nums.size(); ++i){
            //can employ map to improve the time complexity
            //vector&amp;lt;bool&amp;gt; is not a container. do not use. alternates: deque&amp;lt;bool&amp;gt;, or bitset
            if (find(v.begin(), v.end(), nums[i]) != v.end()){
                continue;
            }
            v.emplace_back(nums[i]);
            backtracking(rst, nums, v);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;permutations-ii&#34;&gt;Permutations II&lt;/h2&gt;

&lt;p&gt;全排列去重。在循环的过程中加入while语句跳过相同的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permuteUnique(vector&amp;lt;int&amp;gt; &amp;amp;num) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permutations;
        if(num.size() == 0)
            return permutations;
        vector&amp;lt;int&amp;gt; curr;
        vector&amp;lt;bool&amp;gt; isVisited(num.size(), false);
        /* we need to sort the input array here because of this array
           contains the duplication value, then we need to skip the duplication
           value for the final result */
        sort(num.begin(),num.end());
        dfs(permutations,curr,num,isVisited);
        return permutations;
    }

    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ret, vector&amp;lt;int&amp;gt; curr, vector&amp;lt;int&amp;gt; num, vector&amp;lt;bool&amp;gt; isVisited)
    {
        if(curr.size() == num.size())
        {
            ret.push_back(curr);
            return;
        }

        for(int i = 0; i &amp;lt; num.size(); ++i)
        {
            if(isVisited[i] == false)
            {
                isVisited[i] = true;
                curr.push_back(num[i]);
                dfs(ret,curr,num,isVisited);
                isVisited[i] = false;
                curr.pop_back();
                while(i &amp;lt; num.size()-1 &amp;amp;&amp;amp; num[i] == num[i+1])
                //we use this while loop to skip the duplication value in the input array.
                    ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens&#34;&gt;N-Queens&lt;/h2&gt;

&lt;p&gt;经典的搜索题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string &#39;...Q&#39; shows a queen on forth position
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; solveNQueens(int n) {
        // write your code here
        vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; rst;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            rst.emplace_back(cur);
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens-ii&#34;&gt;N-Queens II&lt;/h2&gt;

&lt;p&gt;只要求solutions的个数就可以。这道题并不用动归解，还是要用搜索。和上一题基本没差别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    int totalNQueens(int n) {
         // write your code here
        int rst = 0;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(int&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            ++rst;
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Subsets and Combinations</title>
      <link>https://pineal.github.com/posts/subsets_combinations/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/subsets_combinations/</guid>
      <description>

&lt;h1 id=&#34;subsets-and-combinations&#34;&gt;Subsets and Combinations&lt;/h1&gt;

&lt;p&gt;Original Questions on &lt;a href=&#34;http://www.lintcode.com&#34;&gt;LeetCode&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subsets-i&#34;&gt;Subsets I&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible subsets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If S = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursive-solution&#34;&gt;Recursive Solution&lt;/h3&gt;

&lt;p&gt;Backtracking的模板。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    	if (nums.size() == 0)
    	    return {};
    	vector&amp;lt;int&amp;gt; v;
    	sort(nums.begin(), nums.end());
    	backtracking(rst, v, nums, 0);
    	return rst;

    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos){

        rst.emplace_back(v);

        for (int i = pos; i &amp;lt; nums.size(); ++i){
            v.emplace_back(nums[i]);
            backtracking(rst, v, nums, i + 1);
            v.pop_back();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterative-solution&#34;&gt;Iterative Solution&lt;/h3&gt;

&lt;p&gt;建一个result的vector用来储存结果。初始化为一个［］。从nums取出下一个元素$$m$$，和result里所有的vector: $ temp = v \in rst$, 把 m 加到这些vector的末端: $temp = temp \bigcup m$, 再把这些vector放到result中，进行下一次迭代。一共有两重循环， 外面那层代表了每次从nums中取元素共有nums.size()个，里面那层代表把元素放到新的vector里，一共有result.size() 的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	sort(nums.begin(),nums.end());
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst(1);
    	vector&amp;lt;int&amp;gt; temp;
    	for (int i = 0; i &amp;lt; nums.size(); ++i){
    	  int size = rst.size();  
    	  for (int j = 0; j &amp;lt; size; ++j){
    	      temp = rst[j];
    	      temp.emplace_back(nums[i]);
    	      rst.emplace_back(temp);
    	      temp.clear();
    	  }
    	}
    	return rst;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subsets-ii&#34;&gt;Subsets II&lt;/h2&gt;

&lt;p&gt;上面那道题的followup，加上了去重的要求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        vector&amp;lt;int&amp;gt; sorted_S(S);
        sort(sorted_S.begin(), sorted_S.end());
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result(1);
        size_t previous_size = 0;
        for (size_t i = 0; i &amp;lt; sorted_S.size(); ++i) {
            const size_t size = result.size();
            for (size_t j = 0; j &amp;lt; size; ++j) {

                if (i == 0 || sorted_S[i] != sorted_S[i - 1] || j &amp;gt;= previous_size) {
                    result.emplace_back(result[j]);
                    result.back().emplace_back(sorted_S[i]);
                }
            }
            previous_size = size;
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去重的递归：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (S.size() == 0)
            return {};
        vector &amp;lt;int&amp;gt; v;
        vector&amp;lt;int&amp;gt; nums(S);
        sort(nums.begin(), nums.end());
        backtracking(rst, nums, v, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v, int pos){

        rst.emplace_back(v);    

        for (int i = pos; i &amp;lt; nums.size(); i++){
            v.emplace_back(nums[i]);
            backtracking (rst, nums, v, i + 1);
            v.pop_back();
            while(i &amp;lt; nums.size()-1 &amp;amp;&amp;amp; nums[i] == nums[i+1]){
                ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinations&#34;&gt;Combinations&lt;/h2&gt;

&lt;p&gt;相似的递归模版：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n: Given the range of numbers
     * @param k: Given the numbers of combinations
     * @return: All the combinations of k numbers out of 1..n
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combine(int n, int k) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(n, k, rst, v, 1);
        return rst;
    }


    void backtracking(int n, int k, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, int curr){
        if (v.size() == k){
            rst.emplace_back(v);
            return;
        }

        for (int i = curr;  i &amp;lt;= n; ++i){
            v.emplace_back(i);
            backtracking(n, k, rst, v, i+1);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sequences Dynamic Programming</title>
      <link>https://pineal.github.com/posts/two_sequences_dynamic_programming/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/two_sequences_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;两个序列类型的动态规划。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/longest-common-subsequence/&#34;&gt;Longest Common Sequences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/edit-distance/&#34;&gt;Edit Distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/interleaving-string/&#34;&gt;Interleaving String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/distinct-subsequences/&#34;&gt;Distinct Subsequences&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;longest-common-sequences&#34;&gt;Longest Common Sequences&lt;/h2&gt;

&lt;p&gt;LCS是的经典动归问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    int longestCommonSubsequence(string A, string B) {
        // write your code here
        int dp[A.size() + 1][B.size() + 1];

        for (int i = 0; i &amp;lt; A.size() + 1; ++i){
            dp[i][0] = 0;
        }

        for (int i = 0; i &amp;lt; B.size() + 1; ++i){
            dp[0][i] = 0;
        }

        for (int i = 1; i &amp;lt; A.size() + 1; ++i){
            for (int j = 1; j &amp;lt; B.size() + 1; ++j){
                if (A[i - 1] == B[j - 1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
    return dp[A.size()][B.size()];    
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;edit-distance&#34;&gt;Edit Distance&lt;/h2&gt;

&lt;p&gt;设状态为dp[i][j]，表示T[0, j]在S[0, i]里出现的次数。&lt;/p&gt;

&lt;p&gt;状态转移方程可以用一下公式来表达：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果 $$word1[i] == word2[j]$$，&lt;/p&gt;

&lt;p&gt;$$dp[i][j] = dp[i - 1][j - 1]$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 $word1[i] != word2[j]$,&lt;/p&gt;

&lt;p&gt;$$
  \begin{aligned}
 dp[i][j] &amp;amp; =  min ( &lt;br /&gt;
   &amp;amp; = dp[i - 1][j] + 1,(在word1中删除一个字符word1[i])   &lt;br /&gt;
   &amp;amp; = dp[i][j - 1] + 1,（在word1中插入一个字符word2[j]）   &lt;br /&gt;
   &amp;amp; = dp[i - 1][j - 1] + 1（替换word1[i] == word2[j]）    &lt;br /&gt;
   &amp;amp; )    &lt;br /&gt;
  \end{aligned}
$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://yutianx.info/2014/09/26/2014-09-26-leetcode-edit-distance/&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minDistance(string word1, string word2) {
        const int len1 = word1.size();
        const int len2 = word2.size();

        int dp[len1 + 1][len2 + 1];
        for (int i = 0; i &amp;lt;= len1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j &amp;lt;= len2; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i &amp;lt;= len1; i++) {
            for (int j = 1; j &amp;lt;= len2; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));  
                }
            }
        }
        return dp[len1][len2];
}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;interleaving-string&#34;&gt;Interleaving String&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true of false.
     */
    bool isInterleave(string s1, string s2, string s3) {
        // write your code here
        int len1 = s1.size(), len2 = s2.size(), len3 = s3.size();
        if (len1 + len2 != len3) return false;
        //代表s1前i个字符和s2前j个字符能否组成s3前i+j个字符

        bool dp[len1 + 1][len2 + 1];
        dp[0][0] = true;
        //初始化：s1前i个字符和s2前0个字符能否组成s3前i个字符？
        //只要能一一配对，即为true 否则为 false
        for (int i = 1; i &amp;lt; len1 + 1; ++i){
            dp[i][0] = (s3[i-1] == s1[i-1])? true : false;
        }

        for (int j = 1; j &amp;lt; len2 + 1; ++j){
            dp[0][j] = (s3[j-1] == s2[j-1])? true : false;
        }
        // 比较 s3 第i + j 个字符 和 s1第i个字符 或者 s2第j个字符
        for (int i = 1; i &amp;lt; len1 + 1; ++i){
            for (int j = 1; j &amp;lt; len2 + 1; ++j){
                if ((s3[i + j - 1] == s1[i - 1] &amp;amp;&amp;amp; dp[i - 1][j]) || (s3[i + j - 1] == s2[j - 1] &amp;amp;&amp;amp; dp[i][j - 1])){
                    dp[i][j] = true;
                }
                else{
                    dp[i][j] = false;
                }
            }
        }
        return dp[len1][len2];   
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;distinct-subsequences&#34;&gt;Distinct Subsequences&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    int numDistinct(string &amp;amp;S, string &amp;amp;T) {

        if (S.size() &amp;lt; T.size()) return 0;
        if (T.empty()) return 1;

        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(S.size() + 1, vector&amp;lt;int&amp;gt;(T.size() + 1, 0));

        int lenS = S.size();
        int lenT = T.size();

        for (int i = 0; i &amp;lt; S.size(); ++i) {
            dp[i][0] = 1;
            for (int j = 0; j &amp;lt; T.size(); ++j) {
                if (S[i] == T[j]) {
                    dp[i + 1][j + 1] = dp[i][j + 1] + dp[i][j];
                } else {
                    dp[i + 1][j + 1] = dp[i][j + 1];
                }
            }
        }

        return dp[S.size()][T.size()];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Matrix Dynamic Programming</title>
      <link>https://pineal.github.com/posts/matrix_dynamic_programming/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/matrix_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/unique-paths/&#34;&gt;Unique Paths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/minimum-path-sum/&#34;&gt;Min Path Sum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般这类问题都是给了一个m＊n的矩阵(或者三角形)，从一个方向走到另一个方向（从顶到底，或者从左上角到右下角 .etc），一般来说只会朝固定的方向走。&lt;/p&gt;

&lt;p&gt;初始化两条边，然后根据条件循环更新状态方程，主要看上一步的状态，最后得出结果。&lt;/p&gt;

&lt;h2 id=&#34;unique-paths&#34;&gt;Unique Paths&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n, m: positive integer (1 &amp;lt;= n ,m &amp;lt;= 100)
     * @return an integer
     */
    int uniquePaths(int m, int n) {
        // wirte your code here

    int dp[m][n];

        for (int i = 0; i &amp;lt; m; i++){
            dp[i][0] =  1;
        }

        for (int i = 0; i &amp;lt; n; i++){
            dp[0][i] =  1;
        }

        for (int i = 1;i &amp;lt; m; i++){
            for (int j = 1; j &amp;lt; n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;min-path-sum&#34;&gt;Min Path Sum&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param grid: a list of lists of integers.
     * @return: An integer, minimizes the sum of all numbers along its path
     */
    int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;grid) {
        // write your code here
        int m = grid.size(), n = grid[0].size();
        int sum[m][n];

        sum[0][0] = grid[0][0];

        for (int i = 1; i &amp;lt; m; i++){
            sum[i][0] =  sum[i-1][0] + grid[i][0];
        }

        for (int i = 1; i &amp;lt; n; i++){
            sum[0][i] =  sum[0][i-1] + grid[0][i];
        }

        for (int i = 1; i &amp;lt; m; i++){
            for (int j = 1 ; j &amp;lt; n; j++){
                sum[i][j] = min(sum[i-1][j], sum[i][j-1]) + grid[i][j];
            }
        }
        return sum[m-1][n-1];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sequence Dynamic Programming</title>
      <link>https://pineal.github.com/posts/sequence_dynamic_programming/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sequence_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/unique-paths/&#34;&gt;Climbing Stairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/house-robber/&#34;&gt;House Robber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/longest-increasing-subsequence/&#34;&gt;Longest Increasing Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/word-break/&#34;&gt;Word Break&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;climbing-stairs&#34;&gt;Climbing Stairs&lt;/h2&gt;

&lt;p&gt;状态转移方程，两种可能：要么是从i-1爬到i的，要么就是从i-2爬到i的，要计算所有可能的爬法之要把两者相加即可。所以维护一个数组来记录到i的爬法总数，那么:&lt;/p&gt;

&lt;p&gt;$$
f[i] = f[i-1] + f[i-2]
$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        // write your code here
        if (n &amp;lt;= 1){
            return 1;
        }

        vector&amp;lt;int&amp;gt; opt = {0, 1, 2};

        for (int i = 3; i &amp;lt;= n; i++){
            opt.emplace_back(opt[i-1] + opt[i-2]);
        }

        return opt[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;house-robber&#34;&gt;House Robber&lt;/h2&gt;

&lt;p&gt;这道题很像学校里上算法课的时候给的例题。最重要的是想清楚状态转移方程是怎么样的。常规的动归思路：维护一个相同大小的一维数组，因为是一个累积的过程，并且不能取邻近位置，那么在位置i的最优解只有两种可能：不取位置i上的值，那么这个最优值就跟i-1位置上的一样；或者取i上的值加上i-2上的最优值。比较这两者之间的大小即可。这类问题可以枚举初始状态，然后顺着这个思路写出状态转移方程。并且一般都是从头到尾的一次循环。&lt;/p&gt;

&lt;p&gt;$$
f[i] = max(f[i-1], f[i-2] + A[i])
$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
long long houseRobber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int len = nums.size();
    if (len == 0) return 0;
    if (len == 1) return nums[0];

    vector&amp;lt;long long&amp;gt; s = {nums[0], max(nums[0],nums[1])};

    for (int i=2;i&amp;lt;len;i++){
        s.emplace_back(max(s[i-1], s[i-2] + nums[i]));
    }

    return s[len-1];
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;longest-increasing-subsequence&#34;&gt;Longest Increasing Subsequence&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param nums: The integer array
     * @return: The length of LIS (longest increasing subsequence)
     */
    int longestIncreasingSubsequence(vector&amp;lt;int&amp;gt; nums) {
        // write your code here
        if (nums.empty()) return 0;

        vector&amp;lt;int&amp;gt; dp(nums.size(), 1);
        int rst = 0;

        for (int i = 1; i &amp;lt; nums.size(); i++){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if (nums[j] &amp;lt;= nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }                             
            }
            rst = max(rst, dp[i]);
        }
        return rst;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;word-break&#34;&gt;Word Break&lt;/h2&gt;

&lt;p&gt;在做了分割字符串II那道题之后，发现其实这两题一样一样的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;State: f[i] 表示前i个字符能否根据词典中的词被成功分词。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function: f[i] = or{f[j], j &amp;lt; i, letter in [j+1, i] can be found in dict}, 含义为小于i的索引j中只要有一个f[j]为真且j+1到i中组成的字符能在词典中找到时，f[i]即为真，否则为假。具体实现可分为自顶向下或者自底向上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Initialization: f[0] = true, 数组长度为字符串长度 + 1，便于处理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Answer: f[s.length]&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    bool wordBreak(string s, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {
        // write your code here
        if (s.empty()) return true;
        if (dict.empty()) return false;

        int len = s.size();
        int max_word_len = 0;

        for (unordered_set&amp;lt;string&amp;gt;::iterator it = dict.begin(); it != dict.end(); ++it) {
            int thisLen = (*it).size();
            max_word_len = max(max_word_len, thisLen);
        }

        deque&amp;lt;bool&amp;gt; canBreak(len + 1, false);
        canBreak[0] = true;

        for (int i = 1; i &amp;lt; len + 1; ++i){
            for (int j = i - 1; j &amp;gt;= 0; --j){

                if (i - j &amp;gt; max_word_len) break;


                if (canBreak[j] &amp;amp;&amp;amp; dict.find(s.substr(j, i - j))!= dict.end()){
                    canBreak[i] = true;
                    break;
                }   
            }
        }
    return canBreak[len];    
    }
};


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Optimal Control</title>
      <link>https://pineal.github.com/posts/optimal_control/</link>
      <pubDate>Sat, 26 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/optimal_control/</guid>
      <description>

&lt;h1 id=&#34;optimal-control&#34;&gt;Optimal Control&lt;/h1&gt;

&lt;h2 id=&#34;optimal-control-framework&#34;&gt;Optimal Control Framework&lt;/h2&gt;

&lt;p&gt;Given:
A controlled dynamical system：$ x^{n+1} = f(x^n, u^n)$&lt;/p&gt;

&lt;p&gt;A cost function：$V = \phi(x^N, \alpha) + \sum^{N-1}_{i=0}L(x^i, u^i, \alpha)$&lt;/p&gt;

&lt;p&gt;Goal: Find the sequence of commands that minimizes(maximizes) the cost function&lt;/p&gt;

&lt;h2 id=&#34;bellman-s-principle-of-optimality&#34;&gt;Bellman&amp;rsquo;s Principle of Optimality&lt;/h2&gt;

&lt;p&gt;Optimize it using dynamic programming:&lt;/p&gt;

&lt;p&gt;$$
J_i(X&lt;em&gt;i) = \mathop{arg min}&lt;/em&gt;{u_i\in u(x&lt;em&gt;i)}{{L(x^i, u^i, \alpha) + V^*&lt;/em&gt;{i+1}x_{(i+1)}}}
$$&lt;/p&gt;

&lt;h2 id=&#34;linear-quadratic-regulator&#34;&gt;Linear quadratic regulator&lt;/h2&gt;

&lt;p&gt;Special Assumption: Linear System Dynamics
 $$
  x^{n+1} = Ax^n + Bu^n
 $$&lt;/p&gt;

&lt;p&gt;Quadratic cost function
 $$
 L(x^i, u^i, \alpha) ＝ x^{i^T}Qx^i + u^{i^T}Ru^{i^T}
 $$&lt;/p&gt;

&lt;p&gt;Goal:
    - Bring the system to a setpoint and keep it there
    - Note: this an also be did with a nonlinear system by a local linearization&lt;/p&gt;

&lt;p&gt;$$
  \begin{aligned}
 V^&lt;em&gt;_i(X&lt;em&gt;i) &amp;amp; = \mathop{arg min}&lt;/em&gt;{u_i\in u(x_i)}{{L(x^i, u^i, \alpha) + V^&lt;/em&gt;&lt;em&gt;{i+1}x&lt;/em&gt;{(i+1)}}} &lt;br /&gt;
   &amp;amp; = \mathop{arg min}_{u_i\in u(x&lt;em&gt;i)}{{x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^*&lt;/em&gt;{i+1}x&lt;em&gt;{(i+1)}}} &lt;br /&gt;
   &amp;amp; = \mathop{arg min}&lt;/em&gt;{u_i\in u(x&lt;em&gt;i)}{{x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^*&lt;/em&gt;{i+1}(Ax^n + Bu^n)}} &lt;br /&gt;
  \end{aligned}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;As A linear control law expressed as:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
    u^{i^*} = -K^ix^i
$$&lt;/p&gt;

&lt;p&gt;Rewrite the optimal cost at stage i as a quadratic form:&lt;/p&gt;

&lt;p&gt;$$
    {V^i}^* = {x^i}^TP^ix^i
$$&lt;/p&gt;

&lt;p&gt;Thus,&lt;/p&gt;

&lt;p&gt;$$
   V^&lt;em&gt;_i(X&lt;em&gt;i) = \mathop{arg min}&lt;/em&gt;{u_i\in u(x_i)}{ {x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^&lt;/em&gt;_{i+1}(Ax^n + Bu^n)} } &lt;br /&gt;
$$&lt;/p&gt;

&lt;h2 id=&#34;finite-horizon-approximation&#34;&gt;Finite horizon approximation&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;motion-predictive-control&#34;&gt;Motion Predictive Control&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;fast-mpc&#34;&gt;Fast MPC&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://pineal.github.com/posts/binary_tree/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_tree/</guid>
      <description>

&lt;h2 id=&#34;definition-of-binary-tree&#34;&gt;Definition of Binary Tree&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Binary Tree
全部都填满的树。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Complete Binary Tree
除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Balanced Binary Tree
左右子树的高度最多差1. Height of the tree: $$O(log(n))$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary Search Tree
将二叉树按inorder方式遍历，是递增的。&lt;/p&gt;

&lt;h2 id=&#34;three-different-ways-to-traverse-a-binary-tree&#34;&gt;Three different ways to traverse a binary Tree&lt;/h2&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;DFS: 前序（pre-order, NLR）&lt;/li&gt;
&lt;li&gt;DFS: 中序（in-order, LNR）&lt;/li&gt;
&lt;li&gt;DFS: 后序（post-order, LRN）&lt;/li&gt;
&lt;li&gt;BFS: 层序（level-order）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traverse-binary-tree-example&#34;&gt;Traverse Binary Tree Example&lt;/h3&gt;

&lt;p&gt;[A:B, C]
[B:D]
[D:None]
[C:E,F]
[E:G,H]
[G:None]
[H:None]
[F:I]
[I:None]&lt;/p&gt;

&lt;p&gt;NLR: A B D C E G H F I&lt;/p&gt;

&lt;p&gt;LNR: D B A G E H C F I&lt;/p&gt;

&lt;p&gt;LRN: D B G H E I F C A&lt;/p&gt;

&lt;h2 id=&#34;template-for-dfs-traverse-using-recursion-nlr-and-lnr&#34;&gt;Template For DFS Traverse Using Recursion(NLR and LNR)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void helper(TreeNode* node, vector&amp;lt;int&amp;gt; &amp;amp; rst){
    if (node != nullptr){
//      rst.emplace_back(root -&amp;gt; val);  If it is PreOder
        helper(node -&amp;gt; left, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is InOrder
        helper(node -&amp;gt; right, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is PostOrder
    }
}
vector&amp;lt;int&amp;gt; DFS_Traversal(TreeNode* root) {
    // write your code here
    vector&amp;lt;int&amp;gt; rst;
    helper(root, rst);
    return rst;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;template-for-dfs-traverse-using-none-recursion-nlr-and-lnr&#34;&gt;Template For DFS Traverse Using None-Recursion(NLR and LNR)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; DFS_Traversal(TreeNode *root) {
    // write your code here
    vector&amp;lt;int&amp;gt; rst;
    if (root == nullptr) return rst;
    stack&amp;lt;TreeNode*&amp;gt; s;

    while (!s.empty() || root != nullptr){
        if (root != nullptr){
//          rst.emplace_back(root -&amp;gt; val);  If Pre-Order
            s.push(root);
            root = root -&amp;gt; left;
        }
        else{
            root = s.top();
            s.pop();
//          rst.emplace_back(root -&amp;gt; val);  If In-Order
            root = root -&amp;gt; right;
        }            
    }
return rst;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;template-for-dfs-traverse-using-none-recursion-lrn&#34;&gt;Template For DFS Traverse Using None-Recursion(LRN)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def DFS_Stack_LRN(root):
  s = []
  pre = None
  while root or s:
    if root:
      s.append(root)
      root = root.left
    elif s[-1].right != pre:
      root = s[-1].right
      pre = None
    else:
      pre = s.pop()
      print(pre.val)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;template-for-bfs-traverse-using-1-queue-best&#34;&gt;Template For BFS Traverse Using 1 Queue(Best)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode *root) {
    // write your code here
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    if (root == nullptr) return rst;

    queue&amp;lt;TreeNode*&amp;gt; nodes;
    nodes.push(root);

    while(!nodes.empty()){
        vector&amp;lt;int&amp;gt; level;
        int size = nodes.size();
        for (int i = 0; i &amp;lt; size; i++){
            TreeNode* node = nodes.front();
            nodes.pop();
            level.emplace_back(node -&amp;gt; val);
            if (node -&amp;gt; left != nullptr) nodes.push(node -&amp;gt; left);
            if (node -&amp;gt; right != nullptr) nodes.push(node -&amp;gt; right);    
        }
        rst.emplace_back(level);
    }
return rst;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;morris-traverse&#34;&gt;?Morris Traverse?&lt;/h2&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;difference-of-dfs-and-bfs&#34;&gt;Difference of DFS and BFS&lt;/h3&gt;

&lt;p&gt;DFS using stacks, and BFS using queues if Non-Recursion&lt;/p&gt;

&lt;h3 id=&#34;difference-of-recursion-and-non-recursion&#34;&gt;Difference of Recursion and Non-Recursion&lt;/h3&gt;

&lt;p&gt;Recursion is dangerous when memory resource is limited: stack may overflow;
However Non-Recursion method occupies more space&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://pineal.github.com/posts/binary_search/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_search/</guid>
      <description>

&lt;h2 id=&#34;经典二分搜索及其变种&#34;&gt;经典二分搜索及其变种&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int classic_binary_search(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty()) {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt;= right){
      int mid = left + (right - left)/2;
      if (input[mid] == target){
        return mid;
      }
      else if (input[mid] &amp;lt; target) {
        left = mid + 1;
      }
      else {
        right = mid - 1;
      }
    }
    return -1;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_first_index(vector&amp;lt;int&amp;gt; input, int target) {
    // Write your solution here
    if (input.size() == 0) return -1;
    int left = 0, right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt; input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[left] == target){
      return left;
    }
    else if (input[right] == target) {
      return right;
    }
    else
      return -1;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_last_index(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty())  {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt;= input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[right] == target) {
      return right;
    }
    else if (input[left] == target) {
      return left;
    }
    else {
      return -1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二维二分搜索&#34;&gt;二维二分搜索&lt;/h2&gt;

&lt;h3 id=&#34;search-a-2d-matrix-https-leetcode-com-problems-search-a-2d-matrix&#34;&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix/&#34;&gt;Search a 2D Matrix&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;从左到右递增，下一行的开头一定比上一行的末尾大。那么就可以转化为一维的二分搜索。考点在二维矩阵到一维矩阵的变换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
  int left = 0;
  int right = matrix.size() * matrix[0].size() - 1;
  while (left &amp;lt;= right) {
    int mid = left + (right - left) / 2;
    int i = mid / matrix[0].size();
    int j = mid % matrix[0].size();
    if (matrix[i][j] == target) {
      return true;
    } else if (target &amp;gt; matrix[i][j]) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;search-a-2d-matrix-ii-https-leetcode-com-problems-search-a-2d-matrix-ii&#34;&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix-ii/&#34;&gt;Search a 2D matrix II&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;从左往右一定递增，从上到下一定递增。跟之前一题相比，这里的二维矩阵并不能保证转化成一维递增的矩阵。
如果从左上角开始往右下角搜索，那么有多种可能，刚开始用的是分治法，把矩阵分成四块，由于这个矩形的性质，我们只能排除掉一块，然后往三块可能的继续搜。时间复杂度为$O(n^{1.58})$, 参考分治法时间复杂度分析公式.
但如果从右上角往左下角搜，那么可以保证向左一定是递减的，向下一定是递增的，那么可以排除掉特定行或者特定列。这样的时间复杂度出来的是$O(m + n)$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
	int m = matrix.size();
	if (m == 0) return false;
	int n = matrix[0].size();
	int i = 0, j = n - 1;
	while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;gt;= 0) {
		if (matrix[i][j] == target)
			return true;
		else if (matrix[i][j] &amp;gt; target) {
			j--;
		} else
			i++;
	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Kalman Filter</title>
      <link>https://pineal.github.com/posts/kalman_filter/</link>
      <pubDate>Tue, 24 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;purpose-and-usage&#34;&gt;Purpose and Usage&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Eliminate noise in measurements&lt;/li&gt;
&lt;li&gt;Generate non-observable states(e.g., Velocity from position signals)&lt;/li&gt;
&lt;li&gt;For prediction of future state&lt;/li&gt;
&lt;li&gt;Optimal filtering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;framework-and-model&#34;&gt;Framework and Model&lt;/h2&gt;

&lt;h3 id=&#34;given&#34;&gt;Given:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A discrete stochastic linear controlled dynamical system:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1}$$&lt;/p&gt;

&lt;p&gt;Each current signal value $x^k$ is a combination of previous signal value $x_{k-1}$ times a constant, a control signal $u_{k}$ and a process noise and a process noise signal $w_{k-1}$ (which usually considered as zero).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A measurement function, where $v_{k}$ is the measurement noise.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$ y_{k} = Hx_{k} + v_{k} $$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Assume the process noise and the measurement noise are both considered to be normal distribution that&lt;/p&gt;

&lt;p&gt;$$ p(w) \sim N (0, Q), $$&lt;/p&gt;

&lt;p&gt;$$ p(v) \sim N (0, R). $$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In reality, covariance matrix $Q$ and $R$ may change in every iteration. We assume they are constant here however.&lt;/p&gt;

&lt;h3 id=&#34;goal&#34;&gt;Goal:&lt;/h3&gt;

&lt;p&gt;Find the best (recursive) estimate of the state $x$ of the system.&lt;/p&gt;

&lt;h3 id=&#34;computational-origins&#34;&gt;Computational Origins&lt;/h3&gt;

&lt;p&gt;Define $e_{k}^{-}$ to be a priori state estimate at step k given knowledge of the process prior to step $k$, and define $e_{k}$  to be a posteriori state estimate at step $k$ given measurement $z_{k}$. Then a priori and a posteriori estimate errors can be defined as:&lt;/p&gt;

&lt;p&gt;$$e_{k}^{-} \equiv x_{k} - \hat{x}_{k}^{-}$$&lt;/p&gt;

&lt;p&gt;$$e_{k} \equiv x_{k} - \hat{x}_{k}$$&lt;/p&gt;

&lt;p&gt;The a priori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k}^{-} = E[e_{k}^{-}e_{k}^{-T}]$$&lt;/p&gt;

&lt;p&gt;The a posteriori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k} = E[e_{k}e_{k}^{T}]$$&lt;/p&gt;

&lt;p&gt;Then How can we optimally (linearly) combine the estimate and measurement to obtain the best reconstruction of ￼the true x?&lt;/p&gt;

&lt;p&gt;The answer given in “The Probabilistic Origins of the Filter” found.&lt;/p&gt;

&lt;p&gt;$$
   \hat{x} = \hat{x}_{k}^{-} - K \times residual
$$&lt;/p&gt;

&lt;p&gt;Where &lt;em&gt;residual&lt;/em&gt; is $z_k - H \hat{x}_{k}^{-}$. It also can be called as measurement innovation.&lt;/p&gt;

&lt;p&gt;The Kalman filter gains are derived by minimizing the posterior error covariance, resulting in&lt;/p&gt;

&lt;p&gt;$$K_k = \frac{P_k^-H^T}{(HP_k^-H^T + R)^{-1}}$$&lt;/p&gt;

&lt;p&gt;If the a priori estimate of the process noise is zero, Then&lt;/p&gt;

&lt;p&gt;$$K = 0$$&lt;/p&gt;

&lt;p&gt;If the measurement noise is zero&lt;/p&gt;

&lt;p&gt;$$K = H^{-1}$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linear Programming</title>
      <link>https://pineal.github.com/posts/linear_programming/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/linear_programming/</guid>
      <description>&lt;p&gt;$$\matrix{A} \times \matrix{X} = \matrix{B}  $$&lt;/p&gt;

&lt;p&gt;Coeffienent matrix&lt;/p&gt;

&lt;p&gt;A =&amp;gt; n * n, x vector of unknowns, B right hand side&lt;/p&gt;

&lt;p&gt;Linear system of equations.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;$$A \times X ≥ B$$&lt;/p&gt;

&lt;p&gt;Objective function&lt;/p&gt;

&lt;p&gt;$$C^T \times X $$&lt;/p&gt;

&lt;p&gt;linear&lt;/p&gt;

&lt;p&gt;Goal : Minimize the objective function&lt;/p&gt;

&lt;p&gt;E.g.:
$$
\cases{x1 - x2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x1 + x2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;Maximize
$x1 + 2x_2$&lt;/p&gt;

&lt;p&gt;###Simplex method
Only look at the vertex&lt;/p&gt;

&lt;p&gt;Start of one vertex, go clockwise, find the max before the value going down&lt;/p&gt;

&lt;p&gt;###Weighted vertex cover problem&lt;/p&gt;

&lt;p&gt;for G = (V, E), S $\in$ V in a set such that each edge has at least one end in S $W_i ≥ 0$ for each i $\in$ V $$W(S) = \sum i \in S w_i$$&lt;/p&gt;

&lt;p&gt;Objective: Minimize W(S)&lt;/p&gt;

&lt;p&gt;Model this as an LP&lt;/p&gt;

&lt;p&gt;x_i is a decision valuable for each node i \in V&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_1 - x_2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x_1 + x_2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_i = 0 &amp;amp; i \notin S \&lt;br /&gt;
x_i = 1 &amp;amp; i \in S
}
$$&lt;/p&gt;

&lt;p&gt;x_i + x_j ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;Minimize \sigma w_ix_i
Subject to
$x_i + x_j ≥ 1 for (i, j) \in E$
$x_i \in {0,1} for i \in V$  &amp;lt;= discreate&lt;/p&gt;

&lt;p&gt;Integer Programming&lt;/p&gt;

&lt;p&gt;Linear programming  (continues variables)
Integer Programming (discrete variables)
mixed integer programming&lt;/p&gt;

&lt;p&gt;Drop the requirement that x_i \in {0,1}
and solve the LP in poly time and find {x_i^*} between 0 and 1&lt;/p&gt;

&lt;p&gt;so that x_i^* + x_j^* ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;W_{LP} = \sigma w_ix_i^*&lt;/p&gt;

&lt;p&gt;S^* is the opt vertex cover set
W(S^*) = weight of the opt solution&lt;/p&gt;

&lt;p&gt;W(S^*) ≥ W_{LP}&lt;/p&gt;

&lt;p&gt;S is our approx. solution&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W&lt;em&gt;{LP}
W&lt;/em&gt;{LP} ≤ 2 * W(s^*)&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W(S^*)&lt;/p&gt;

&lt;p&gt;Solve the max. flow problem using LP. Variable are flow over edges.&lt;/p&gt;

&lt;p&gt;Maximize \sigma f{e}
subject to
0 ≤ f(e) ≤ c_e foe each edge e \in E
\sigma f(e) - \sigma f(e) = 0 for v \in V&lt;/p&gt;

&lt;p&gt;A = B
A - B ≥ 0
B - A ≥ 0&lt;/p&gt;

&lt;p&gt;Max flow with lower bounds on flow over the edges
objective function stays same
conservation of the flow stays same&lt;/p&gt;

&lt;p&gt;Cap constraint: l_e≤f(e)≤c_e for each edge e \in E&lt;/p&gt;

&lt;p&gt;###Multi commodity flow
f_i(e): flow of commodity i over edge e
\alpha_i: is the profit associated with one unit of flow for commodity i.&lt;/p&gt;

&lt;p&gt;We have m commodities&lt;/p&gt;

&lt;p&gt;Objective: maximize profit&lt;/p&gt;

&lt;p&gt;Maximize $\sigma&lt;em&gt;{l=i}^m \sigma&lt;/em&gt;{eoutofS} \alpha_i f_i(e)$&lt;/p&gt;

&lt;p&gt;subject to 0 ≤ \sigma_{i=1}^m f&lt;em&gt;i{e} ≤c&lt;/em&gt;{e} for each e \in E&lt;/p&gt;

&lt;p&gt;\sigma_{i=1}^m f&lt;em&gt;i{e} = \sigma&lt;/em&gt;{i=1}^m f_i{e} for each node v \in V and for each i = 1 to m&lt;/p&gt;

&lt;p&gt;###Shortest path using LP
Shortest distance from V to t is d(v) for each node V
For each node V
$$
d(t) ≤ d(y) + c&lt;em&gt;{yt} \&lt;br /&gt;
d(t) ≤ d(w) + c&lt;/em&gt;{wt} \&lt;br /&gt;
d(t) ≤ d(x) + c_{xt} \&lt;br /&gt;
$$&lt;/p&gt;

&lt;p&gt;d&lt;em&gt;{v} ≤ d&lt;/em&gt;{u} + w(u, v) for each edge (u, v) \in E
d(s) = 0&lt;/p&gt;

&lt;p&gt;Objective function:
    Minimize d(t)&lt;/p&gt;

&lt;p&gt;1:36&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>海底捞</title>
      <link>https://pineal.github.com/posts/%E6%B5%B7%E5%BA%95%E6%8D%9E/</link>
      <pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E6%B5%B7%E5%BA%95%E6%8D%9E/</guid>
      <description>&lt;p&gt;昨晚梦到了自己从纽约秋日的街头穿越回1993年的冰岛，&lt;br/&gt;
只是通过一本神秘的皮革封面的似乎无尽的书。&lt;br/&gt;
在天然冰镇伏特加的陪伴下享受如舞池灯般的极光。&lt;br/&gt;
我觉得变换的速度有点应接不暇，于是来到奥斯陆的一艘潜艇中。&lt;br/&gt;
忽的进入了战地模式。可是炮弹又怎能在海底炸出土来。&lt;br/&gt;
最后竟然在写字楼里签收你寄过来的的大件快递，这么多年。&lt;br/&gt;
我把挂在墙上的地图pin上自己的足迹，&lt;br/&gt;
醒来后我惊异的发现自己对北欧的地理分布怎么能如此熟悉。&lt;br/&gt;
至于是否忘记了从包裹里取出东西，是不是根本不重要，&lt;br/&gt;
也许因为我的手一直枕在你的脖子下。&lt;br/&gt;
这样的梦，也应该就是为何荒芜的 Greenland 听起来生意盎然， &lt;br/&gt;
而可爱的 Iceland 却让人望而却步的缘由。&lt;br/&gt;
想想连名字都这么童话的地方，冰岛。&lt;br/&gt;
难怪有人一定要跟自己爱的人一起去共同度过。&lt;br/&gt;
凛冬将至，群鸦争渡。对了，那本让我穿越的书应该是博尔赫斯写的书里的书，&lt;br/&gt;
即使手感跟我爱罗不太一样，这场景也改切换到神秘而荒诞的南美了吧。&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NP problem</title>
      <link>https://pineal.github.com/posts/np_problem/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/np_problem/</guid>
      <description>&lt;p&gt;##Introduction&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Plan&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Explore the space of computationally hand problem to arrive at a mathematic characteristic a large d of them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Technique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Compare negative difficultly of different problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Problems can find a polynomial time algorithm to solve.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NP problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;An algorithm that can be verified if it is a solution to a problem or not in polynomial time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loose definition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If problem X in at least as hard as problem Y. It means that if we could solve X, we could also solve Y.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Y X&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Y is polynomial time reduced to X. If Y can be solved using a poly number of std computational steps plus a poly no of called to a black box to love X.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If X can be solved in polynomial time, then Y can be solved in polynomial time.&lt;/li&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If Y cannot be solved in polynomial time, then X cannot be solved in polynomial time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NP-Complete Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is NPC problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prove it is a NP problem.&lt;/li&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;NP hard Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is hard problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##Examples&lt;/p&gt;

&lt;p&gt;###Independent Set
Ref: Given a graph $G = (V,E)$, we say a set of nodes, $S \in V$ in independent if no two nodes in S and joined by an edge.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the maximum size independent set in graph G.(Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G and a number k, does G contain an independent set of size at least K.(Decision version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ans: No solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Vertex Cover
Ref: Given a $graph G=(V,E)$ we say that a set of nodes $S \in V$ in a vertex cover if every edge $e \in E$ has at least one end in S.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the smallest vertex cover set in G (Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G=(V,E) and a number k, G contain a vertex cover of size at most k.(Decision version)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Independent Set and Vertex Cover&lt;/p&gt;

&lt;p&gt;FACT: let G=(V,E) be a graph then S in an independent set if and only if its complement (V-S) is a vertex cover.&lt;/p&gt;

&lt;p&gt;S is an independent set.&lt;/p&gt;

&lt;p&gt;**case 1 **&lt;/p&gt;

&lt;p&gt;U is in S and V is not.
V-S will have V and not U.&lt;/p&gt;

&lt;p&gt;case 2
V is in S and U is not.
V-S will have U and not V&lt;/p&gt;

&lt;p&gt;case 3
Neither V or U are in the set&lt;/p&gt;

&lt;p&gt;Suppose V-S is a vertex cover can prove that S is an independent set.&lt;/p&gt;

&lt;p&gt;Claim: independent Set≤P vertex Cover
Prove If we have a black box to solve the vertex cover problem. We can decide if G has independent set of size at least k by asking the black box if G has a vertex cover of size at most n-k.&lt;/p&gt;

&lt;p&gt;Claim: Vertex cover ≤S independent Set&lt;/p&gt;

&lt;p&gt;Proof: if we have a black box to solve the independent set we can deicide if G has a vertex cover of size at most k by asking the black box if G has an independent set of size at least n-k.&lt;/p&gt;

&lt;p&gt;Set cover problem
Given a set U of n elements, a collection s_1 to s_m of sub sets of U and and a number of k, does there exist a collection of at most k of these sets whose union is equal to all of U.&lt;/p&gt;

&lt;p&gt;Set U = set of all edges in G
S1 = {(1, 2), (1,3)}
S2 = {(1,2), (2,3), (2,4), (2,5)}&lt;/p&gt;

&lt;p&gt;Proof of correction:
A) If we have a vertex cover of size k in G, then i can find a collection of k sets whose union is equal to all of U.
B) If I have a collection of k sets, whose union is equal to all of U, then I can find a vertex cover of size k in G.&lt;/p&gt;

&lt;p&gt;Given u bolean variable x1&amp;hellip;xn a&lt;/p&gt;

&lt;p&gt;a truth assignment fox X is an assignment of values 0 or 1 to each x_i&lt;/p&gt;

&lt;p&gt;An assignment satisfies a change C if it causes C to evaluate 1.&lt;/p&gt;

&lt;p&gt;An assignment satisfies a collection of if C1 and C2 and &amp;hellip; CK evaluate to 1.&lt;/p&gt;

&lt;p&gt;Given a set of closures C1 to Ck over a set of variables x - {x1, &amp;hellip; xn} does there exist a satisfying truth&lt;/p&gt;

&lt;p&gt;Problem statement
Given a set of&lt;/p&gt;

&lt;p&gt;Three set problem
Given an&lt;/p&gt;

&lt;p&gt;C1 = (x1, x2, x3)&lt;/p&gt;

&lt;p&gt;Efficient Certification&lt;/p&gt;

&lt;p&gt;ex: indenpendent set problem.
certificate is a set of nodes of size at least k.
certifier: go over every edge and check the if they are not both in S the edge is OK.
check the size of set S.&lt;/p&gt;

&lt;p&gt;Evaluate each clause&lt;/p&gt;

&lt;p&gt;If X \in NP and for all Y \in NP&lt;/p&gt;

&lt;p&gt;Is there a problem in NP that all other problem in NP can be reduced to it in polynomial time&lt;/p&gt;

&lt;p&gt;Basic strategy to probe a problem X is NP-complete
1.prove X \in nP
2.choose a problem Y that is known to be NP-complete
3.Prove that Y≤pX&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>22</title>
      <link>https://pineal.github.com/posts/22/</link>
      <pubDate>Sun, 14 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/22/</guid>
      <description>&lt;p&gt;给我两杯冰冻的鲜啤吧，我就会是个满脸胡渣的诗人。&lt;/p&gt;

&lt;p&gt;做一个市井小民吧，坐在皇城脚下，干爽的微风傍晚。&lt;/p&gt;

&lt;p&gt;一起来撸个串吧，Windows 98 的年代转眼已经 Windows 8。&lt;/p&gt;

&lt;p&gt;忘了吹着江风的童年吧，那里没有属于你的玩具。&lt;/p&gt;

&lt;p&gt;想念大不列颠了吧，夏日的夜晚虽然短暂可星空却是那么性感。&lt;/p&gt;

&lt;p&gt;告别你的青春吧，二十二年的电影也不算太长。&lt;/p&gt;

&lt;p&gt;爱着那个姑娘吧，故宫的护城河边的初升的太阳，哦，再来一碗炸酱面。&lt;/p&gt;

&lt;p&gt;还有你的梦想吧，是什么还能让你远走高飞头也不回。&lt;/p&gt;

&lt;p&gt;一起去炸了国家工商总局吧，还有那个颐指气使的方形脸庞画着细眉毛瞪着大眼睛翘着薄嘴唇的像教导主任一样的中国女人。&lt;/p&gt;

&lt;p&gt;你累了吧，你离开吧，做一个良心未泯的，入世的人吧。&lt;/p&gt;

&lt;p&gt;我怀念的，是双熊猫皱纹卫生纸。皱巴巴的还可以是一张五元纸钞，塞进自动售货机，能吐出两听可口可乐，可口可乐包装的那个红色，我一直很想知道它的颜色代码。&lt;/p&gt;

&lt;p&gt;就是这个神奇的感觉。一切都是潮的：地是潮的，空气是潮的，书页是潮的，黄油饼干是潮的，换下的衬衫是潮的，就连耳机线和音乐都不如落地签那么清澈透亮。&lt;/p&gt;

&lt;p&gt;所有看的看不见的都黏糊糊的纠缠在了一起。现在，我最想要的是一听雪碧，喷薄而出的气泡，大口畅饮时喉结的蠕动，以及金属变形和打嗝的快感。&lt;/p&gt;

&lt;p&gt;吃下了同样来自利物浦的帅哥给的糖。波音777上一片漆黑什么都看不见，包装上可辨的只有discount40%， 怀疑糖上粘着纸，吃完后满嘴茴香的味道。&lt;/p&gt;

&lt;p&gt;仿佛如同一场梦，我们如此短暂地相逢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>送我一颗菠菜</title>
      <link>https://pineal.github.com/posts/%E9%80%81%E6%88%91%E4%B8%80%E9%A2%97%E8%8F%A0%E8%8F%9C/</link>
      <pubDate>Fri, 26 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E9%80%81%E6%88%91%E4%B8%80%E9%A2%97%E8%8F%A0%E8%8F%9C/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s slip into dreams.——甜如菠菜。&lt;/p&gt;

&lt;p&gt;蒸锅一定是这个世界上最伟大的发明之一。相对于蒸汽机对人类文明的贡献或者毁灭，拥有同样原理的技术却能将味蕾一一摆平还能使享受热腾腾氤氲的每一个皮肤细胞的呼吸作用治理的服服帖帖。 英国人的智商绝不容易将这种天才的技术应用在生活中——他们的局限就在于仅仅贡献了瓦特——这种脑子瓦特的民族的奇怪食物怎么能跟三文鱼沙拉三明治和火腿肠起司面包相媲美。自然，一个烤箱就能解决的世界使得蒸锅的必要性无限趋近于零。英国人更不可能学会炒菜这种更加高级的技能——似乎只有集齐七颗龙珠召唤神龙才有这个可能了——原因在于他们习惯了满嘴sorry和cheers跑出时速被前铁道部完爆的蒸汽式火车，所以怎么可能用炒的嘛。综上所述，黑暗料理界一定会败给中华小当家。我蹑手蹑脚的从锅中取出黄金开口暗戳戳笑：哦，菠菜，只要你蒸蒸切切爱我一遍。&lt;/p&gt;

&lt;p&gt;皮尔洛这厮竟然说：“自轮子之后，人类历史最伟大的发明就是PlayStation”。他和内斯塔一起选巴萨当主队踢实况就跟阿莱格里逼他去尤文留大胡子一样不靠谱。巴塞罗那狂热症可是是有缘由的。除开拉玛西亚影剧院来说，For instance: 西班牙语的音乐是如此的动听，性感的大小舌颤音让人浑身鸡皮疙瘩止不住的颤抖。且不说C罗的最爱Ai Se Eu Te Pego!，你想，在国内公交车上功放爱情买卖的时候，在酒吧门口共舞江南Style的时候，在韩寒把万青听众打入深渊的时候，来一曲Siempre Me Quedará在iphone非主流简约播放器in:play上播放这种事能让逼格瞬间爆棚几倍——直接从绿色的菠菜叶爆到绛红色的菜根，剩余能量还能生出几根诱人的小须须。对了，我也爱田纳西恰恰。&lt;/p&gt;

&lt;p&gt;至于菠菜，&amp;rdquo;菠这种字眼不是那种充满野性的丰满人类专用的么?&amp;ldquo;, 那一个神奇的铁罐中蕴含着来自伊朗高原的高能蔬菜—— 如果最近几周的情况用多巴胺含量来解释的话，一切是那么的通情达理又不失文艺清新范儿。我又对自己完美的借口再一次的感到满意。人总是在不断虚伪的过程中逐渐把平庸的筹码逐渐花光。你说&amp;rdquo;Time Flies, But You are the Piolet.&amp;rdquo; 怎知时光未死，你却已蹒跚老去。不禁思考，能认识到God Complex这种命题本身是否陷入了虚无主义的圈套。“It&amp;rsquo;s too hard to make good mistakes. ”一切总是矛盾的，你想把博文理得逻辑上无懈可击，就会失去意识流般的丝滑柔顺（你又不是德芙巧克力）；你想要努力征服全世界，却发现连自己都无法击败（你又不是鸿星尔克）；你对佳人钦慕不已，炙热如焰却不能悲伤的坐在你身旁（你又不是左小祖咒），你的冷漠却又能被称赞为人奉为圭臬的男人的成熟（你连自己都不是了）——等到菠菜都熟透，一起去看细水长流？也许一切都会是好的，一个三脚猫的工科生却有着蹩脚的文艺情怀——如果哪一天突然发现自己站在了人文和科技的十字路口也无需太过惊讶：我一定会在老乔的墓碑前摆个剪刀手合影留念。&lt;/p&gt;

&lt;p&gt;送你一颗子弹，送我一颗菠菜。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>