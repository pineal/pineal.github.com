<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on PINEAL.ME</title>
    <link>https://pineal.github.com/posts/</link>
    <description>Recent content in Posts on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Apr 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Topics on Gragh Algorithm</title>
      <link>https://pineal.github.com/posts/graph_algorithms/</link>
      <pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/graph_algorithms/</guid>
      <description>

&lt;h1 id=&#34;graph&#34;&gt;Graph&lt;/h1&gt;

&lt;h2 id=&#34;graph-representing&#34;&gt;Graph Representing&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-and-its-representations/&#34;&gt;https://www.geeksforgeeks.org/graph-and-its-representations/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs&#34;&gt;https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;adjacent-matrix&#34;&gt;Adjacent Matrix&lt;/h3&gt;

&lt;h3 id=&#34;adjacent-list&#34;&gt;Adjacent List&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/&#34;&gt;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/&#34;&gt;https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;edges&#34;&gt;Edges&lt;/h3&gt;

&lt;h2 id=&#34;traversal&#34;&gt;Traversal&lt;/h2&gt;

&lt;h3 id=&#34;bfs&#34;&gt;BFS&lt;/h3&gt;

&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Pacific Atlantic Water Flow&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;start from matrix&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;start from occean&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone Graph
follow up: reverse if DAG&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;topological-sorting&#34;&gt;Topological Sorting&lt;/h2&gt;

&lt;h3 id=&#34;dfs-method&#34;&gt;DFS method&lt;/h3&gt;

&lt;p&gt;拓扑排序的常规方法是用DFS。DFS 有一个好处就是可以 backtracking 到所有的 solution。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/topological-sorting/&#34;&gt;https://www.geeksforgeeks.org/topological-sorting/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bfs-1&#34;&gt;BFS&lt;/h3&gt;

&lt;p&gt;另一个方法 Kahn’s algorithm 用记录入度/出度的方式进行BFS, 相对容易记忆和实现&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/&#34;&gt;https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;More questions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule&#34;&gt;Course Schedule&lt;/a&gt; | &lt;a href=&#34;https://github.com/pineal/Leetcode_OJ/blob/master/cpp/207_Course_Schedule.cpp&#34;&gt;Solution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule-ii&#34;&gt;Course Schedule II&lt;/a&gt; | &lt;a href=&#34;https://github.com/pineal/Leetcode_OJ/blob/master/cpp/210_Course_Schedule_II.cpp&#34;&gt;Solution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/sequence-reconstruction&#34;&gt;Sequence Reconstruction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-increasing-path-in-a-matrix&#34;&gt;Longest Increasing Path in a Matrix&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/alien-dictionary&#34;&gt;Alien Dictionary&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/&#34;&gt;All Topological sorts of a DAG&lt;/a&gt; | should use DFS&lt;/p&gt;

&lt;h2 id=&#34;connected-component&#34;&gt;Connected Component&lt;/h2&gt;

&lt;h3 id=&#34;connected-components-for-undirected-graph&#34;&gt;Connected components for undirected graph&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/&#34;&gt;Number of Connected Components&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;strongly-connected-components&#34;&gt;Strongly Connected Components&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/strongly-connected-components/&#34;&gt;https://www.geeksforgeeks.org/strongly-connected-components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/&#34;&gt;https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/connectivity-in-a-directed-graph/&#34;&gt;https://www.geeksforgeeks.org/connectivity-in-a-directed-graph/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;shortest-path&#34;&gt;Shortest Path&lt;/h2&gt;

&lt;h3 id=&#34;shortest-distance-in-adjacent-table-bfs&#34;&gt;Shortest distance in adjacent table - BFS&lt;/h3&gt;

&lt;p&gt;Best Meeting Point&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/shortest-distance-from-all-buildings/description/&#34;&gt;Shortest Distance from All Buildings&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;dijkstra&#34;&gt;Dijkstra&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&#34;&gt;https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&#34;&gt;https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-star&#34;&gt;A star&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&#34;&gt;https://github.com/pineal/-O_O-/blob/master/A_Star_Search/A_Star_Search.cpp&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;iterative-deepening-search-ids-or-iterative-deepening-depth-first-search-iddfs&#34;&gt;Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/&#34;&gt;https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;bipartite&#34;&gt;Bipartite&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/is-graph-bipartite&#34;&gt;Is Graph Bipartite&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Basic Backtracking Problems</title>
      <link>https://pineal.github.com/posts/backtracking/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/backtracking/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Backtracking 类型的题目最重要的是想清楚每一层在做什么，以及到下一层一共有几个分叉。&lt;/p&gt;

&lt;p&gt;时间复杂度： branch factor ^ level&lt;/p&gt;

&lt;p&gt;时间复杂度： call stack -&amp;gt; level&lt;/p&gt;

&lt;h2 id=&#34;subsets&#34;&gt;Subsets&lt;/h2&gt;

&lt;p&gt;这一类的题目的框架为，在递归树中的第 i 层，代表正在处理 nums 里的第 i 个元素。 从该层的父节点一定会伸展出两个分叉： 第一个分叉代表着一层会放这个元素，第二个分叉代表不放这个元素。 这样出来的递归树非常平衡。&lt;/p&gt;

&lt;h3 id=&#34;subsets-i-http-www-lintcode-com-en-problem-subsets&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        sort(nums.begin(), nums.end());
        vector&amp;lt;int&amp;gt; cur;
        dfs(rst, cur, nums, 0);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; rst, vector&amp;lt;int&amp;gt; &amp;amp; cur, const vector&amp;lt;int&amp;gt;&amp;amp; nums, int level) {
        if (level == nums.size()) {
            rst.emplace_back(cur);
            return;
        }
        cur.emplace_back(nums[level]);
        dfs(rst, cur, nums, level + 1);
        cur.pop_back();
        dfs(rst, cur, nums, level + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subsets-ii-dedup-http-www-lintcode-com-en-problem-subsets-ii&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II - Dedup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;去重首先需要排序，要利用有序性。从递归树上看的话，放的那一个分支不变，因为我们是先做放元素，再走不放该元素的。如果不放该元素，那么此时的结果会跟父节点的是重复的。ab1 -&amp;gt; ab1b2, ab1。  a -&amp;gt; ab2, a。 ab1 和 ab2 不能同时出现。 所以这个分支就需要直接跳到跟当前层元素不同的那一层。在代码上体现就是level++。&lt;/p&gt;

&lt;p&gt;ab1 ab2 出发产生的分支都是完全一样的。那么我们可以去掉ab2。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; cur;
        sort(nums.begin(), nums.end());
        dfs(rst, nums, 0, cur);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; result, vector&amp;lt;int&amp;gt; &amp;amp; nums, int level, vector&amp;lt;int&amp;gt; &amp;amp; cur) {
        if (level == nums.size()) {
            result.emplace_back(cur);
            return;
        }
        
        cur.emplace_back(nums[level]);
        dfs(result, nums, level + 1, cur);
        cur.pop_back();
        //pruning techniques
        while (level &amp;lt; nums.size() - 1 &amp;amp;&amp;amp; nums[level] == nums[level+1]) {
            level++;
        }                
        dfs(result, nums, level + 1, cur);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variant-i-combination&#34;&gt;Variant I - Combination&lt;/h3&gt;

&lt;p&gt;整体框架跟 Subset I 一模一样， 唯一的区别是 base case return 的时候加上条件： 当前结果的长度为 k 才返回。
原题链接：&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;去重的方法也应该和 Subset II 一样。&lt;/p&gt;

&lt;h3 id=&#34;variant-ii-permutations-of-inserting-spaces-into-a-string&#34;&gt;Variant II - Permutations of inserting spaces into a string&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&#34;&gt;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还有别的问法，比如如何分一个给定的数组成两部分，两部分的和相同。或者要在一串数组/字符串里面插入。&lt;/li&gt;
&lt;li&gt;时间复杂度是$O(2^n)$&lt;/li&gt;
&lt;li&gt;另一种常见做法：k层，每层的意义为最后的结果钟第几个元素应该是什么。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;permutations&#34;&gt;Permutations&lt;/h2&gt;

&lt;p&gt;因为全排列需要全部元素都出现，唯一不同的是他们的顺序，那么我们可以不停两两交换数组中的元素，得到全排列。&lt;/p&gt;

&lt;p&gt;Time n * (n-1) * (n - 2) = O(n!)&lt;/p&gt;

&lt;p&gt;Space O(n)&lt;/p&gt;

&lt;p&gt;如果要求 一个长度不变的array/string 的 permutation 只是 order 不一样，就可以考虑用 swap-swap 的方法。&lt;/p&gt;

&lt;h3 id=&#34;permutations-i&#34;&gt;Permutations I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
  if (input == &amp;quot;&amp;quot;) {
    return {&amp;quot;&amp;quot;};
  }
  vector&amp;lt;string&amp;gt; result;
  helper(result, input, 0);
  return result;
  }
  
private:
  void swap(string &amp;amp;s, int i, int j) {
    auto temp = s[i];
    s[i] = s[j];
    s[j] = temp;
  }

  void helper(vector&amp;lt;string&amp;gt; &amp;amp; result, string &amp;amp; s, int index) {
    if (index == s.size()){
      result.emplace_back(s);
      return;
    }
    for (int i = index; i &amp;lt; s.size(); i++) {
      swap(s, i, index);
      helper(result, s, index + 1);
      swap(s, i, index);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;permutations-ii-dedup&#34;&gt;Permutations II - Dedup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
    vector&amp;lt;string&amp;gt; result;
    helper(input, result, 0);
    return result;
  }
  
private:
  void helper(string &amp;amp; input, vector&amp;lt;string&amp;gt; &amp;amp; result, int level) {
    if (level == input.size()) {
        result.emplace_back(input);
        return;
    }
    
    set&amp;lt;char&amp;gt; charset;
    for (int i = level; i &amp;lt; input.size(); ++i) {
      if (charset.find(input[i]) != charset.end()) {
        continue;
      }
      charset.emplace(input[i]);
      swap(input[i], input[level]);
      helper(input, result, level + 1);
      swap(input[i], input[level]);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parenthesis-problems&#34;&gt;Parenthesis Problems&lt;/h2&gt;

&lt;h3 id=&#34;valid&#34;&gt;Valid&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Given N pairs of parentheses “()”, return a list with all the valid permutations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void validParenthesisHelper(int l, int r, int n, string &amp;amp; cur, vector&amp;lt;string&amp;gt; &amp;amp; res) {
    if (l + r ==  2 * n) {
        res.emplace_back(cur);
        return;
    }
    
    if (l &amp;lt; n) {
        cur += &amp;quot;(&amp;quot;;
        validParenthesisHelper(l + 1, r, n, cur, res);
        cur.pop_back();
    }
    
    if (r &amp;lt; l) {
        cur += &amp;quot;)&amp;quot;;
        validParenthesisHelper(l, r + 1, n, cur, res);
        cur.pop_back();
    }
}

vector&amp;lt;string&amp;gt; validParenthesis(int n) {
    vector&amp;lt;string&amp;gt; res;
    string cur;
    validParenthesisHelper(0, 0, n, cur, res);
    return res;
}

void testvalidParenthesis() {
    auto res = validParenthesis(3);
    for (const auto &amp;amp; str : res) {
        cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time: O(2^2n)
Space: O(2n)&lt;/p&gt;

&lt;h2 id=&#34;coin-combinations&#34;&gt;Coin Combinations&lt;/h2&gt;

&lt;h3 id=&#34;99-cents&#34;&gt;99 Cents&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&#34;&gt;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void coinCombinationHelper(const vector&amp;lt;int&amp;gt; &amp;amp; coins,
                           vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res,
                           vector&amp;lt;int&amp;gt; &amp;amp; cur,
                           int remaining,
                           int level) {
    if (level == coins.size()) {
        if (remaining == 0) {
            res.emplace_back(cur);
        }
        return;
    }

    int n = remaining/coins[level];
    for (int i = 0; i &amp;lt;= n; i++) {
        cur.emplace_back(i);
        coinCombinationHelper(coins, res, cur, remaining - i * coins[level], level + 1);
        cur.pop_back();
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; coinCombination(const vector&amp;lt;int&amp;gt; &amp;amp; coins, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; cur;
    coinCombinationHelper(coins, res, cur, target, 0);
    return res;
}

void testCoinsCombination() {
    vector&amp;lt;int&amp;gt; coins = {25, 10, 5, 1};
    auto res = coinCombination(coins, 99);
    for (const auto &amp;amp; v : res) {
        for (const auto &amp;amp; c : v) {
            cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;find-all-valid-combinations-of-factors-that-form-an-integer&#34;&gt;find all valid combinations of factors that form an integer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&#34;&gt;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;backtracking-on-tree&#34;&gt;Backtracking on Tree&lt;/h2&gt;

&lt;h3 id=&#34;longest-consecutive-sequence&#34;&gt;Longest consecutive sequence&lt;/h3&gt;

&lt;p&gt;int global_max = INT_MIN;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int helper(TreeNode* root) {
  if (root == nullptr) {
    return 0;
  }

  int left = 0;
  int right = 0;

  if (root-&amp;gt;left &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;val -1 == root-&amp;gt;val) {
    left = helper(root-&amp;gt;left);
  } 
  if (root-&amp;gt;right &amp;amp;&amp;amp; root-&amp;gt;right-&amp;gt;val -1 == root-&amp;gt;val) {
    right = helper(root-&amp;gt;right);
  } 
  int local_max = max(left, right) + 1;
  global_max = max(global_max, local_max)l
  return local_max;

} 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Extended Kalman Filter</title>
      <link>https://pineal.github.com/posts/extended_kalman_filter/</link>
      <pubDate>Thu, 01 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/extended_kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;review-of-kalman-filter&#34;&gt;Review of Kalman filter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pineal.github.io/2015/03/Kalman-Filter/]&#34;&gt;Previous post on basic kalman filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ilectureonline.com/lectures/subject/SPECIAL%20TOPICS/26/190&#34;&gt;iLecture lessons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Distribution of Gausion is not Gaussian, it becomes non-linear&lt;/p&gt;

&lt;p&gt;Extented Kalman filter uses a linear approximation of h(x)
Here we use first order taylor expansion to&lt;/p&gt;

&lt;p&gt;Given a function f(x), a taylor series expansion could be expressed:&lt;/p&gt;

&lt;p&gt;$$f(x) \approx \frac{\partial{f(\mu)} }{\partial{x}}(x - \mu)$$&lt;/p&gt;

&lt;h2 id=&#34;multivariate-taylor-series&#34;&gt;Multivariate Taylor Series&lt;/h2&gt;

&lt;h2 id=&#34;design-kalman-filter-for-1d-tracking-problem&#34;&gt;Design Kalman Filter for 1D tracking problem&lt;/h2&gt;

&lt;p&gt;We need to define two linear functions:
1. state transition function
2. measurement function&lt;/p&gt;

&lt;h3 id=&#34;state-transition-function&#34;&gt;State transition function&lt;/h3&gt;

&lt;p&gt;$$ x&amp;rsquo; = F * x + noise $$&lt;/p&gt;

&lt;p&gt;where,&lt;/p&gt;

&lt;p&gt;$$F = \begin{pmatrix}
        1 &amp;amp; \Delta{t}  \\ 0 &amp;amp; 1
      \end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;$$x = \begin{pmatrix} p \\ v\end{pmatrix}$$&lt;/p&gt;

&lt;p&gt;postion $p$ is linear motion model, calculation is:&lt;/p&gt;

&lt;p&gt;$$p&amp;rsquo; = p + v * \Delta{t}$$&lt;/p&gt;

&lt;p&gt;Thus We can express it in a matrix form:&lt;/p&gt;

&lt;p&gt;$$&lt;/p&gt;

&lt;h1 id=&#34;begin-pmatrix-p-v-end-pmatrix&#34;&gt;\begin{pmatrix} p&amp;rsquo; \\ v&amp;rsquo; \end{pmatrix}&lt;/h1&gt;

&lt;p&gt;\begin{pmatrix}
        1 &amp;amp; \Delta{t} \\ 0 &amp;amp; 1
\end{pmatrix}
\begin{pmatrix} p \\ v\end{pmatrix}
$$&lt;/p&gt;

&lt;h3 id=&#34;measurement-update-function&#34;&gt;Measurement Update function&lt;/h3&gt;

&lt;p&gt;At time $t$, the belief is represented by the mean $\mu_t$ and the covariance $\Sigma_t$.&lt;/p&gt;

&lt;h4 id=&#34;process-model&#34;&gt;Process Model&lt;/h4&gt;

&lt;p&gt;The state transition probability $p(x_t \mid u&lt;em&gt;t, x&lt;/em&gt;{t-1})$ must be a linear functoin in its arguments with added Gaussian noise. This is expressed by the following equation:&lt;/p&gt;

&lt;p&gt;$$x_t = A&lt;em&gt;tx&lt;/em&gt;{t-1} + B_tu_t + \epsilon_t$$&lt;/p&gt;

&lt;h4 id=&#34;measurement-model&#34;&gt;Measurement Model&lt;/h4&gt;

&lt;p&gt;The measurement probability $p(z_t \mid x_t)$ must also be linear in its arguments, with added Gaussian noise:&lt;/p&gt;

&lt;p&gt;$$z_t = C_tx_t + \delta_t$$&lt;/p&gt;

&lt;h4 id=&#34;kalman-filter-algorithm&#34;&gt;Kalman Filter Algorithm&lt;/h4&gt;

&lt;p&gt;$$\bar\mu_t  = A&lt;em&gt;t\mu&lt;/em&gt;{t-1} + B_tu_t$$&lt;/p&gt;

&lt;p&gt;$$\bar\Sigma_t = A&lt;em&gt;t\Sigma&lt;/em&gt;{t-1} + R_t $$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cache Design</title>
      <link>https://pineal.github.com/posts/cache_design/</link>
      <pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/cache_design/</guid>
      <description>

&lt;h1 id=&#34;cache-design&#34;&gt;Cache Design&lt;/h1&gt;

&lt;h2 id=&#34;lru&#34;&gt;LRU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1-SMH7LNov8UM8BuCKMJGTQ523GnK5Td02qqX-E0LWQk/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;
&lt;/iframe&gt;

&lt;h2 id=&#34;lfu&#34;&gt;LFU&lt;/h2&gt;

&lt;iframe src=&#34;https://docs.google.com/presentation/d/1B_BeXdSxWUKpag_fWd_4laL8HVRmXZ5KU8prgOWIxB8/embed?start=false&amp;loop=false&amp;delayms=3000&#34; frameborder=&#34;0&#34; width=&#34;480&#34; height=&#34;399&#34; allowfullscreen=&#34;true&#34; mozallowfullscreen=&#34;true&#34; webkitallowfullscreen=&#34;true&#34;&gt;
&lt;/iframe&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/tree/master/Cache%20Design/Cache%20Design&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>少年常戚戚</title>
      <link>https://pineal.github.com/posts/%E5%B0%91%E5%B9%B4%E5%B8%B8%E6%88%9A%E6%88%9A/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E5%B0%91%E5%B9%B4%E5%B8%B8%E6%88%9A%E6%88%9A/</guid>
      <description>&lt;p&gt;我为什么要离开 &lt;br/&gt;
你为什么不留下 &lt;br/&gt;
就像是络腮胡的最北端 &lt;br/&gt;
若隐若现 &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;我费尽全力为你练习&lt;br/&gt;
却被你嘲笑不够有趣&lt;br/&gt;
愤愤不平&lt;br/&gt;
毕竟全中国也不会有几个&lt;br/&gt;
广场舞十级&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;想跟无耻的自己打一场群架&lt;br/&gt;
可惜敌军太过怯懦&lt;br/&gt;
友军狐假虎威&lt;br/&gt;
司令害怕三个地雷&lt;br/&gt;
还有一对炸弹&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;九十年代的汽车都有个喇叭&lt;br/&gt;
喇叭会响&lt;br/&gt;
倒车请注意&lt;br/&gt;
倒车请注意&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;为什么这锅肉散发着资本主义的&lt;br/&gt;
腐朽气息&lt;br/&gt;
哦&lt;br/&gt;
我用僵尸丹炖的&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kth Problems</title>
      <link>https://pineal.github.com/posts/kth_problems/</link>
      <pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kth_problems/</guid>
      <description>

&lt;h1 id=&#34;kth-problems&#34;&gt;Kth Problems&lt;/h1&gt;

&lt;h2 id=&#34;solution-with-priority-queue&#34;&gt;Solution with priority queue&lt;/h2&gt;

&lt;p&gt;套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).&lt;/p&gt;

&lt;h3 id=&#34;merge-k-sorted-lists&#34;&gt;Merge k Sorted Lists&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
//Time O(nlogk)
//Space O(n)
//provides greater
struct Cmp {
  bool operator() (ListNode* n1, ListNode* n2) {
    return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;
  }
};

class Solution {
public:
  ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) {
    //min_heap needs a greater comparator
    //Method 1: redefine functor
    //priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, Cmp&amp;gt; min_heap;
    //Method 2: Lambda
    auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&amp;gt; val &amp;gt; n2 -&amp;gt; val;};
    priority_queue&amp;lt;ListNode*, vector&amp;lt;ListNode*&amp;gt;, decltype(cmp)&amp;gt; min_heap(cmp);
    //maintain the min_heap of size k instead of all nodes
    // klogn =&amp;gt; nlogk
    for (int i = 0; i &amp;lt; lists.size(); i++) {
      if (lists[i]) {
        min_heap.emplace(lists[i]);
      }
    }

    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (!min_heap.empty()) {
      ListNode* temp = min_heap.top();
      cur -&amp;gt; next = temp;
      min_heap.pop();
      if (temp -&amp;gt; next) {
        min_heap.emplace(temp -&amp;gt; next);
      }
      cur = cur -&amp;gt; next;
    }
    return dummy -&amp;gt; next;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-number-in-sorted-matrix&#34;&gt;Kth Smallest Number In Sorted Matrix&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class Cell {
public:
    int row;
    int col;
    int value;
    Cell(int _row, int _column, int _value) {
        row = _row;
        col = _column;
        value = _value;
    }

    bool operator &amp;lt; (const Cell &amp;amp; c) const {
        return value &amp;lt;= c.value;
    }

    bool operator &amp;gt; (const Cell &amp;amp; c) const {
        return value &amp;gt; c.value;
    }
};

int kthSmallest(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; m, int k) {
    priority_queue&amp;lt;Cell, vector&amp;lt;Cell&amp;gt;, greater&amp;lt;Cell&amp;gt;&amp;gt; min_heap;
    min_heap.emplace(Cell(0, 0, m[0][0]));
    size_t num_row = m.size();
    size_t num_col = m[0].size();
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(num_row, vector&amp;lt;bool&amp;gt;(num_col, false));
    visited[0][0] = true;
    for (int i = 0; i &amp;lt; k - 1; i++) {
        Cell c = min_heap.top();
        min_heap.pop();
        if (c.row + 1 &amp;lt; num_row &amp;amp;&amp;amp; visited[c.row + 1][c.col] == false) {
                min_heap.emplace(Cell(c.row + 1, c.col, m[c.row + 1][c.col]));
                visited[c.row + 1][c.col] = true;
        }

        if (c.col + 1 &amp;lt; num_col &amp;amp;&amp;amp; visited[c.row][c.col + 1] == false) {
                min_heap.emplace(Cell(c.row, c.col + 1, m[c.row][c.col + 1]));
                visited[c.row][c.col + 1] = true;
        }
    }
    return min_heap.top().value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-sum-in-two-sorted-arrays&#34;&gt;Kth Smallest Sum In Two Sorted Arrays&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Cell {
public:
  int i;
  int j;
  int sum;
  Cell(int _i, int _j, int _sum) {
    i = _i;
    j = _j;
    sum = _sum;
  }

  bool operator &amp;lt; (const Cell &amp;amp; c) const {
    return sum &amp;lt;= c.sum;
  }

  bool operator &amp;gt; (const Cell &amp;amp; c) const {
    return sum &amp;gt; c.sum;
  }
};

class Solution {
 public:
  int kthSum(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, int k) {
    // Write your solution here
    priority_queue&amp;lt;Cell, vector&amp;lt;Cell&amp;gt;, greater&amp;lt;Cell&amp;gt;&amp;gt; min_heap;
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; visited(a.size(), vector&amp;lt;bool&amp;gt;(b.size(), false));
    visited[0][0] = true;
    min_heap.emplace(Cell(0, 0, a[0] + b[0]));
    for (int i = 0; i &amp;lt; k - 1; i++) {
      Cell cur = min_heap.top();
      min_heap.pop();
      if (cur.i + 1 &amp;lt; a.size() &amp;amp;&amp;amp; !visited[cur.i + 1][cur.j]) {
        int sum = a[cur.i + 1] + b[cur.j];
        min_heap.emplace(Cell(cur.i + 1, cur.j, sum));
        visited[cur.i + 1][cur.j] = true;
      }

      if (cur.j + 1 &amp;lt; b.size() &amp;amp;&amp;amp; !visited[cur.i][cur.j + 1]) {
        int sum = a[cur.i] + b[cur.j + 1];
        min_heap.emplace(Cell(cur.i, cur.j + 1, sum));
        visited[cur.i][cur.j + 1] = true;
      }
    }
    return min_heap.top().sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-smallest-with-only-3-5-7-as-factors&#34;&gt;Kth Smallest With Only 3, 5, 7 As Factors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  long kth(int k) {
    // Write your solution here.
    priority_queue&amp;lt;long, vector&amp;lt;long&amp;gt;, greater&amp;lt;long&amp;gt;&amp;gt; min_heap;
    min_heap.emplace(105);
    set&amp;lt;long&amp;gt; visited;
    visited.emplace(105);
    for (int i = 0; i &amp;lt; k - 1; i++) {
      long cur = min_heap.top();
      min_heap.pop();
      if (visited.find(cur * 3) == visited.end()) {
        min_heap.emplace(cur * 3);
        visited.emplace(cur * 3);
      }

      if (visited.find(cur * 5) == visited.end()) {
        min_heap.emplace(cur * 5);
        visited.emplace(cur * 5);
      }      

      if (visited.find(cur * 7) == visited.end()) {
        min_heap.emplace(cur * 7);
        visited.emplace(cur * 7);
      }      
    }

    return min_heap.top();
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kth-closest-point&#34;&gt;Kth Closest Point&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {
public:
    int x;
    int y;
    int z;
    double dis;
    Point (int _x, int _y, int _z, double _dis) {
        x = _x;
        y = _y;
        z = _z;
        dis = _dis;
    }

    bool operator &amp;lt; (const Point &amp;amp; p1) const {
        return dis &amp;lt;= p1.dis;
    }

    bool operator &amp;gt; (const Point &amp;amp; p1) const {
        return dis &amp;gt; p1.dis;
    }

};

class Solution {
 public:
    vector&amp;lt;int&amp;gt; closest(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b, vector&amp;lt;int&amp;gt; c, int k) {
        priority_queue&amp;lt;Point, vector&amp;lt;Point&amp;gt;, greater&amp;lt;Point&amp;gt;&amp;gt; min_heap;
        set&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; visited;
        double d = sqrt(a[0] * a[0] + b[0] * b[0] + c[0] * c[0] + 0.0);
        Point* start = new Point(0,0,0,d);
        min_heap.emplace(*start);
        visited.emplace(vector&amp;lt;int&amp;gt;{0,0,0});
        for (int i = 0; i &amp;lt; k - 1; i++) {
            Point p = min_heap.top();
            min_heap.pop();
            if (p.x + 1 &amp;lt; a.size()) {
                double d = sqrt(a[p.x + 1] * a[p.x + 1] + b[p.y] * b[p.y] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x + 1,p.y,p.z,d);
                if (visited.find({p.x + 1,p.y,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x + 1, p.y, p.z};
                    visited.emplace(v);
                }
            }
            if (p.y + 1 &amp;lt; b.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y + 1] * b[p.y + 1] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x,p.y + 1,p.z,d);
                if (visited.find({p.x,p.y + 1,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y + 1,p.z};
                    visited.emplace(v);
                }
            }

            if (p.z + 1 &amp;lt; c.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y] * b[p.y] + c[p.z + 1] * c[p.z + 1] + 0.0);
                Point* temp = new Point(p.x,p.y,p.z + 1,d);
                if (visited.find({p.x,p.y,p.z + 1}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&amp;lt;int&amp;gt; v = {p.x,p.y,p.z + 1};
                    visited.emplace(v);
                }
            }      
        }

        Point rst = min_heap.top();
        return {a[rst.x], b[rst.y], c[rst.z]};
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;visited尽量用bool数组表示，二维三维都可。不要存放node类的class，地址不一样。&lt;/p&gt;

&lt;h2 id=&#34;solution-with-binary-search&#34;&gt;Solution with binary search&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://pineal.github.io/posts/binary_search/#advanced-using-binary-search-to-solve-kth-problem&#34;&gt;post about binary search&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution-with-quick-sort-partition&#34;&gt;Solution with quick-sort partition&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60309/4-C++-Solutions-using-Partition-Max-Heap-priority_queue-and-multiset-respectively&#34;&gt;solution&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Data Structures for Disjoint Sets</title>
      <link>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/data_structures_for_disjoint_sets/</guid>
      <description>

&lt;h1 id=&#34;disjoint-sets&#34;&gt;Disjoint Sets&lt;/h1&gt;

&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;make_set(x)
将一个vertex变成一个disjoint&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;union(x, y)
将包含vertex x 的 set 和 包含vertex y 的 set 并起来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find_set(x)
返回一个指针，指向包含这个vertex 的唯一的 set&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;basic-implementation&#34;&gt;Basic implementation&lt;/h2&gt;

&lt;p&gt;最基本的应用是来确定一个 undirected graph 中的 connected components.&lt;/p&gt;

&lt;p&gt;连接components:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connected_component(G)
    for each vertex v in G
        make_set(v)
    for each edge(u, v) e in G
        if (find_set(u) != find_set(v))
            union(u, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断两个vertices是否连接在同一component中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;same_component(u, v)
    if find_set(u) == find_set(v)
        return true
    else
        return false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;h3 id=&#34;number-of-connected-components-in-an-undirected-graph&#34;&gt;Number of Connected Components in an Undirected Graph&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    //compress the path and return the root of the union set
    int find_set(vector&amp;lt;int&amp;gt; &amp;amp; allsets, int node) {
        if (node != allsets[node]) {
            allsets[node] = find_set(allsets, allsets[node]);
        }
        return allsets[node];
    }
    
    void union_set(vector&amp;lt;int&amp;gt; &amp;amp; allsets, int x, int y) {
        int xroot = find_set(allsets, x);
        int yroot = find_set(allsets, y);
        allsets[yroot] = xroot;
    }
    int countComponents(int n, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;amp; edges) {
        //allsets[x] : get the parent of set include x
        vector&amp;lt;int&amp;gt; allsets(n);
        int count = 0;
        for (int i = 0; i &amp;lt; n; i++) {
            allsets[i] = i;
        }
        for (auto edge : edges) {
            int x = find_set(allsets, edge.first);
            int y = find_set(allsets, edge.second);
            if (x != y) {
                union_set(allsets, edge.first, edge.second);
                count++;
            }
        }
        return n - count;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optimization-disjoint-set-forest&#34;&gt;Optimization - Disjoint-Set Forest&lt;/h2&gt;

&lt;p&gt;除了可以用链表/数组来实现 disjoint-set， disjoint-set forest是一种比链表实现更快的实现。我们将sets表示为rooted trees。 每一个 node 包括一个 vertex，每一棵树代表一个set. 所有的node都指向各自的parent. 在树中那个指向自己的显然就是tree root。这种数据结构高效的原因是用了以下两种技巧：&amp;rdquo;union by rank&amp;rdquo; and &amp;ldquo;path compression&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;union-by-rank&#34;&gt;Union By Rank&lt;/h3&gt;

&lt;p&gt;为每个node维护一个变量rank。 rank代表这这个node的高度的上限。在并集的过程中，我们依据rank的高低，把低rank的root指向高rank的root。&lt;/p&gt;

&lt;h3 id=&#34;path-compression&#34;&gt;Path compression&lt;/h3&gt;

&lt;p&gt;路径压缩并不改变任何rank，只是把tree中的所有node都指向这颗树的root。这个过程在find_set这个操作中实现。&lt;/p&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;make_set(x)
x.p = x
x.rank = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;union(x, y)
    link(find_set(x), find_set(y))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;link(x,y)
    if x.rank &amp;gt; y.rank
        y.p = x
    else if x.rank &amp;lt; y.rank
        x.p = y
    else
        x.p = y
        y.rank = y.rank + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;find_set(x)
    if x != x.p
        x.p = find_set(x.p)
    return x.p
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h3&gt;

&lt;p&gt;时间复杂度为 $O(m \alpha(n))$, union_set takes amortized n time complexity.&lt;/p&gt;

&lt;p&gt;空间复杂度为 O(n)&lt;/p&gt;

&lt;p&gt;TODO: 分析&lt;/p&gt;

&lt;h2 id=&#34;detect-cycle-in-a-undirected-graph&#34;&gt;Detect Cycle in a undirected graph&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Edge {
public:
    int src;
    int dest;
    Edge() {;}
    Edge(int s, int d);
};

Edge::Edge(int s, int d) {
    src = s;
    dest = d;
}

class Graph {
public:
    int V;
    int E;
    vector&amp;lt;Edge&amp;gt; edges;
    Graph(int V, int E);
    void addEdge(int start, int end);
};

Graph::Graph(int V, int E) {
    this-&amp;gt;V = V;
    this-&amp;gt;E = E;
    this-&amp;gt;edges.resize(E);
}

void Graph::addEdge(int start, int end) {
    Edge e(start, end);
    edges.emplace_back(e);
}


class DisjointSet {
public:
    int parent;
    int rank;
    DisjointSet(int parent);
};

DisjointSet::DisjointSet(int p) {
    this-&amp;gt;parent = p;
    this-&amp;gt;rank = 0;
}

//given a node, find it&#39;s parent in its disjoint_set
int find_set(vector&amp;lt;DisjointSet&amp;gt; &amp;amp; allsets, int node) {
    if (allsets[node].parent != node) {
        allsets[node].parent = find_set(allsets, allsets[node].parent);
    }
    return allsets[node].parent;
}

void union_set(vector&amp;lt;DisjointSet&amp;gt; &amp;amp; allsets, int x, int y) {
    int xp = find_set(allsets, x);
    int yp = find_set(allsets, y);
    if (allsets[xp].rank &amp;gt; allsets[yp].rank) {
        allsets[yp].parent = xp;
    }
    else if (allsets[xp].rank &amp;lt; allsets[yp].rank) {
        allsets[xp].parent = yp;
    }
    else {
        allsets[xp].parent = yp;
        allsets[yp].rank++;
    }
}

bool is_cycle(const Graph &amp;amp; graph) {
    int V = graph.V;
    int E = graph.E;
    vector&amp;lt;DisjointSet&amp;gt; allsets;
    for (int v = 0; v &amp;lt; V; v++) {
        allsets.emplace_back(v);
    }
    for (int e = 0; e &amp;lt; E; e++) {
        int x = find_set(allsets, graph.edges[e].src);
        int y = find_set(allsets, graph.edges[e].dest);
        if (x == y) {
            return true;
        }
        else {
            union_set(allsets, x, y);
        }
    }
    return false;
}

void test_is_cycle() {
    Graph graph(3, 3);
    graph.addEdge(0, 1);
    graph.addEdge(1, 2);
    graph.addEdge(0, 2);
    if (is_cycle(graph)) {
    	cout &amp;lt;&amp;lt;  &amp;quot;has a cycle&amp;quot;;
    }
    else {
        cout &amp;lt;&amp;lt; &amp;quot;does not have a cycle&amp;quot;;
    }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;leetcode-305-number-of-islands-ii&#34;&gt;LeetCode 305 Number of Islands II&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://pineal.github.com/posts/bit_manipulation/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/bit_manipulation/</guid>
      <description>

&lt;h1 id=&#34;summary-of-basic-bit-manipulation&#34;&gt;Summary of Basic Bit Manipulation&lt;/h1&gt;

&lt;h2 id=&#34;count-1-in-binary&#34;&gt;Count 1 in Binary&lt;/h2&gt;

&lt;p&gt;数的二进制表示中有多少位1. 有两种方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每次把各位的数和 1 做 &amp;amp; 运算，然后计数，右移进行下一位。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        for (int i = 0; i &amp;lt; sizeof(int)*8; i++) {
            counter += num &amp;amp; 1;
            num &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;把 num 和 num - 1 做 &amp;amp; 运算， 直到num为0，有多少次运算就有多少个1. 因为每次“&amp;amp;”都会去掉num最右边的1.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        while (num) {
            num &amp;amp;= num - 1;
            counter++;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用法判断是不是2的整数次幂很容易，因为2的整数次幂必然只有1个bit的1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkPowerOf2(int n) {
    // write your code here
    return n &amp;gt; 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flip-bits&#34;&gt;Flip Bits&lt;/h2&gt;

&lt;p&gt;用到了xor的性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param a, b: Two integer
     *return: An integer
     */
    int bitSwapRequired(int a, int b) {
        // write your code here
        int counter = 0;
        int c = a^b;
        for (int i = 0; i &amp;lt; 32; i++) {
            counter += c &amp;amp; 1;
            c &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-b-problem&#34;&gt;A + B problem&lt;/h2&gt;

&lt;p&gt;这题。
         主要利用异或运算来完成。
         异或运算有一个别名叫做：不进位加法。
         那么a ^ b就是a和b相加之后，该进位的地方不进位的结果。
         然后下面考虑哪些地方要进位，自然是a和b里都是1的地方。
         a &amp;amp; b就是a和b里都是1的那些位置，a &amp;amp; b &amp;lt;&amp;lt; 1 就是进位
         之后的结果。所以：a + b = (a ^ b) + (a &amp;amp; b &amp;lt;&amp;lt; 1)
         。令a&amp;rsquo; = a ^ b, b&amp;rsquo; = (a &amp;amp; b) &amp;lt;&amp;lt; 1
         可以知道，这个过程是在模拟加法的运算过程，进位不可能
         一直持续，所以b最终会变为0。因此重复做上述操作就可以
         求得a + b的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
       while (b != 0) {
            int _a = a ^ b;
            int _b = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
            a = _a;
            b = _b;
        }
        return a;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-bits&#34;&gt;Update Bits&lt;/h2&gt;

&lt;p&gt;Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.&lt;/p&gt;

&lt;p&gt;把一个数的 ［j， i］ 之间的bits 用另一个数去填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int right_part = n &amp;amp; ((1 &amp;lt;&amp;lt; i) - 1);
        // The behavior of right shift &amp;gt;= 32 is undefined in C++.
        int left_part = j &amp;gt;= 31 ? 0 : (n &amp;gt;&amp;gt; (j + 1)) &amp;lt;&amp;lt; (j + 1);
        return left_part | (m &amp;lt;&amp;lt; i) | right_part;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用一个 mask 把 i 右边的数给取出来。
左边的数要这么取：先把bits右移 j + 1位，然后再左移 j + 1位，这样右边的数就都清空了。
最后一步把 m 左移后再把左边部分和右边部分用 ｜ 粘起来。
这种思想还可以用来做高地位互换等。把前一半的数右移，把后一半的数左移，然后 ｜ 起来。&lt;/p&gt;

&lt;h2 id=&#34;swap-two-variables&#34;&gt;swap two variables&lt;/h2&gt;

&lt;p&gt;如何不用第三个临时变量来交换两个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(int &amp;amp;a, int &amp;amp;b){
	if (a != b){
		  a ^= b;
      b ^= a;
      a ^= b;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;abs&#34;&gt;abs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//取符号位
	int a = -100;
	int i = a &amp;gt;&amp;gt; 31;
	//i = 0 正数
	if(i == 0){
		printf(&amp;quot;%d\n&amp;quot;,a);
	}
	//i = 1 负数
	else{
		printf(&amp;quot;%d\n&amp;quot;,~a + 1);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-complement&#34;&gt;Number Complement&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int findComplement(int num) {
        unsigned mask = ~0;
        while (num &amp;amp; mask) mask &amp;lt;&amp;lt;= 1;
        return ~mask &amp;amp; ~num;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://pineal.github.com/posts/sorting_algorithms/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sorting_algorithms/</guid>
      <description>

&lt;p&gt;假设这里的排序都是升序。&lt;/p&gt;

&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort:&lt;/h2&gt;

&lt;p&gt;归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// merge part
  vector&amp;lt;int&amp;gt; merge(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
	  vector&amp;lt;int&amp;gt; rst;
	  std::vector&amp;lt;int&amp;gt;::iterator iter1 = A.begin(), iter2 = B.begin();

	  while (iter1 != A.end() || iter2 != B.end()) {
	  	if (iter1 == A.end()) {
		  	rst.insert(rst.end(), iter2, B.end());
		  	break;
		  }
		  if (iter2 == B.end()) {
		  	rst.insert(rst.end(), iter1, A.end());
		  	break;
		  }
		  if (*iter1 &amp;lt; *iter2) {
			  rst.emplace_back(*iter1);
			  iter1++;
		  }
		  else {
			  rst.emplace_back(*iter2);
			  iter2++;
		  }
	  }
	  return rst;
  }

// key part of merge sort, recursive function
  vector&amp;lt;int&amp;gt; MSort(vector&amp;lt;int&amp;gt; array, int left, int right) {
	  vector&amp;lt;int&amp;gt; rst;
	  if (left == right) {
		  rst.emplace_back(array[left]);
		  return rst;
	  }
	  int mid = left + (right - left) / 2;
	  vector&amp;lt;int&amp;gt; leftArr = MSort(array, left, mid);
	  vector&amp;lt;int&amp;gt; rightArr = MSort(array, mid + 1, right);
	  rst = merge(leftArr, rightArr);
	  return rst;
  }
// driver for merge sort
  vector&amp;lt;int&amp;gt; mergeSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
	  vector&amp;lt;int&amp;gt; rst;
	  rst = MSort(array, 0, array.size() - 1);
	  return rst;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析： $O(nlog(n))$&lt;/p&gt;

&lt;p&gt;画出递归树，一共 $log(n)$ 层, 每一层是 $O(n)$ 的复杂度.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort:&lt;/h2&gt;

&lt;p&gt;快速排序的核心的思想为是 &lt;strong&gt;partition&lt;/strong&gt;. 这个思想在很多类型的问题中都会用到，会在后文举例说明。&lt;/p&gt;

&lt;p&gt;快速排序的基本操作为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选取一个pivot。&lt;/li&gt;
&lt;li&gt;所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边。&lt;/li&gt;
&lt;li&gt;分割数组：对pivot两边的数组递归重复以上步骤，直到不能分割。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体有哪些实现呢。
先来看第一种方法。这是一个textbook的解法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; int median(vector&amp;lt;int&amp;gt;&amp;amp; arr, int left, int right){
   // arr[left] &amp;lt;= arr[center] &amp;lt;= arr[right]
   int center = left + (right - left)/2;
   if (arr[left] &amp;gt; arr[center]) swap(&amp;amp;arr[left], &amp;amp;arr[center]);
   if (arr[left] &amp;gt; arr[right])  swap(&amp;amp;arr[left], &amp;amp;arr[right]);
   if (arr[center] &amp;gt; arr[right]) swap(&amp;amp;arr[center], &amp;amp;arr[right]);
   swap(&amp;amp;arr[center], &amp;amp;arr[right - 1]); //hide pivot
   return arr[right - 1];
 }

 void QSort(vector&amp;lt;int&amp;gt; &amp;amp; arr, int left, int right) {

//   if (left &amp;gt;= right) return;
   if (left + CutOff &amp;lt;= right){
     int pivot = median(arr, left, right);
     int i = left;
     int j = right - 1;
     for(;;){
      while (arr[++i] &amp;lt; pivot){}
       while (arr[--j] &amp;gt; pivot){}
      if (i &amp;lt; j) swap(&amp;amp;arr[i], &amp;amp;arr[j]);
       else  break;
     }
//   if (left + 1 != right){
       swap(&amp;amp;arr[i], &amp;amp;arr[right - 1]); //restore pivot
//   }  
     QSort(arr, left, i - 1);
     QSort(arr, i + 1, right);
   }
   else{
     insertion_Sort(arr, left, right - left + 1);
   }
 }

 vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
   if (array.size() &amp;lt;= 1) return array;
   QSort(array, 0, array.size() - 1);
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个解法。基本思想是一样的。每次都要保持所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边这个条件。
实现的过程为，选取两块挡板，分别从数组的头和尾往中间靠拢，直到挡板相遇。在每一次的循环中，保证第一块挡板左边的数都小于pivot，第二块挡板右边的数都大于pivot。&lt;/p&gt;

&lt;p&gt;事实上根据上面这个general rule来分，两个挡板指向的两个数只有四种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;lt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt;= pivot, a[j] &amp;lt;= pivot$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么对应刚才的rule该做着么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;满足条件：移动挡板i++， j&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足前半个条件，移动挡板i++，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足后半个条件，移动挡板j&amp;ndash;，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不满足任何条件，但是一旦交换两个挡板上的数，即可让条件满足&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  void QuickSort(vector&amp;lt;int&amp;gt; &amp;amp; array, int left, int right){
    if (left &amp;gt; right) return;
    int pivot_index = (left + right)/2;
    int pivot =  array[pivot_index];
    int left_bound = left;
    int right_bound = right - 1;
    //hide the pivot in the rightmost
    std::swap(array[pivot_index], array[right]);
    //three regions:
    //1. [0, leftbound - 1] : all elements smaller than pivot should be here
    //2. [leftbound, rightbound]: to be discovered, scan the element in a[leftbound], and move leftbound every step
    //3. [rightbound + 1, array.size() - 1] all elements bigger than pivot should be here
    while (left_bound &amp;lt;= right_bound) {
      //check two
      if (array[left_bound] &amp;lt; pivot) {
      // obey all three rules, move leftbound
        ++left_bound;
      }
      else if (array[right_bound] &amp;gt; pivot) {
        --right_bound;
      }
      else {
        //array[left_bound] &amp;gt; pivot &amp;amp;&amp;amp; array[right_bound &amp;lt; pivot]
        std::swap(array[left_bound++], array[right_bound--]);      
      }
    }
    //restore the pivot to the original position
    std::swap(array[left_bound], array[right]);
    //partition and recursion
    QuickSort(array, left, left_bound - 1);
    QuickSort(array, left_bound + 1, right);
  }

  vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
    QuickSort(array, 0, array.size() - 1);
    return array;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的解法可以归结为一种类型。比如一堆数中只有两种，三种四种数，那么就可以对应个数的挡板将数分割成相应区域，每次检查条件是否满足。Eg: Sort colors。这样的做法复杂度只需要$O(n)$.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-i-sort-colors&#34;&gt;Partition Extension I: Sort Colors&lt;/h3&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int zero = 0;
    int one = 0;    //explorer
    int two = nums.size() - 1;
    //Three seperator Four regions
    //[0, zero)     0
    //[zero, one]   1
    //(two, end]    2
    while (one &amp;lt;= two) {
        if (nums[one] == 0) {   
            swap(nums[one++], nums[zero++]);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums[one], nums[two--]);
            //don&#39;t move &#39;one&#39;:
            //you don&#39;t know what is swaped from &#39;two&#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-i-four-colors&#34;&gt;Follow up I: four colors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; rainbowSortII(vector&amp;lt;int&amp;gt; array) {
   int zero = 0, one = 0, other = array.size() - 1;
   while (one &amp;lt;= other) {
     if (array[one] &amp;lt; 1) {
       swap(array[one++], array[zero++]);
     } else if (array[one] &amp;gt; 1) {
       swap(array[other--], array[one]);
     } else {
       one++;
     }
   }
   int two = one, three = array.size() - 1;
   while (two &amp;lt;= three) {
     if (array[two] == 3 &amp;amp;&amp;amp; array[three] == 2) {
       swap(array[two++], array[three--]);
     } else if (array[two] == 2) {
       two++;
     } else {
       three--;
     }
   }
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-ii-k-colors&#34;&gt;Follow up II: k colors&lt;/h3&gt;

&lt;p&gt;TODO: couting sort.&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-ii-kth-smallest-largest-element-in-an-unsorted-array&#34;&gt;Partition Extension II: Kth smallest/largest element in an unsorted array&lt;/h3&gt;

&lt;p&gt;quick sort partition 思想的另一经典应用。
&lt;a href=&#34;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&#34;&gt;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wiggle-sort&#34;&gt;Wiggle Sort&lt;/h2&gt;

&lt;p&gt;$nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]&amp;hellip;.$&lt;/p&gt;

&lt;p&gt;这个时间复杂度优化到了O(n)。下面那个做法是通用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    for (int i=0; i&amp;lt;(int)nums.size() - 1; i++) {
        if (i % 2 == 0 &amp;amp;&amp;amp; nums[i] &amp;gt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
        if (i % 2 == 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
    }        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-wiggle-sort-ii&#34;&gt;Follow up: Wiggle Sort II&lt;/h3&gt;

&lt;p&gt;$nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;$&lt;/p&gt;

&lt;p&gt;根据这个性质，我们可以确定一种排法一定可以成立：把小的那一半排在偶数位，把大的那一半排在奇数位。这个是通用的。
 时间复杂度 $ O(nlog(n)) $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    vector&amp;lt;int&amp;gt; copy(nums);
    sort(copy.begin(), copy.end());
    int left = (nums.size() + 1) / 2 - 1;
    int right = nums.size() - 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        nums[i] = (i % 2 == 0)? copy[left--] : copy[right--];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传说中$O(n)$ 的解法。&lt;/p&gt;

&lt;h2 id=&#34;sort-in-specified-order&#34;&gt;Sort In Specified Order&lt;/h2&gt;

&lt;p&gt;A1 = {2, 1, 2, 5, 7, 1, 9, 3},&lt;/p&gt;

&lt;p&gt;A2 = {2, 1, 3},&lt;/p&gt;

&lt;p&gt;A1 is sorted to {2, 2, 1, 1, 3, 5, 7, 9}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; helper(vector&amp;lt;int&amp;gt; &amp;amp; A1, vector&amp;lt;int&amp;gt; &amp;amp; A2) {
   // Write your solution here.
   if (A1.size() &amp;lt;= 1 |||| A2.size() == 0) {
       sort(A1.begin(), A1.end());
       return A1;
   }
   map&amp;lt;int, int&amp;gt; t;
   for (int i = 0; i &amp;lt; A2.size(); i++) {
       t.emplace(A2[i], i);
   }

   int j = 0, k = A1.size() - 1;
   while (j &amp;lt;= k) {
       if (t.find(A1[j]) == t.end() &amp;amp;&amp;amp; t.find(A1[k]) != t.end()) {
           swap(A1[j], A1[k]);
           j++;
           k--;
       }
       else if (t.find(A1[j]) != t.end()) {
           j++;
       }
       else {
           k--;
       }
   }

   //sort the [0, j) in specified order
   //[2 1 3 4]
   //2 1 2 1 4 3 =&amp;gt; 2 2 1 1 3 4

   for (int i = 0; i &amp;lt; j; i++) {
       int min_index = i;
       for (int l = i; l &amp;lt; j; l++) {
           if (t[A1[min_index]] &amp;gt; t[A1[l]]) {
               min_index = l;
           }
       }
       swap(A1[i], A1[min_index]);
   }

   //sort the (k, n) part in ascending order
   sort(A1.begin() + k + 1, A1.end());
   return A1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort:&lt;/h2&gt;

&lt;p&gt;插入排序。假设一个长度为N的数组$A[]$，总体过程为，从 index 为 1 开始到 N-1，使得 $A[0,index]$ 是一个排好序的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void insertion_sort(T arr[], int len){
  for (int i = 1; i &amp;lt; len; i++){
    int temp = arr[i];
      for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1]&amp;gt;temp; j--){ //实际比较的是j-1
        arr[j] = arr[j-1];  //全部往后移一位腾出位置等插入
      }
    arr[j] = temp;    //插入到腾出来的位置
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度：
$O(n^2)$&lt;/p&gt;

&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort:&lt;/h2&gt;

&lt;p&gt;选择排序。假设一个长度为N的数组$A[]$，总体过程为，从index为0开始到N-1，使得$A[0,index]$是一个排好序的数组。&lt;/p&gt;

&lt;p&gt;怎么跟插入排序这么像呢？是挺像的，但是具体的过程是有区别。这区别就是“插入”和“选择”的区别。&lt;/p&gt;

&lt;p&gt;插入排序是每次往前面那些已经排序好的数里“插入”进去，而选择排序则是，每次从这个数后面那些没排好序的数里“选择”到最小的，和这个数交换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void selection_sort(T arr[], int len){
  for (int i = 0; i &amp;lt; len - 1; i++){  //len - 1即可，最后一次交换在倒数第一个和倒数第二个之间进行
    int min_index = i;
    for (int j = i + 1; j &amp;lt; len; j++){
      //找到未排序的数组中最小的数的index
      if (arr[j]&amp;lt;arr[min_index]){
          min_index = j;
      }        
    }
    swap(arr[i], arr[min_index]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析：
$O(n^2)$的复杂度。实际上是冒泡排序的一个优化，虽然最坏时间复杂度上是一样的。&lt;/p&gt;

&lt;p&gt;附上冒泡排序代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(int arr[], int n) {
    int i, j;
    for (i = 0; i &amp;lt; n - 1; i++) {
        for (j = 0; j &amp;lt; n - 1 - i; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Optimal Control</title>
      <link>https://pineal.github.com/posts/optimal_control/</link>
      <pubDate>Sat, 26 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/optimal_control/</guid>
      <description>

&lt;h1 id=&#34;optimal-control&#34;&gt;Optimal Control&lt;/h1&gt;

&lt;h2 id=&#34;optimal-control-framework&#34;&gt;Optimal Control Framework&lt;/h2&gt;

&lt;p&gt;Given:
A controlled dynamical system：$ x^{n+1} = f(x^n, u^n)$&lt;/p&gt;

&lt;p&gt;A cost function：$V = \phi(x^N, \alpha) + \sum^{N-1}_{i=0}L(x^i, u^i, \alpha)$&lt;/p&gt;

&lt;p&gt;Goal: Find the sequence of commands that minimizes(maximizes) the cost function&lt;/p&gt;

&lt;h2 id=&#34;bellman-s-principle-of-optimality&#34;&gt;Bellman&amp;rsquo;s Principle of Optimality&lt;/h2&gt;

&lt;p&gt;Optimize it using dynamic programming:&lt;/p&gt;

&lt;p&gt;$$
J_i(X&lt;em&gt;i) = \mathop{arg min}&lt;/em&gt;{u_i\in u(x&lt;em&gt;i)}{{L(x^i, u^i, \alpha) + V^*&lt;/em&gt;{i+1}x_{(i+1)}}}
$$&lt;/p&gt;

&lt;h2 id=&#34;linear-quadratic-regulator&#34;&gt;Linear quadratic regulator&lt;/h2&gt;

&lt;p&gt;Special Assumption: Linear System Dynamics
 $$
  x^{n+1} = Ax^n + Bu^n
 $$&lt;/p&gt;

&lt;p&gt;Quadratic cost function
 $$
 L(x^i, u^i, \alpha) ＝ x^{i^T}Qx^i + u^{i^T}Ru^{i^T}
 $$&lt;/p&gt;

&lt;p&gt;Goal:
    - Bring the system to a setpoint and keep it there
    - Note: this an also be did with a nonlinear system by a local linearization&lt;/p&gt;

&lt;p&gt;$$
  \begin{aligned}
 V^&lt;em&gt;_i(X&lt;em&gt;i) &amp;amp; = \mathop{arg min}&lt;/em&gt;{u_i\in u(x_i)}{{L(x^i, u^i, \alpha) + V^&lt;/em&gt;&lt;em&gt;{i+1}x&lt;/em&gt;{(i+1)}}} &lt;br /&gt;
   &amp;amp; = \mathop{arg min}_{u_i\in u(x&lt;em&gt;i)}{{x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^*&lt;/em&gt;{i+1}x&lt;em&gt;{(i+1)}}} &lt;br /&gt;
   &amp;amp; = \mathop{arg min}&lt;/em&gt;{u_i\in u(x&lt;em&gt;i)}{{x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^*&lt;/em&gt;{i+1}(Ax^n + Bu^n)}} &lt;br /&gt;
  \end{aligned}
$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;As A linear control law expressed as:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$
    u^{i^*} = -K^ix^i
$$&lt;/p&gt;

&lt;p&gt;Rewrite the optimal cost at stage i as a quadratic form:&lt;/p&gt;

&lt;p&gt;$$
    {V^i}^* = {x^i}^TP^ix^i
$$&lt;/p&gt;

&lt;p&gt;Thus,&lt;/p&gt;

&lt;p&gt;$$
   V^&lt;em&gt;_i(X&lt;em&gt;i) = \mathop{arg min}&lt;/em&gt;{u_i\in u(x_i)}{ {x^{i^T}Qx^i + u^{i^T}Ru^{i^T} + V^&lt;/em&gt;_{i+1}(Ax^n + Bu^n)} } &lt;br /&gt;
$$&lt;/p&gt;

&lt;h2 id=&#34;finite-horizon-approximation&#34;&gt;Finite horizon approximation&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;motion-predictive-control&#34;&gt;Motion Predictive Control&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;fast-mpc&#34;&gt;Fast MPC&lt;/h2&gt;

&lt;p&gt;To be continued&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://pineal.github.com/posts/binary_tree/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_tree/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;h3 id=&#34;concepts&#34;&gt;Concepts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Binary Tree: 全部都填满的树。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Complete Binary Tree: 除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Balanced Binary Tree: 左右子树的高度最多差1. Height of the tree: $O(log(n))$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary Search Tree: Recursively, Leftsubtree is smaller than root and righ subtree is larger than root. Inorder traverse is increasing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;traverse&#34;&gt;Traverse&lt;/h2&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preorder: 8-&amp;gt;3-&amp;gt;1-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;10-&amp;gt;14-&amp;gt;13&lt;/li&gt;
&lt;li&gt;Inorder:  1-&amp;gt;3-&amp;gt;4-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;10-&amp;gt;13-&amp;gt;14&lt;/li&gt;
&lt;li&gt;Postorder: 1-&amp;gt;4-&amp;gt;7-&amp;gt;6-&amp;gt;3-&amp;gt;13-&amp;gt;14-&amp;gt;10-&amp;gt;8&lt;/li&gt;
&lt;li&gt;Levelorder: 8-&amp;gt;3-&amp;gt;10-&amp;gt;1-&amp;gt;6-&amp;gt;14-&amp;gt;4-&amp;gt;7-&amp;gt;13&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traverse-recursively&#34;&gt;Traverse Recursively&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void helper(TreeNode* node, vector&amp;lt;int&amp;gt; &amp;amp; rst){
    if (node != nullptr){
//      rst.emplace_back(root -&amp;gt; val);  If it is PreOder
        helper(node -&amp;gt; left, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is InOrder
        helper(node -&amp;gt; right, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is PostOrder
    }
}
vector&amp;lt;int&amp;gt; DFS_Traversal(TreeNode* root) {
    // write your code here
    vector&amp;lt;int&amp;gt; rst;
    helper(root, rst);
    return rst;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;preorder-iterative&#34;&gt;Preorder iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s, vector&amp;lt;int&amp;gt; &amp;amp; res) {
    while (root) {
        res.emplace_back(root-&amp;gt;val);
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; preorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s, res);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        cur = cur-&amp;gt;right;
        pushleft(cur, s, res);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inorder-iterative&#34;&gt;Inorder Iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s) {
    while (root) {
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; inorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        res.emplace_back(cur-&amp;gt;val);
        cur = cur-&amp;gt;right;
        pushleft(cur, s);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-i&#34;&gt;Postorder iterative I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s1, s2;
    s1.push(root);
    while (!s1.empty()) {
        auto cur = s1.top();
        s2.push(cur);
        s1.pop();
        if (cur-&amp;gt;left) {
            s1.push(cur-&amp;gt;left);
        }
        if (cur-&amp;gt;right) {
            s1.push(cur-&amp;gt;right);
        }
    }
    while (!s2.empty()) {
        auto cur = s2.top();
        s2.pop();
        res.emplace_back(cur-&amp;gt;val);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-ii&#34;&gt;Postorder iterative II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorderII(TreeNode* root) {
    if (root == nullptr) {
        return {};
    }
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    s.push(root);
    TreeNode* prev = nullptr;
    while (!s.empty()) {
        auto cur = s.top();
        if (prev == nullptr || cur == prev-&amp;gt;left || cur == prev-&amp;gt;right) {
            if (cur-&amp;gt;left) {
                s.push(cur-&amp;gt;left);
            }
            else if (cur-&amp;gt;right) {
                s.push(cur-&amp;gt;right);
            }
            else {
                s.pop();
                res.emplace_back(cur-&amp;gt;val);
            }
        }
        else if (prev == cur-&amp;gt;right || prev == cur-&amp;gt;left &amp;amp;&amp;amp; cur-&amp;gt;right == nullptr) {
            s.pop();
            res.emplace_back(cur-&amp;gt;val);
        }
        else {
            s.push(cur-&amp;gt;right);
        }
        prev = cur;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bfs-level-order&#34;&gt;BFS level order&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    if (root == nullptr) return rst;

    queue&amp;lt;TreeNode*&amp;gt; nodes;
    nodes.push(root);

    while(!nodes.empty()){
        vector&amp;lt;int&amp;gt; level;
        int size = nodes.size();
        for (int i = 0; i &amp;lt; size; i++){
            TreeNode* node = nodes.front();
            nodes.pop();
            level.emplace_back(node -&amp;gt; val);
            if (node -&amp;gt; left != nullptr) nodes.push(node -&amp;gt; left);
            if (node -&amp;gt; right != nullptr) nodes.push(node -&amp;gt; right);    
        }
        rst.emplace_back(level);
    }
return rst;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;morris-traverse-todo&#34;&gt;Morris Traverse(TODO)&lt;/h3&gt;

&lt;h2 id=&#34;binary-tree-iterator&#34;&gt;Binary Tree Iterator&lt;/h2&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/d600d536acf50c6d3299e99b200a4c247b79ece7/Binary_Tree/Binary_Tree_Iterator.cpp&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bst-iterator&#34;&gt;BST iterator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BSTIterator {
private:
    stack&amp;lt;TreeNode*&amp;gt; s;
public:
    BSTIterator(TreeNode *root) {
        while (root) {
            s.push(root);
            root = root -&amp;gt; left;
        }
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !s.empty();
    }

    /** @return the next smallest number */
    //which means ascending order
    //which means inoredr traversal
    int next() {
        if (s.empty()) {
            return INT_MAX;
        }
        
        TreeNode* parent = s.top();
        s.pop();
        TreeNode* cur = parent -&amp;gt; right;
        while (cur) {
            s.push(cur);
            cur = cur -&amp;gt; left;
        }
        return parent -&amp;gt; val;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;different-views-of-tree&#34;&gt;Different views of tree&lt;/h2&gt;

&lt;h3 id=&#34;boundary-of-binary-tree&#34;&gt;Boundary of Binary Tree&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;int&amp;gt; boundaryOfBinaryTree(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector&amp;lt;int&amp;gt; left, right, bottom, res;
        res.emplace_back(root-&amp;gt;val);
        getLeft(root-&amp;gt;left, left);
        getBottom(root-&amp;gt;left, bottom);
        getBottom(root-&amp;gt;right, bottom);
        getRight(root-&amp;gt;right, right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), bottom.begin(), bottom.end());
        res.insert(res.end(), right.rbegin(), right.rend());
        return res;
    }
private:    
    void getLeft(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;left) {
            getLeft(root-&amp;gt;left, res);
        }
        else {
            getLeft(root-&amp;gt;right, res);    
        }
    }
    
    void getRight(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;right) {
            getRight(root-&amp;gt;right, res);
        } 
        else {
            getRight(root-&amp;gt;left, res);
        }
    }
    
    void getBottom(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            res.emplace_back(root-&amp;gt;val);
        }
        getBottom(root-&amp;gt;left, res);
        getBottom(root-&amp;gt;right, res);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;path-problems&#34;&gt;Path problems&lt;/h2&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-i&#34;&gt;Maximum Path Sum Binary Tree I&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from one leaf node to another leaf node. If there is no such path available, return INT_MIN (C++).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
 int global_max = INT_MIN;
 
  int maxPathSum(TreeNode* root){
    dfs(root);
    return global_max;
  }
 
  int dfs(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
  
    int left =  dfs(root -&amp;gt; left);
    int right = dfs(root -&amp;gt; right);

    if (root -&amp;gt; left &amp;amp;&amp;amp; root -&amp;gt; right) {
      int sum = left + right + root -&amp;gt; value;
      global_max = max(sum, global_max);
      return max(left, right) + root -&amp;gt; value;
    } 
      return (!root -&amp;gt; left)? right + root -&amp;gt; value : left + root -&amp;gt; value;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-ii&#34;&gt;Maximum Path Sum Binary Tree II&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from any node to any node &lt;strong&gt;(the start node and the end node can be the same)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);    
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    //left = (left &amp;lt; 0)? 0 : left;
    //right = (right &amp;lt; 0)? 0 : right; 
    global_max = max(global_max, left + right + root -&amp;gt; value);
    return max(0, max(left, right) + root -&amp;gt; value); 
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-iii&#34;&gt;Maximum Path Sum Binary Tree III&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number.
Find the maximum possible subpath sum&lt;strong&gt;(both the starting and ending node of the subpath should be on the same path from root to one of the leaf nodes, and the subpath is allowed to contain only one node)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    int sum = max(max(left, right) , 0) + root -&amp;gt; value;
    global_max = max(global_max, sum);
    return sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lca-problems&#34;&gt;LCA problems&lt;/h2&gt;

&lt;h3 id=&#34;lca-i&#34;&gt;LCA I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root -&amp;gt; left, p, q);
        TreeNode* right = lowestCommonAncestor(root -&amp;gt; right, p, q);
        if (left &amp;amp;&amp;amp; right) {
            return root;
        }
        return left? left : right;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-of-bst&#34;&gt;LCA of BST&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return root;
        // p, q are in two sides or root is one of p, q
        } else if ((root-&amp;gt;val - p-&amp;gt;val) * (root-&amp;gt;val - q-&amp;gt;val) &amp;lt;= 0) {
            return root;
        //p,q are smaller than root =&amp;gt; both in left side
        } else if (root-&amp;gt;val &amp;gt; p-&amp;gt;val &amp;amp;&amp;amp; root -&amp;gt; val &amp;gt; q-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;left, p, q);
        //both in right side
        } else {
            return lowestCommonAncestor(root-&amp;gt;right, p, q);            
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-ii&#34;&gt;LCA II&lt;/h3&gt;

&lt;p&gt;Give the treenode with parent pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//class TreeNodeP {
// public:
//  int value;
//  TreeNodeP* left;
//  TreeNodeP* right;
//  TreeNodeP* parent;
//  TreeNodeP(int v, TreeNodeP* p) 
//      : value(v), left(NULL), right(NULL), parent(p) {}
//};

class Solution {
private:
 int path_length(TreeNodeP* node) {
   int length = 0;
   while (node) {
     node = node -&amp;gt; parent;
     length++;
   }
   return length;
 }
 
 TreeNodeP* llc(TreeNodeP* small, TreeNodeP* large, int diff) {
   while (diff &amp;gt; 0) {
     large = large -&amp;gt; parent;
     diff--;
   }
   while (large != small) {
     large = large -&amp;gt; parent;
     small = small -&amp;gt; parent;
   }
   return large;
 }
 public:
  TreeNodeP* LCA(TreeNodeP* one, TreeNodeP* two) {
    int l1 = path_length(one);
    int l2 = path_length(two);
    if (l1 &amp;lt;= l2) {
      return llc(one, two, l2 - l1);
    } else {
      return llc(two, one, l1 - l2);
    }
  }
  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iii&#34;&gt;LCA III&lt;/h3&gt;

&lt;p&gt;Given two nodes in a binary tree, find their lowest common ancestor (the given two nodes are not guaranteed to be in the binary tree). Return null If any of the nodes is not in the tree. There is no parent pointer for the nodes in the binary tree. The given two nodes are not guaranteed to be in the binary tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  bool flag1 = false;
  bool flag2 = false;
  TreeNode* solve(TreeNode* root, TreeNode* one, TreeNode* two) {
  
    traversal(root, one, two);
    if (flag1 &amp;amp;&amp;amp; flag2) {
      return findLCA(root, one, two);
    } 
    return nullptr;
  }
  void traversal(TreeNode* root, TreeNode* one, TreeNode* two) {
    if (root == nullptr) {
      return;
    }
    if (root == one) {flag1 = true;}
    if (root == two) {flag2 = true;}
    traversal(root -&amp;gt; left, one, two);
    traversal(root -&amp;gt; right, one, two);
  }
  TreeNode* findLCA(TreeNode* root, TreeNode* one, TreeNode* two) {
   
    if (root == nullptr) {
      return nullptr;
    }
    
    if (root == one) {
      return root;
    }
    
    if (root == two) {
      return root;
    }
    
    auto left =  findLCA(root -&amp;gt; left,  one, two);
    auto right = findLCA(root -&amp;gt; right, one, two);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else if (left) {
      return left;
    } else if (right) {
      return right;
    } else {
      return nullptr;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iv&#34;&gt;LCA IV&lt;/h3&gt;

&lt;p&gt;Give k nodes, find their CLA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* LCA(TreeNode* root, vector&amp;lt;TreeNode*&amp;gt; nodes) {
    if (root == nullptr) {
      return root;
    }
    
    for (int i = 0; i &amp;lt; nodes.size(); i++) {
      if (root == nodes[i]) {
        return root;
      }
    }
    
    auto left = LCA(root -&amp;gt; left, nodes);
    auto right = LCA(root -&amp;gt; right, nodes);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else {
      return left? left : right;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-if-cousins&#34;&gt;Check if cousins&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/check-two-nodes-cousins-binary-tree/&#34;&gt;Geeksforgeeks source&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkIfCousins(TreeNode* root, TreeNode* one, TreeNode* two) {
  
  bool res = false;
  helper(root, one, two, 0, res);
  return res;
}

//return target&#39;node level
//return -1 is not found
int helper(TreeNode* root, TreeNode* one, TreeNode* Two, int level, bool &amp;amp; res) {

  if (root == nullptr) {
    return -1;
  }

  if (root == one || root == two) {
    return level;
  }

  int left = helper(root-&amp;gt;left, one, two, level + 1, res);
  int right = helper(root-&amp;gt;right, one, two, level + 1, res);

  if (left == right &amp;amp;&amp;amp; left - 1 &amp;gt; level) {
    res = true;
  }
  return max(left, right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serialize-and-deserialize-binary-tree&#34;&gt;Serialize and deserialize binary tree&lt;/h2&gt;

&lt;h3 id=&#34;reconstruct-binary-tree-with-preorder-and-inorder&#34;&gt;Reconstruct Binary Tree With Preorder And Inorder&lt;/h3&gt;

&lt;p&gt;一棵树需要什么信息？需要知道什么是根，左子树和右子树分别又是什么。&lt;/p&gt;

&lt;p&gt;那么从这两种遍历之中可以获取什么信息？&lt;/p&gt;

&lt;p&gt;先序遍历： root | left subtree | right subtree&lt;/p&gt;

&lt;p&gt;中序遍历： left subtree | root | right subtree&lt;/p&gt;

&lt;p&gt;先序遍历的最左边，一定是根，但是无法找到左子树和右子树的分界点；但是可以通过找到根，从而从中序遍历中找到这个分界。&lt;/p&gt;

&lt;p&gt;解题步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;leftmost of preOrder must be root&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find position of root in inOrder =&amp;gt; need a hashtable to pre-store indices&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: left side of root is left subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: right side of root is right subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;recursively solve the problem on left subtree and right subtree&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; pre) {
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    
    return helper(in, 0, in.size() - 1, pre, 0, table);
  }
  
  TreeNode* helper(const vector&amp;lt;int&amp;gt; &amp;amp; in, int in_left, int in_right, 
                   const vector&amp;lt;int&amp;gt; &amp;amp; pre, int pre_left,
                    unordered_map&amp;lt;int, int&amp;gt; table) {
                      
    if (in_left &amp;gt; in_right) {
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(pre[pre_left]);
    int index = table[root -&amp;gt; value];
    root -&amp;gt; left = helper(in, in_left, index - 1, pre, pre_left + 1, table);
    root -&amp;gt; right = helper(in, index + 1, in_right, pre, pre_left + index - in_left + 1, table);
    return root;                  
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-with-level-order&#34;&gt;Reconstruct with level order&lt;/h3&gt;

&lt;p&gt;level order 的第一个元素，一定是root。通过inorder找到root的位置，然后根据index的关系，分割左右子树。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; level) {
    map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    return helper(level, table);
  }
  TreeNode* helper(vector&amp;lt;int&amp;gt; level, map&amp;lt;int, int&amp;gt; table) {
    if (level.size() == 0) {
      return nullptr;
    }
    TreeNode* root = new TreeNode(level[0]);
    int index = table[root-&amp;gt;value];
    vector&amp;lt;int&amp;gt; left;
    vector&amp;lt;int&amp;gt; right;
    
    for (int i = 0; i &amp;lt; level.size(); i++) {
      if (table[level[i]] &amp;lt; index) {
        left.emplace_back(level[i]);
      } else if (table[level[i]] &amp;gt; index) {
        right.emplace_back(level[i]);
      }
    }
    root -&amp;gt; left = helper(left, table);
    root -&amp;gt; right = helper(right, table);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-binary-search-tree-with-postorder-traversal&#34;&gt;Reconstruct Binary Search Tree With Postorder Traversal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; post) {
    //Post order -&amp;gt; [leftsubtree][rightsubtree]root =&amp;gt; determine the position of root
    //In   order -&amp;gt; [left]root[right] =&amp;gt;recursively find left and right parts
    vector&amp;lt;int&amp;gt; in(post);
    sort(in.begin(), in.end());
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
        table[in[i]] = i;
    }
    return helper(in, post, table, post.size() - 1, 0, in.size() - 1);
  }
  
  TreeNode* helper(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; post, unordered_map&amp;lt;int, int&amp;gt; &amp;amp; table,
                    int post_right, int in_left, int in_right) {
  
    if (in_left &amp;gt; in_right){
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(post[post_right]);
    int index = table[root -&amp;gt; value];
    
    root -&amp;gt; right = helper(in, post, table, post_right - 1, index + 1, in_right);
    root -&amp;gt; left = helper(in, post, table, post_right - 1 - (in_right - index), in_left, index - 1);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string order;
        inorderDFS(root, order);
        return order;
    }
    
    inline void inorderDFS(TreeNode* root, string&amp;amp; order) {
        if (!root) return;
        char buf[4];
        memcpy(buf, &amp;amp;(root-&amp;gt;val), sizeof(int)); //burn the int into 4 chars
        for (int i=0; i&amp;lt;4; i++) order.push_back(buf[i]);
        inorderDFS(root-&amp;gt;left, order);
        inorderDFS(root-&amp;gt;right, order);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int pos = 0;
        return reconstruct(data, pos, INT_MIN, INT_MAX);
    }
    
    inline TreeNode* reconstruct(const string&amp;amp; buffer, int&amp;amp; pos, int minValue, int maxValue) {
        if (pos &amp;gt;= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.
        
        int value;
        memcpy(&amp;amp;value, &amp;amp;buffer[pos], sizeof(int));
        if (value &amp;lt; minValue || value &amp;gt; maxValue) return NULL;
        
        TreeNode* node = new TreeNode(value);
        pos += sizeof(int);
        node-&amp;gt;left = reconstruct(buffer, pos, minValue, value);
        node-&amp;gt;right = reconstruct(buffer, pos, value, maxValue);
        return node;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-doubly-linked-list-from-a-ternary-tree&#34;&gt;Create a Doubly Linked List from a Ternary Tree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/create-doubly-linked-list-ternary-ree/&#34;&gt;Question source&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;difference-between-dfs-and-bfs&#34;&gt;Difference between DFS and BFS&lt;/h3&gt;

&lt;p&gt;DFS using stacks, and BFS using queues if Non-Recursion&lt;/p&gt;

&lt;h3 id=&#34;difference-between-recursion-and-non-recursion&#34;&gt;Difference between Recursion and Non-Recursion&lt;/h3&gt;

&lt;p&gt;Recursion is dangerous when memory resource is limited: stack may overflow;
However Non-Recursion method occupies more space&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://pineal.github.com/posts/binary_search/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_search/</guid>
      <description>

&lt;h2 id=&#34;经典二分搜索及其变种&#34;&gt;经典二分搜索及其变种&lt;/h2&gt;

&lt;p&gt;二分搜索的核心思想是，在给定的搜索空间内，排除掉一定不对的那一部分。应用场景往往是有序的，或者局部有序的。这样从n可以优化到logn。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int classic_binary_search(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty()) {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt;= right){
      int mid = left + (right - left)/2;
      if (input[mid] == target){
        return mid;
      }
      else if (input[mid] &amp;lt; target) {
        left = mid + 1;
      }
      else {
        right = mid - 1;
      }
    }
    return -1;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_first_index(vector&amp;lt;int&amp;gt; input, int target) {
    // Write your solution here
    if (input.size() == 0) return -1;
    int left = 0, right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt; input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[left] == target){
      return left;
    }
    else if (input[right] == target) {
      return right;
    }
    else
      return -1;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int find_last_index(vector&amp;lt;int&amp;gt; input, int target) {
    if (input.empty())  {
      return -1;
    }
    int left = 0;
    int right = input.size() - 1;
    while (left &amp;lt; right - 1){
      int mid = left + (right - left)/2;
      if (target &amp;gt;= input[mid]){
        left = mid;
      }
      else {
        right = mid;
      }
    }

    if (input[right] == target) {
      return right;
    }
    else if (input[left] == target) {
      return left;
    }
    else {
      return -1;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二维二分搜索&#34;&gt;二维二分搜索&lt;/h2&gt;

&lt;h3 id=&#34;search-a-2d-matrix&#34;&gt;Search a 2D Matrix&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix/&#34;&gt;Problem Link from Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从左到右递增，下一行的开头一定比上一行的末尾大。那么就可以转化为一维的二分搜索。考点在二维矩阵到一维矩阵的变换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
  int left = 0;
  int right = matrix.size() * matrix[0].size() - 1;
  while (left &amp;lt;= right) {
    int mid = left + (right - left) / 2;
    int i = mid / matrix[0].size();
    int j = mid % matrix[0].size();
    if (matrix[i][j] == target) {
      return true;
    } else if (target &amp;gt; matrix[i][j]) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;search-a-2d-matrix-ii&#34;&gt;Search a 2D matrix II&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/search-a-2d-matrix-ii/&#34;&gt;Problem Link from Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从左往右一定递增，从上到下一定递增。跟之前一题相比，这里的二维矩阵并不能保证转化成一维递增的矩阵。
如果从左上角开始往右下角搜索，那么有多种可能，刚开始用的是分治法，把矩阵分成四块，由于这个矩形的性质，我们只能排除掉一块，然后往三块可能的继续搜。时间复杂度为$O(n^{1.58})$, 参考分治法时间复杂度分析公式.
但如果从右上角往左下角搜，那么可以保证向左一定是递减的，向下一定是递增的，那么可以排除掉特定行或者特定列。这样的时间复杂度出来的是$O(m + n)$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) {
	int m = matrix.size();
	if (m == 0) return false;
	int n = matrix[0].size();
	int i = 0, j = n - 1;
	while (i &amp;lt; m &amp;amp;&amp;amp; j &amp;gt;= 0) {
		if (matrix[i][j] == target)
			return true;
		else if (matrix[i][j] &amp;gt; target) {
			j--;
		} else
			i++;
	}
	return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;advanced-using-binary-search-to-solve-kth-problem&#34;&gt;Advanced - using binary search to solve kth problem&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/&#34;&gt;https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Follow up:&lt;a href=&#34;https://leetcode.com/problems/find-k-closest-elements/&#34;&gt;https://leetcode.com/problems/find-k-closest-elements/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/&#34;&gt;https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Follow up: find kth smallest element in m sorted arrays&lt;/p&gt;

&lt;h3 id=&#34;more-questions&#34;&gt;More questions&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/&#34;&gt;https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/&#34;&gt;https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dynamic programming and binary search (TONY)&lt;/p&gt;

&lt;p&gt;LIS &lt;a href=&#34;https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/&#34;&gt;https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/&lt;/a&gt;
Russian Doll Envelopes&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kalman Filter</title>
      <link>https://pineal.github.com/posts/kalman_filter/</link>
      <pubDate>Tue, 24 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/kalman_filter/</guid>
      <description>

&lt;h2 id=&#34;purpose-and-usage&#34;&gt;Purpose and Usage&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Eliminate noise in measurements&lt;/li&gt;
&lt;li&gt;Generate non-observable states(e.g., Velocity from position signals)&lt;/li&gt;
&lt;li&gt;For prediction of future state&lt;/li&gt;
&lt;li&gt;Optimal filtering&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;framework-and-model&#34;&gt;Framework and Model&lt;/h2&gt;

&lt;h3 id=&#34;given&#34;&gt;Given:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A discrete stochastic linear controlled dynamical system:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$x_k = Ax_{k-1} + Bu_{k-1} + w_{k-1}$$&lt;/p&gt;

&lt;p&gt;Each current signal value $x^k$ is a combination of previous signal value $x_{k-1}$ times a constant, a control signal $u_{k}$ and a process noise and a process noise signal $w_{k-1}$ (which usually considered as zero).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A measurement function, where $v_{k}$ is the measurement noise.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$ y_{k} = Hx_{k} + v_{k} $$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Assume the process noise and the measurement noise are both considered to be normal distribution that&lt;/p&gt;

&lt;p&gt;$$ p(w) \sim N (0, Q), $$&lt;/p&gt;

&lt;p&gt;$$ p(v) \sim N (0, R). $$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In reality, covariance matrix $Q$ and $R$ may change in every iteration. We assume they are constant here however.&lt;/p&gt;

&lt;h3 id=&#34;goal&#34;&gt;Goal:&lt;/h3&gt;

&lt;p&gt;Find the best (recursive) estimate of the state $x$ of the system.&lt;/p&gt;

&lt;h3 id=&#34;computational-origins&#34;&gt;Computational Origins&lt;/h3&gt;

&lt;p&gt;Define $e_{k}^{-}$ to be a priori state estimate at step k given knowledge of the process prior to step $k$, and define $e_{k}$  to be a posteriori state estimate at step $k$ given measurement $z_{k}$. Then a priori and a posteriori estimate errors can be defined as:&lt;/p&gt;

&lt;p&gt;$$e_{k}^{-} \equiv x_{k} - \hat{x}_{k}^{-}$$&lt;/p&gt;

&lt;p&gt;$$e_{k} \equiv x_{k} - \hat{x}_{k}$$&lt;/p&gt;

&lt;p&gt;The a priori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k}^{-} = E[e_{k}^{-}e_{k}^{-T}]$$&lt;/p&gt;

&lt;p&gt;The a posteriori estimate error covariance is then&lt;/p&gt;

&lt;p&gt;$$P_{k} = E[e_{k}e_{k}^{T}]$$&lt;/p&gt;

&lt;p&gt;Then How can we optimally (linearly) combine the estimate and measurement to obtain the best reconstruction of ￼the true x?&lt;/p&gt;

&lt;p&gt;The answer given in “The Probabilistic Origins of the Filter” found.&lt;/p&gt;

&lt;p&gt;$$
   \hat{x} = \hat{x}_{k}^{-} - K \times residual
$$&lt;/p&gt;

&lt;p&gt;Where &lt;em&gt;residual&lt;/em&gt; is $z_k - H \hat{x}_{k}^{-}$. It also can be called as measurement innovation.&lt;/p&gt;

&lt;p&gt;The Kalman filter gains are derived by minimizing the posterior error covariance, resulting in&lt;/p&gt;

&lt;p&gt;$$K_k = \frac{P_k^-H^T}{(HP_k^-H^T + R)^{-1}}$$&lt;/p&gt;

&lt;p&gt;If the a priori estimate of the process noise is zero, Then&lt;/p&gt;

&lt;p&gt;$$K = 0$$&lt;/p&gt;

&lt;p&gt;If the measurement noise is zero&lt;/p&gt;

&lt;p&gt;$$K = H^{-1}$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linear Programming</title>
      <link>https://pineal.github.com/posts/linear_programming/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/linear_programming/</guid>
      <description>&lt;p&gt;$$\matrix{A} \times \matrix{X} = \matrix{B}  $$&lt;/p&gt;

&lt;p&gt;Coeffienent matrix&lt;/p&gt;

&lt;p&gt;A =&amp;gt; n * n, x vector of unknowns, B right hand side&lt;/p&gt;

&lt;p&gt;Linear system of equations.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;$$A \times X ≥ B$$&lt;/p&gt;

&lt;p&gt;Objective function&lt;/p&gt;

&lt;p&gt;$$C^T \times X $$&lt;/p&gt;

&lt;p&gt;linear&lt;/p&gt;

&lt;p&gt;Goal : Minimize the objective function&lt;/p&gt;

&lt;p&gt;E.g.:
$$
\cases{x1 - x2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x1 + x2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;Maximize
$x1 + 2x_2$&lt;/p&gt;

&lt;p&gt;###Simplex method
Only look at the vertex&lt;/p&gt;

&lt;p&gt;Start of one vertex, go clockwise, find the max before the value going down&lt;/p&gt;

&lt;p&gt;###Weighted vertex cover problem&lt;/p&gt;

&lt;p&gt;for G = (V, E), S $\in$ V in a set such that each edge has at least one end in S $W_i ≥ 0$ for each i $\in$ V $$W(S) = \sum i \in S w_i$$&lt;/p&gt;

&lt;p&gt;Objective: Minimize W(S)&lt;/p&gt;

&lt;p&gt;Model this as an LP&lt;/p&gt;

&lt;p&gt;x_i is a decision valuable for each node i \in V&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_1 - x_2 ≥ 0 \&lt;br /&gt;
x_1 ≥ 0 \&lt;br /&gt;
x_2 ≥ 0 \&lt;br /&gt;
x_1 + x_2 ≤ 4
}$$&lt;/p&gt;

&lt;p&gt;$$
\cases{
x_i = 0 &amp;amp; i \notin S \&lt;br /&gt;
x_i = 1 &amp;amp; i \in S
}
$$&lt;/p&gt;

&lt;p&gt;x_i + x_j ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;Minimize \sigma w_ix_i
Subject to
$x_i + x_j ≥ 1 for (i, j) \in E$
$x_i \in {0,1} for i \in V$  &amp;lt;= discreate&lt;/p&gt;

&lt;p&gt;Integer Programming&lt;/p&gt;

&lt;p&gt;Linear programming  (continues variables)
Integer Programming (discrete variables)
mixed integer programming&lt;/p&gt;

&lt;p&gt;Drop the requirement that x_i \in {0,1}
and solve the LP in poly time and find {x_i^*} between 0 and 1&lt;/p&gt;

&lt;p&gt;so that x_i^* + x_j^* ≥ 1 for each edge&lt;/p&gt;

&lt;p&gt;W_{LP} = \sigma w_ix_i^*&lt;/p&gt;

&lt;p&gt;S^* is the opt vertex cover set
W(S^*) = weight of the opt solution&lt;/p&gt;

&lt;p&gt;W(S^*) ≥ W_{LP}&lt;/p&gt;

&lt;p&gt;S is our approx. solution&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W&lt;em&gt;{LP}
W&lt;/em&gt;{LP} ≤ 2 * W(s^*)&lt;/p&gt;

&lt;p&gt;W(S) ≤ 2 * W(S^*)&lt;/p&gt;

&lt;p&gt;Solve the max. flow problem using LP. Variable are flow over edges.&lt;/p&gt;

&lt;p&gt;Maximize \sigma f{e}
subject to
0 ≤ f(e) ≤ c_e foe each edge e \in E
\sigma f(e) - \sigma f(e) = 0 for v \in V&lt;/p&gt;

&lt;p&gt;A = B
A - B ≥ 0
B - A ≥ 0&lt;/p&gt;

&lt;p&gt;Max flow with lower bounds on flow over the edges
objective function stays same
conservation of the flow stays same&lt;/p&gt;

&lt;p&gt;Cap constraint: l_e≤f(e)≤c_e for each edge e \in E&lt;/p&gt;

&lt;p&gt;###Multi commodity flow
f_i(e): flow of commodity i over edge e
\alpha_i: is the profit associated with one unit of flow for commodity i.&lt;/p&gt;

&lt;p&gt;We have m commodities&lt;/p&gt;

&lt;p&gt;Objective: maximize profit&lt;/p&gt;

&lt;p&gt;Maximize $\sigma&lt;em&gt;{l=i}^m \sigma&lt;/em&gt;{eoutofS} \alpha_i f_i(e)$&lt;/p&gt;

&lt;p&gt;subject to 0 ≤ \sigma_{i=1}^m f&lt;em&gt;i{e} ≤c&lt;/em&gt;{e} for each e \in E&lt;/p&gt;

&lt;p&gt;\sigma_{i=1}^m f&lt;em&gt;i{e} = \sigma&lt;/em&gt;{i=1}^m f_i{e} for each node v \in V and for each i = 1 to m&lt;/p&gt;

&lt;p&gt;###Shortest path using LP
Shortest distance from V to t is d(v) for each node V
For each node V
$$
d(t) ≤ d(y) + c&lt;em&gt;{yt} \&lt;br /&gt;
d(t) ≤ d(w) + c&lt;/em&gt;{wt} \&lt;br /&gt;
d(t) ≤ d(x) + c_{xt} \&lt;br /&gt;
$$&lt;/p&gt;

&lt;p&gt;d&lt;em&gt;{v} ≤ d&lt;/em&gt;{u} + w(u, v) for each edge (u, v) \in E
d(s) = 0&lt;/p&gt;

&lt;p&gt;Objective function:
    Minimize d(t)&lt;/p&gt;

&lt;p&gt;1:36&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>海底捞</title>
      <link>https://pineal.github.com/posts/%E6%B5%B7%E5%BA%95%E6%8D%9E/</link>
      <pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E6%B5%B7%E5%BA%95%E6%8D%9E/</guid>
      <description>&lt;p&gt;昨晚梦到了自己从纽约秋日的街头穿越回1993年的冰岛，&lt;br/&gt;
只是通过一本神秘的皮革封面的似乎无尽的书。&lt;br/&gt;
在天然冰镇伏特加的陪伴下享受如舞池灯般的极光。&lt;br/&gt;
我觉得变换的速度有点应接不暇，于是来到奥斯陆的一艘潜艇中。&lt;br/&gt;
忽的进入了战地模式。可是炮弹又怎能在海底炸出土来。&lt;br/&gt;
最后竟然在写字楼里签收你寄过来的的大件快递，这么多年。&lt;br/&gt;
我把挂在墙上的地图pin上自己的足迹，&lt;br/&gt;
醒来后我惊异的发现自己对北欧的地理分布怎么能如此熟悉。&lt;br/&gt;
至于是否忘记了从包裹里取出东西，是不是根本不重要，&lt;br/&gt;
也许因为我的手一直枕在你的脖子下。&lt;br/&gt;
这样的梦，也应该就是为何荒芜的 Greenland 听起来生意盎然， &lt;br/&gt;
而可爱的 Iceland 却让人望而却步的缘由。&lt;br/&gt;
想想连名字都这么童话的地方，冰岛。&lt;br/&gt;
难怪有人一定要跟自己爱的人一起去共同度过。&lt;br/&gt;
凛冬将至，群鸦争渡。对了，那本让我穿越的书应该是博尔赫斯写的书里的书，&lt;br/&gt;
即使手感跟我爱罗不太一样，这场景也改切换到神秘而荒诞的南美了吧。&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NP problem</title>
      <link>https://pineal.github.com/posts/np_problem/</link>
      <pubDate>Wed, 12 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/np_problem/</guid>
      <description>&lt;p&gt;##Introduction&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Plan&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Explore the space of computationally hand problem to arrive at a mathematic characteristic a large d of them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Technique&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Compare negative difficultly of different problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Problems can find a polynomial time algorithm to solve.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NP problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;An algorithm that can be verified if it is a solution to a problem or not in polynomial time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loose definition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If problem X in at least as hard as problem Y. It means that if we could solve X, we could also solve Y.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Y X&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Y is polynomial time reduced to X. If Y can be solved using a poly number of std computational steps plus a poly no of called to a black box to love X.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If X can be solved in polynomial time, then Y can be solved in polynomial time.&lt;/li&gt;
&lt;li&gt;Suppose $Y ≤_p X$. If Y cannot be solved in polynomial time, then X cannot be solved in polynomial time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NP-Complete Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is NPC problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prove it is a NP problem.&lt;/li&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;NP hard Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prove a problem X is hard problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find a known NPC problem Y which satisfied $Y ≤_p X$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##Examples&lt;/p&gt;

&lt;p&gt;###Independent Set
Ref: Given a graph $G = (V,E)$, we say a set of nodes, $S \in V$ in independent if no two nodes in S and joined by an edge.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the maximum size independent set in graph G.(Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G and a number k, does G contain an independent set of size at least K.(Decision version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ans: No solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Vertex Cover
Ref: Given a $graph G=(V,E)$ we say that a set of nodes $S \in V$ in a vertex cover if every edge $e \in E$ has at least one end in S.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Find the smallest vertex cover set in G (Optimization version)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a graph G=(V,E) and a number k, G contain a vertex cover of size at most k.(Decision version)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Independent Set and Vertex Cover&lt;/p&gt;

&lt;p&gt;FACT: let G=(V,E) be a graph then S in an independent set if and only if its complement (V-S) is a vertex cover.&lt;/p&gt;

&lt;p&gt;S is an independent set.&lt;/p&gt;

&lt;p&gt;**case 1 **&lt;/p&gt;

&lt;p&gt;U is in S and V is not.
V-S will have V and not U.&lt;/p&gt;

&lt;p&gt;case 2
V is in S and U is not.
V-S will have U and not V&lt;/p&gt;

&lt;p&gt;case 3
Neither V or U are in the set&lt;/p&gt;

&lt;p&gt;Suppose V-S is a vertex cover can prove that S is an independent set.&lt;/p&gt;

&lt;p&gt;Claim: independent Set≤P vertex Cover
Prove If we have a black box to solve the vertex cover problem. We can decide if G has independent set of size at least k by asking the black box if G has a vertex cover of size at most n-k.&lt;/p&gt;

&lt;p&gt;Claim: Vertex cover ≤S independent Set&lt;/p&gt;

&lt;p&gt;Proof: if we have a black box to solve the independent set we can deicide if G has a vertex cover of size at most k by asking the black box if G has an independent set of size at least n-k.&lt;/p&gt;

&lt;p&gt;Set cover problem
Given a set U of n elements, a collection s_1 to s_m of sub sets of U and and a number of k, does there exist a collection of at most k of these sets whose union is equal to all of U.&lt;/p&gt;

&lt;p&gt;Set U = set of all edges in G
S1 = {(1, 2), (1,3)}
S2 = {(1,2), (2,3), (2,4), (2,5)}&lt;/p&gt;

&lt;p&gt;Proof of correction:
A) If we have a vertex cover of size k in G, then i can find a collection of k sets whose union is equal to all of U.
B) If I have a collection of k sets, whose union is equal to all of U, then I can find a vertex cover of size k in G.&lt;/p&gt;

&lt;p&gt;Given u bolean variable x1&amp;hellip;xn a&lt;/p&gt;

&lt;p&gt;a truth assignment fox X is an assignment of values 0 or 1 to each x_i&lt;/p&gt;

&lt;p&gt;An assignment satisfies a change C if it causes C to evaluate 1.&lt;/p&gt;

&lt;p&gt;An assignment satisfies a collection of if C1 and C2 and &amp;hellip; CK evaluate to 1.&lt;/p&gt;

&lt;p&gt;Given a set of closures C1 to Ck over a set of variables x - {x1, &amp;hellip; xn} does there exist a satisfying truth&lt;/p&gt;

&lt;p&gt;Problem statement
Given a set of&lt;/p&gt;

&lt;p&gt;Three set problem
Given an&lt;/p&gt;

&lt;p&gt;C1 = (x1, x2, x3)&lt;/p&gt;

&lt;p&gt;Efficient Certification&lt;/p&gt;

&lt;p&gt;ex: indenpendent set problem.
certificate is a set of nodes of size at least k.
certifier: go over every edge and check the if they are not both in S the edge is OK.
check the size of set S.&lt;/p&gt;

&lt;p&gt;Evaluate each clause&lt;/p&gt;

&lt;p&gt;If X \in NP and for all Y \in NP&lt;/p&gt;

&lt;p&gt;Is there a problem in NP that all other problem in NP can be reduced to it in polynomial time&lt;/p&gt;

&lt;p&gt;Basic strategy to probe a problem X is NP-complete
1.prove X \in nP
2.choose a problem Y that is known to be NP-complete
3.Prove that Y≤pX&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>22</title>
      <link>https://pineal.github.com/posts/22/</link>
      <pubDate>Sun, 14 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/22/</guid>
      <description>&lt;p&gt;给我两杯冰冻的鲜啤吧，我就会是个满脸胡渣的诗人。&lt;/p&gt;

&lt;p&gt;做一个市井小民吧，坐在皇城脚下，干爽的微风傍晚。&lt;/p&gt;

&lt;p&gt;一起来撸个串吧，Windows 98 的年代转眼已经 Windows 8。&lt;/p&gt;

&lt;p&gt;忘了吹着江风的童年吧，那里没有属于你的玩具。&lt;/p&gt;

&lt;p&gt;想念大不列颠了吧，夏日的夜晚虽然短暂可星空却是那么性感。&lt;/p&gt;

&lt;p&gt;告别你的青春吧，二十二年的电影也不算太长。&lt;/p&gt;

&lt;p&gt;爱着那个姑娘吧，故宫的护城河边的初升的太阳，哦，再来一碗炸酱面。&lt;/p&gt;

&lt;p&gt;还有你的梦想吧，是什么还能让你远走高飞头也不回。&lt;/p&gt;

&lt;p&gt;一起去炸了国家工商总局吧，还有那个颐指气使的方形脸庞画着细眉毛瞪着大眼睛翘着薄嘴唇的像教导主任一样的中国女人。&lt;/p&gt;

&lt;p&gt;你累了吧，你离开吧，做一个良心未泯的，入世的人吧。&lt;/p&gt;

&lt;p&gt;我怀念的，是双熊猫皱纹卫生纸。皱巴巴的还可以是一张五元纸钞，塞进自动售货机，能吐出两听可口可乐，可口可乐包装的那个红色，我一直很想知道它的颜色代码。&lt;/p&gt;

&lt;p&gt;就是这个神奇的感觉。一切都是潮的：地是潮的，空气是潮的，书页是潮的，黄油饼干是潮的，换下的衬衫是潮的，就连耳机线和音乐都不如落地签那么清澈透亮。&lt;/p&gt;

&lt;p&gt;所有看的看不见的都黏糊糊的纠缠在了一起。现在，我最想要的是一听雪碧，喷薄而出的气泡，大口畅饮时喉结的蠕动，以及金属变形和打嗝的快感。&lt;/p&gt;

&lt;p&gt;吃下了同样来自利物浦的帅哥给的糖。波音777上一片漆黑什么都看不见，包装上可辨的只有discount40%， 怀疑糖上粘着纸，吃完后满嘴茴香的味道。&lt;/p&gt;

&lt;p&gt;仿佛如同一场梦，我们如此短暂地相逢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>送我一颗菠菜</title>
      <link>https://pineal.github.com/posts/%E9%80%81%E6%88%91%E4%B8%80%E9%A2%97%E8%8F%A0%E8%8F%9C/</link>
      <pubDate>Fri, 26 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/%E9%80%81%E6%88%91%E4%B8%80%E9%A2%97%E8%8F%A0%E8%8F%9C/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s slip into dreams.——甜如菠菜。&lt;/p&gt;

&lt;p&gt;蒸锅一定是这个世界上最伟大的发明之一。相对于蒸汽机对人类文明的贡献或者毁灭，拥有同样原理的技术却能将味蕾一一摆平还能使享受热腾腾氤氲的每一个皮肤细胞的呼吸作用治理的服服帖帖。 英国人的智商绝不容易将这种天才的技术应用在生活中——他们的局限就在于仅仅贡献了瓦特——这种脑子瓦特的民族的奇怪食物怎么能跟三文鱼沙拉三明治和火腿肠起司面包相媲美。自然，一个烤箱就能解决的世界使得蒸锅的必要性无限趋近于零。英国人更不可能学会炒菜这种更加高级的技能——似乎只有集齐七颗龙珠召唤神龙才有这个可能了——原因在于他们习惯了满嘴sorry和cheers跑出时速被前铁道部完爆的蒸汽式火车，所以怎么可能用炒的嘛。综上所述，黑暗料理界一定会败给中华小当家。我蹑手蹑脚的从锅中取出黄金开口暗戳戳笑：哦，菠菜，只要你蒸蒸切切爱我一遍。&lt;/p&gt;

&lt;p&gt;皮尔洛这厮竟然说：“自轮子之后，人类历史最伟大的发明就是PlayStation”。他和内斯塔一起选巴萨当主队踢实况就跟阿莱格里逼他去尤文留大胡子一样不靠谱。巴塞罗那狂热症可是是有缘由的。除开拉玛西亚影剧院来说，For instance: 西班牙语的音乐是如此的动听，性感的大小舌颤音让人浑身鸡皮疙瘩止不住的颤抖。且不说C罗的最爱Ai Se Eu Te Pego!，你想，在国内公交车上功放爱情买卖的时候，在酒吧门口共舞江南Style的时候，在韩寒把万青听众打入深渊的时候，来一曲Siempre Me Quedará在iphone非主流简约播放器in:play上播放这种事能让逼格瞬间爆棚几倍——直接从绿色的菠菜叶爆到绛红色的菜根，剩余能量还能生出几根诱人的小须须。对了，我也爱田纳西恰恰。&lt;/p&gt;

&lt;p&gt;至于菠菜，&amp;rdquo;菠这种字眼不是那种充满野性的丰满人类专用的么?&amp;ldquo;, 那一个神奇的铁罐中蕴含着来自伊朗高原的高能蔬菜—— 如果最近几周的情况用多巴胺含量来解释的话，一切是那么的通情达理又不失文艺清新范儿。我又对自己完美的借口再一次的感到满意。人总是在不断虚伪的过程中逐渐把平庸的筹码逐渐花光。你说&amp;rdquo;Time Flies, But You are the Piolet.&amp;rdquo; 怎知时光未死，你却已蹒跚老去。不禁思考，能认识到God Complex这种命题本身是否陷入了虚无主义的圈套。“It&amp;rsquo;s too hard to make good mistakes. ”一切总是矛盾的，你想把博文理得逻辑上无懈可击，就会失去意识流般的丝滑柔顺（你又不是德芙巧克力）；你想要努力征服全世界，却发现连自己都无法击败（你又不是鸿星尔克）；你对佳人钦慕不已，炙热如焰却不能悲伤的坐在你身旁（你又不是左小祖咒），你的冷漠却又能被称赞为人奉为圭臬的男人的成熟（你连自己都不是了）——等到菠菜都熟透，一起去看细水长流？也许一切都会是好的，一个三脚猫的工科生却有着蹩脚的文艺情怀——如果哪一天突然发现自己站在了人文和科技的十字路口也无需太过惊讶：我一定会在老乔的墓碑前摆个剪刀手合影留念。&lt;/p&gt;

&lt;p&gt;送你一颗子弹，送我一颗菠菜。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>