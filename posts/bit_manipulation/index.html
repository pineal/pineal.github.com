<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Bit Manipulation</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Bit Manipulation">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Bit Manipulation">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.github.com/posts/bit_manipulation/">
	<meta name="og:site_name" content="Bit Manipulation">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Algorithm Bit Manipulation ">
	<link rel="stylesheet" type="text/css" href="https://pineal.github.comcss/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.github.com" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.github.com/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.github.com/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.github.comindex.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Bit Manipulation <aside><a href="/tags/algorithm/">Algorithm</a></a>&nbsp;&nbsp;&nbsp;<a href="/tags/bit-manipulation/">Bit Manipulation</a></a>&nbsp;&nbsp;&nbsp;</aside></h1>
  

<h1 id="summary-of-basic-bit-manipulation">Summary of Basic Bit Manipulation</h1>

<h2 id="count-1-in-binary">Count 1 in Binary</h2>

<p>数的二进制表示中有多少位1. 有两种方法。</p>

<ol>
<li>每次把各位的数和 1 做 &amp; 运算，然后计数，右移进行下一位。</li>
</ol>

<pre><code class="language-cpp">class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        for (int i = 0; i &lt; sizeof(int)*8; i++) {
            counter += num &amp; 1;
            num &gt;&gt;= 1;
        }
        return counter;
    }
};
</code></pre>

<ol>
<li>把 num 和 num - 1 做 &amp; 运算， 直到num为0，有多少次运算就有多少个1. 因为每次“&amp;”都会去掉num最右边的1.</li>
</ol>

<pre><code class="language-cpp">class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        while (num) {
            num &amp;= num - 1;
            counter++;
        }
        return counter;
    }
};
</code></pre>

<p>这个用法判断是不是2的整数次幂很容易，因为2的整数次幂必然只有1个bit的1。</p>

<pre><code class="language-cpp">bool checkPowerOf2(int n) {
    // write your code here
    return n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0);
}
</code></pre>

<h2 id="flip-bits">Flip Bits</h2>

<p>用到了xor的性质。</p>

<pre><code class="language-cpp">class Solution {
public:
    /**
     *@param a, b: Two integer
     *return: An integer
     */
    int bitSwapRequired(int a, int b) {
        // write your code here
        int counter = 0;
        int c = a^b;
        for (int i = 0; i &lt; 32; i++) {
            counter += c &amp; 1;
            c &gt;&gt;= 1;
        }
        return counter;
    }
};
</code></pre>

<h2 id="a-b-problem">A + B problem</h2>

<p>这题。
         主要利用异或运算来完成。
         异或运算有一个别名叫做：不进位加法。
         那么a ^ b就是a和b相加之后，该进位的地方不进位的结果。
         然后下面考虑哪些地方要进位，自然是a和b里都是1的地方。
         a &amp; b就是a和b里都是1的那些位置，a &amp; b &lt;&lt; 1 就是进位
         之后的结果。所以：a + b = (a ^ b) + (a &amp; b &lt;&lt; 1)
         。令a&rsquo; = a ^ b, b&rsquo; = (a &amp; b) &lt;&lt; 1
         可以知道，这个过程是在模拟加法的运算过程，进位不可能
         一直持续，所以b最终会变为0。因此重复做上述操作就可以
         求得a + b的值。</p>

<pre><code class="language-cpp">class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
       while (b != 0) {
            int _a = a ^ b;
            int _b = (a &amp; b) &lt;&lt; 1;
            a = _a;
            b = _b;
        }
        return a;
    }
};
</code></pre>

<h2 id="update-bits">Update Bits</h2>

<p>Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.</p>

<p>把一个数的 ［j， i］ 之间的bits 用另一个数去填充。</p>

<pre><code class="language-cpp">class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int right_part = n &amp; ((1 &lt;&lt; i) - 1);
        // The behavior of right shift &gt;= 32 is undefined in C++.
        int left_part = j &gt;= 31 ? 0 : (n &gt;&gt; (j + 1)) &lt;&lt; (j + 1);
        return left_part | (m &lt;&lt; i) | right_part;
    }
};
</code></pre>

<p>先用一个 mask 把 i 右边的数给取出来。
左边的数要这么取：先把bits右移 j + 1位，然后再左移 j + 1位，这样右边的数就都清空了。
最后一步把 m 左移后再把左边部分和右边部分用 ｜ 粘起来。
这种思想还可以用来做高地位互换等。把前一半的数右移，把后一半的数左移，然后 ｜ 起来。</p>

<h2 id="swap-two-variables">swap two variables</h2>

<p>如何不用第三个临时变量来交换两个数。</p>

<pre><code class="language-cpp">void swap(int &amp;a, int &amp;b){
	if (a != b){
		  a ^= b;
      b ^= a;
      a ^= b;
	}
}
</code></pre>

<h2 id="abs">abs</h2>

<pre><code class="language-cpp">//取符号位
	int a = -100;
	int i = a &gt;&gt; 31;
	//i = 0 正数
	if(i == 0){
		printf(&quot;%d\n&quot;,a);
	}
	//i = 1 负数
	else{
		printf(&quot;%d\n&quot;,~a + 1);
	}
</code></pre>

<h2 id="number-complement">Number Complement</h2>

<pre><code class="language-cpp">class Solution {
public:
    int findComplement(int num) {
        unsigned mask = ~0;
        while (num &amp; mask) mask &lt;&lt;= 1;
        return ~mask &amp; ~num;
    }
};
</code></pre>

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
