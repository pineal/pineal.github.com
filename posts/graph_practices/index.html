<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Gragh practice</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Gragh practice">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Gragh practice">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.github.com/posts/graph_practices/">
	<meta name="og:site_name" content="Gragh practice">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="bfs graph ">
	<link rel="stylesheet" type="text/css" href="https://pineal.github.com/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.github.com/" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.github.com/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.github.com/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.github.com/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Gragh practice</h1>
  <aside> <nav id="TableOfContents">
<ul>
<li><a href="#graph">Graph</a>
<ul>
<li><a href="#search-in-gragh">Search In Gragh</a>
<ul>
<li><a href="#leetcode-317-shortest-distance-from-all-buildings">Leetcode 317: Shortest Distance from All Buildings</a></li>
<li><a href="#leetcode-407-trapping-rain-water-ii">Leetcode 407: Trapping Rain Water II</a></li>
</ul></li>
</ul></li>
</ul>
</nav></aside>
  

<h1 id="graph">Graph</h1>

<p>Leetcode 里现有的图论的题比较简单，都有套路。八个题七个BFS一个DFS。</p>

<p>后半部分把图里的搜索的题目也放了进来。</p>

<p>BFS Direct Graphs - Topological Sorting</p>

<p>Course Schedule</p>

<p>用两个个hashmap记录所有的入度和出度。</p>

<p>用一个zeroInDegree的队列做BFS，没有入度意味着起点</p>

<p>在BFS过程中，不断的删除孩子的入度，然后把父亲节点从出度中删掉，这样就把这个点和所有和他连接的孩子的边都删掉了。</p>

<p>最后判断如果出度中还有点，说明还有边存在着。</p>

<pre><code class="language-cpp">//BFS
class Solution {
	public:
		bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; pres) {
			queue&lt;int&gt; zeroInDegree;

			unordered_map&lt;int, unordered_set&lt;int&gt;&gt; inDegree;
			unordered_map&lt;int, unordered_set&lt;int&gt;&gt; outDegree;

			for (int i = 0; i &lt; pres.size(); i++) {
				inDegree[pres[i].first].emplace(pres[i].second);
				outDegree[pres[i].second].emplace(pres[i].first);
			}

			for (int i = 0; i &lt; numCourses; i++) {
				if (!inDegree.count(i)) {
					zeroInDegree.push(i);
				}
			}

			while (!zeroInDegree.empty()) {
				int parent = zeroInDegree.front();
				zeroInDegree.pop();
				//for each child has a edge from parent
				for (auto child : outDegree[parent]) {
					//remove edge
					inDegree[child].erase(parent);
					//if this child has no edge, add to queue
					if (inDegree[child].empty()) {
						zeroInDegree.push(child);
					}
				}
				outDegree.erase(parent);
			}

			//if still exist edges in the graph, return false
			if (!outDegree.empty()) {
				return false;
			}
			return true;   
		}
};

</code></pre>

<p>Course Schedule II</p>

<p>BFS的过程中顺便记录弹出的顺序就行了。</p>

<p>Alien Dictionary</p>

<p>每个字母就是一个节点，根据排好序的词，找到第一个不想等的字母，找到关系，建立direct graph.</p>

<p>剩下的跟 Course Schedule ii 无异，BFS就行。</p>

<p>BFS Undirected Graphs</p>

<p>Clone Graph</p>

<p>用一个hashmap来记录orignal graph 与 copied graph 之间的节点的一一对应的关系。</p>

<p>用BFS遍历原图。做两件事：加没有遇到过的点到copied graph里，把coped graph里的节点按照 orignal graph 的连接关系连接－也就是加到neighbor里面。</p>

<p>Graph Valid Tree</p>

<p>給一堆边来表示graph，问是不是valid tree。区别就在于 树里面 不可能有环。 那么如何探测图里面的环？遍历一下就行，如果是树，那么每个点只会被访问一次，如果有环，则会被访问多次。</p>

<p>Undirected graph 没有入度和出度一说，所有的边都是度。第一步建图，只需一个map, 记录点和对应的边。</p>

<p>然后从任意点开始做bfs，要用一个set或者vector来记录访问过的点，再次访问的话就判断不是树。</p>

<p>弹出一个父亲：在孩子节点上删除父亲到孩子的边，将孩子压入队列，然后删除该父亲。</p>

<p>最后要加一个判断，看是否所有的点都访问过。不然有可能是两个不连接的图。那也不符合题意。</p>

<p>Number of Connected Components in an Undirected Graph</p>

<p>需要有一个visited 的数组来记录是否被访问过。遍历每一个点，对每一个没访问过的点(还存在在只由条件给的edge构造的graph中) 做BFS。BFS过程中删点和边，同时记录访问。BFS完 counter 加一。 最后要注意，因为条件给的是边，所以有的单个的点可以不在这个边的集合上，所以要再遍历一遍visited看看没有被访问过的就是单个的点。单个的点也是graph啊。这就是这个visited的意义所在。</p>

<p>Minimum Height Trees</p>

<p>最多最多只有两个 MHT 在图里。这道题才真正需要degree。首先需要明白，最大的MHT只能是两个node。证明的话用反证法，假设有3个，那么必然可以变到1个。</p>

<p>那么就可以用这么一个做法，每次把叶子都剥下来，直到剩下的节点数小于等于2。用degree来记录每个点的度数。那么度数为1就是叶子节点。把叶子剥下来就意味着度数为0，但是要区别最后剩下的点而不是不要的点，我们把这些剥下来的点度数设为-1。然后总数-1。对他们的父节点也要减掉度数。循环直到剩下的点小于等于2。</p>

<p>再用一次循环找到度数为0 或者 为 1的点，那么就是剩下来的结果。</p>

<p>DFS</p>

<p>Reconstruct Itinerary</p>

<p>一笔画问题。注意要用一个hashmap来表示graph，虽然这个graph是有向的，但是不需要入度出度。key是string, value需要一个multiset 因为同一个出发地可能有好几张同一个目的地的机票。</p>

<p>用一个while 循环对当前的点做DFS。每到一个点就往所有的孩子递归，每一次删除对应的边，直到当前节点已经没有出去的边。跳出循环后加入该点－意味着没边可以走了，就开始往回弹栈，把点压入答案中。</p>

<p>BFS Shortest distance</p>

<p>图给的是基本上邻接表，所以最短路径本来用dijkstra做的可以简化为BFS，因为路径间的权重都是1。</p>

<p>Walls and Gates</p>

<p>最基础的BFS找路径。</p>

<p>Word Ladder ／ Word Ladder II（TODO）</p>

<p>可以抽象成图的问题。难点在时间复杂度的优化上。</p>

<p>如何找到符合要求的neighbor？</p>

<p>遍历在dict里其余所有word，和当前的比较，那么是O(nk)的复杂度，算上BFS，总的复杂度能达到O(n^2k)。</p>

<p>k是word的长度。</p>

<p>依次替换当前word里的字母，找dict里是否存在，在替换回来。那么是O(26*k)的复杂度，总的复杂度可以优化到O(nk).</p>

<p>如何求出具体路径？用一个hashmap来记录每层的word，key是从头开始的距离，value是所有这些距离的词。然后做DFS即可。注意用一个visited去重。</p>

<p>还能优化吗？TODO：双端BFS。</p>

<p>Surrounded Regions</p>

<p>标记法。</p>

<h2 id="search-in-gragh">Search In Gragh</h2>

<h3 id="leetcode-317-shortest-distance-from-all-buildings">Leetcode 317: Shortest Distance from All Buildings</h3>

<p>找到一个点，从他开始到所有的buildings的距离最短的和，中间有障碍物。对每个点做BFS，然后加起来求一个最小值。这样的时间复杂度是 $O(m*n)[BFS] * O(m*n)[matrix] = O(m^2*n^2)$。优化：从building开始搜。那么时间复杂度为$O(k*m*n)$。 $k$ 是 building 的个数。</p>

<pre><code class="language-cpp">class Solution {
public:
    int shortestDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int res = INT_MAX;
        
        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dis(grid.size(), vector&lt;pair&lt;int, int&gt;&gt;(grid[0].size()));    
        //dis[i][j].first =&gt; total distance from k buildings to grid[i][j]
        //dis[i][j].second =&gt; num of times search from k buildings and visited to grid[i][j] successfully (avoid dead end)
        int m = grid.size();
        int n = grid[0].size();
        int num_buildings = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                    num_buildings++;
                }
            }
        }
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dis[i][j].second == num_buildings) {
                    res = min(res, dis[i][j].first);
                }
            }
        }
        return res == INT_MAX? -1 : res;
    }
    
    
    void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp; grid, vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &amp; dis, int i, int j) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&lt;deque&lt;bool&gt;&gt; visited(m, deque&lt;bool&gt;(n, false));
        
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to building in grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y].first += level;
                    dis[x][y].second++;
                }
                for (const auto &amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &lt; m &amp;&amp; x_prime &gt;= 0 &amp;&amp; y_prime &lt; n &amp;&amp; y_prime &gt;= 0 &amp;&amp; 
                        grid[x_prime][y_prime] == 0 &amp;&amp;
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
        
    }
};
</code></pre>

<p>Best Meeting Point</p>

<p>和上题一样的做法，只是可以在人所在的位置。做BFS标记visited的时候要注意。</p>

<pre><code class="language-cpp">class Solution {
public:
    int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int res = INT_MAX;        
        vector&lt;vector&lt;int&gt;&gt; dis(grid.size(), vector&lt;int&gt;(grid[0].size()));    
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (grid[i][j] == 1) {
                    bfs(grid, dis, i, j);
                }
            }
        }
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                    res = min(res, dis[i][j]);
            }
        }
        return res == INT_MAX? -1 : res;        
    }
    void bfs(const vector&lt;vector&lt;int&gt;&gt; &amp; grid, vector&lt;vector&lt;int&gt;&gt; &amp; dis, int i, int j) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.emplace(i, j);
        int m = grid.size();
        int n = grid[0].size();
        deque&lt;deque&lt;bool&gt;&gt; visited(m, deque&lt;bool&gt;(n, false));
        visited[i][j] = true;
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        int level = 0;      //distance to grid[i][j]
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (level != 0) {
                    dis[x][y] += level;
                }
                for (const auto &amp; dir : dirs) {
                    int x_prime = x + dir.first;
                    int y_prime = y + dir.second;
                    if (x_prime &lt; m &amp;&amp; x_prime &gt;= 0 &amp;&amp; y_prime &lt; n &amp;&amp; y_prime &gt;= 0 &amp;&amp; 
                        visited[x_prime][y_prime] == false) {
                        q.emplace(x_prime, y_prime);
                        visited[x_prime][y_prime] = true;
                    }
                }    
            }            
            level++;
        }
    }    
};
</code></pre>

<p>但超时啦。
答案里给的方法是算出median。并不适用有obstacle的情况（是嘛？）。</p>

<pre><code class="language-cpp">// Time:  O(mn)
// Space: O(m+n)

class Solution {
public:
    int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        vector&lt;int&gt; x, y;
        for (int i = 0; i &lt; grid.size(); ++i) {
            for (int j = 0; j &lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    x.emplace_back(i);
                    y.emplace_back(j);
                }
            }
        }
        nth_element(x.begin(), x.begin() + x.size() / 2, x.end());
        nth_element(y.begin(), y.begin() + y.size() / 2, y.end());
        const int mid_x = x[x.size() / 2];
        const int mid_y = y[y.size() / 2];
        int sum = 0;
        for (int i = 0; i &lt; grid.size(); ++i) {
            for (int j = 0; j &lt; grid[0].size(); ++j) {
                if (grid[i][j]) {
                    sum += abs(mid_x - i) + abs(mid_y - j);
                }
            }
        }
        return sum;
    }
};
</code></pre>

<p><a href="https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations">数学证明参考链接</a></p>

<ul>
<li>nth_element()
把按 comparator 排序的有第n个数放在 n 的位置，前面的都比它“小”， 后面的都比它“大”。 但其他并不保证有序，时间复杂度 $O(n)$ 比 sort 好一些。</li>
</ul>

<h3 id="leetcode-407-trapping-rain-water-ii">Leetcode 407: Trapping Rain Water II</h3>

<pre><code class="language-cpp">class Solution {
public:
    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {
        if (heightMap.empty()) {
            return 0;
        }
        int rst = 0;
        int m = heightMap.size();
        int n = heightMap[0].size();

        auto cmp = [&amp;heightMap](const pair&lt;int, int&gt; &amp; a, const pair&lt;int, int&gt; &amp; b) {
            return heightMap[a.first][a.second] &gt; heightMap[b.first][b.second]; 
        };
        
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; min_heap(cmp);
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));
        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        
        //start with boundary
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if(!(i==0 || i==m-1 || j==0 || j==n-1)) continue;
                min_heap.emplace(i, j);
                visited[i][j] = 1;
            }
        }
        
        int max_h = 0;
        int x, y;
        while (!min_heap.empty()) {
            x = min_heap.top().first;
            y = min_heap.top().second;
            max_h = max(heightMap[x][y], max_h);
            min_heap.pop();
            for (auto dir : dirs) {
              int x_n = x + dir.first;
              int y_n = y + dir.second;
              if (x_n &gt; 0 &amp;&amp; x_n &lt; m - 1 &amp;&amp; y_n &gt; 0 &amp;&amp; y_n &lt; n - 1 &amp;&amp; !visited[x_n][y_n]) {
                visited[x_n][y_n] = true;
                rst += max(0, (max_h - heightMap[x_n][y_n]));
                min_heap.emplace(x_n, y_n);
              }              
            }
        }
        return rst;
    }
};
</code></pre>

<p>Skyline</p>


  <a href="/tags/bfs/">bfs</a></a>&nbsp;&nbsp;&nbsp;<a href="/tags/graph/">graph</a></a>&nbsp;&nbsp;&nbsp;

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
