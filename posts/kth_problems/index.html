<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Kth Problems</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Kth Problems">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Kth Problems">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.me/posts/kth_problems/">
	<meta name="og:site_name" content="Kth Problems">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Heap priority Queue ">
	<link rel="stylesheet" type="text/css" href="https://pineal.mecss/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.me" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.me/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.me/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.meindex.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Kth Problems <aside><a href="/tags/heap/">Heap</a></a>&nbsp;&nbsp;&nbsp;<a href="/tags/priority-queue/">priority Queue</a></a>&nbsp;&nbsp;&nbsp;</aside></h1>
  

<h1 id="kth-problems">Kth Problems</h1>

<p>套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).</p>

<h3 id="merge-k-sorted-lists">Merge k Sorted Lists</h3>

<pre><code class="language-cpp">
//Time O(nlogk)
//Space O(n)
//provides greater
struct Cmp {
  bool operator() (ListNode* n1, ListNode* n2) {
    return n1 -&gt; val &gt; n2 -&gt; val;
  }
};

class Solution {
public:
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
    //min_heap needs a greater comparator
    //Method 1: redefine functor
    //priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; min_heap;
    //Method 2: Lambda
    auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&gt; val &gt; n2 -&gt; val;};
    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; min_heap(cmp);
    //maintain the min_heap of size k instead of all nodes
    // klogn =&gt; nlogk
    for (int i = 0; i &lt; lists.size(); i++) {
      if (lists[i]) {
        min_heap.emplace(lists[i]);
      }
    }

    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (!min_heap.empty()) {
      ListNode* temp = min_heap.top();
      cur -&gt; next = temp;
      min_heap.pop();
      if (temp -&gt; next) {
        min_heap.emplace(temp -&gt; next);
      }
      cur = cur -&gt; next;
    }
    return dummy -&gt; next;
  }
};
</code></pre>

<h3 id="kth-smallest-number-in-sorted-matrix">Kth Smallest Number In Sorted Matrix</h3>

<pre><code class="language-cpp">
class Cell {
public:
    int row;
    int col;
    int value;
    Cell(int _row, int _column, int _value) {
        row = _row;
        col = _column;
        value = _value;
    }

    bool operator &lt; (const Cell &amp; c) const {
        return value &lt;= c.value;
    }

    bool operator &gt; (const Cell &amp; c) const {
        return value &gt; c.value;
    }
};

int kthSmallest(vector&lt;vector&lt;int&gt;&gt; m, int k) {
    priority_queue&lt;Cell, vector&lt;Cell&gt;, greater&lt;Cell&gt;&gt; min_heap;
    min_heap.emplace(Cell(0, 0, m[0][0]));
    size_t num_row = m.size();
    size_t num_col = m[0].size();
    vector&lt;vector&lt;bool&gt;&gt; visited(num_row, vector&lt;bool&gt;(num_col, false));
    visited[0][0] = true;
    for (int i = 0; i &lt; k - 1; i++) {
        Cell c = min_heap.top();
        min_heap.pop();
        if (c.row + 1 &lt; num_row &amp;&amp; visited[c.row + 1][c.col] == false) {
                min_heap.emplace(Cell(c.row + 1, c.col, m[c.row + 1][c.col]));
                visited[c.row + 1][c.col] = true;
        }

        if (c.col + 1 &lt; num_col &amp;&amp; visited[c.row][c.col + 1] == false) {
                min_heap.emplace(Cell(c.row, c.col + 1, m[c.row][c.col + 1]));
                visited[c.row][c.col + 1] = true;
        }
    }
    return min_heap.top().value;
}
</code></pre>

<h3 id="kth-smallest-sum-in-two-sorted-arrays">Kth Smallest Sum In Two Sorted Arrays</h3>

<pre><code class="language-cpp">class Cell {
public:
  int i;
  int j;
  int sum;
  Cell(int _i, int _j, int _sum) {
    i = _i;
    j = _j;
    sum = _sum;
  }

  bool operator &lt; (const Cell &amp; c) const {
    return sum &lt;= c.sum;
  }

  bool operator &gt; (const Cell &amp; c) const {
    return sum &gt; c.sum;
  }
};

class Solution {
 public:
  int kthSum(vector&lt;int&gt; a, vector&lt;int&gt; b, int k) {
    // Write your solution here
    priority_queue&lt;Cell, vector&lt;Cell&gt;, greater&lt;Cell&gt;&gt; min_heap;
    vector&lt;vector&lt;bool&gt;&gt; visited(a.size(), vector&lt;bool&gt;(b.size(), false));
    visited[0][0] = true;
    min_heap.emplace(Cell(0, 0, a[0] + b[0]));
    for (int i = 0; i &lt; k - 1; i++) {
      Cell cur = min_heap.top();
      min_heap.pop();
      if (cur.i + 1 &lt; a.size() &amp;&amp; !visited[cur.i + 1][cur.j]) {
        int sum = a[cur.i + 1] + b[cur.j];
        min_heap.emplace(Cell(cur.i + 1, cur.j, sum));
        visited[cur.i + 1][cur.j] = true;
      }

      if (cur.j + 1 &lt; b.size() &amp;&amp; !visited[cur.i][cur.j + 1]) {
        int sum = a[cur.i] + b[cur.j + 1];
        min_heap.emplace(Cell(cur.i, cur.j + 1, sum));
        visited[cur.i][cur.j + 1] = true;
      }
    }
    return min_heap.top().sum;
  }
};
</code></pre>

<h3 id="kth-smallest-with-only-3-5-7-as-factors">Kth Smallest With Only 3, 5, 7 As Factors</h3>

<pre><code class="language-cpp">  long kth(int k) {
    // Write your solution here.
    priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; min_heap;
    min_heap.emplace(105);
    set&lt;long&gt; visited;
    visited.emplace(105);
    for (int i = 0; i &lt; k - 1; i++) {
      long cur = min_heap.top();
      min_heap.pop();
      if (visited.find(cur * 3) == visited.end()) {
        min_heap.emplace(cur * 3);
        visited.emplace(cur * 3);
      }

      if (visited.find(cur * 5) == visited.end()) {
        min_heap.emplace(cur * 5);
        visited.emplace(cur * 5);
      }      

      if (visited.find(cur * 7) == visited.end()) {
        min_heap.emplace(cur * 7);
        visited.emplace(cur * 7);
      }      
    }

    return min_heap.top();
  }

</code></pre>

<h3 id="kth-closest-point">Kth Closest Point</h3>

<pre><code class="language-cpp">class Point {
public:
    int x;
    int y;
    int z;
    double dis;
    Point (int _x, int _y, int _z, double _dis) {
        x = _x;
        y = _y;
        z = _z;
        dis = _dis;
    }

    bool operator &lt; (const Point &amp; p1) const {
        return dis &lt;= p1.dis;
    }

    bool operator &gt; (const Point &amp; p1) const {
        return dis &gt; p1.dis;
    }

};

class Solution {
 public:
    vector&lt;int&gt; closest(vector&lt;int&gt; a, vector&lt;int&gt; b, vector&lt;int&gt; c, int k) {
        priority_queue&lt;Point, vector&lt;Point&gt;, greater&lt;Point&gt;&gt; min_heap;
        set&lt;vector&lt;int&gt;&gt; visited;
        double d = sqrt(a[0] * a[0] + b[0] * b[0] + c[0] * c[0] + 0.0);
        Point* start = new Point(0,0,0,d);
        min_heap.emplace(*start);
        visited.emplace(vector&lt;int&gt;{0,0,0});
        for (int i = 0; i &lt; k - 1; i++) {
            Point p = min_heap.top();
            min_heap.pop();
            if (p.x + 1 &lt; a.size()) {
                double d = sqrt(a[p.x + 1] * a[p.x + 1] + b[p.y] * b[p.y] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x + 1,p.y,p.z,d);
                if (visited.find({p.x + 1,p.y,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x + 1, p.y, p.z};
                    visited.emplace(v);
                }
            }
            if (p.y + 1 &lt; b.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y + 1] * b[p.y + 1] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x,p.y + 1,p.z,d);
                if (visited.find({p.x,p.y + 1,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x,p.y + 1,p.z};
                    visited.emplace(v);
                }
            }

            if (p.z + 1 &lt; c.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y] * b[p.y] + c[p.z + 1] * c[p.z + 1] + 0.0);
                Point* temp = new Point(p.x,p.y,p.z + 1,d);
                if (visited.find({p.x,p.y,p.z + 1}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x,p.y,p.z + 1};
                    visited.emplace(v);
                }
            }      
        }

        Point rst = min_heap.top();
        return {a[rst.x], b[rst.y], c[rst.z]};
    }
};
</code></pre>

<p>visited尽量用bool数组表示，二维三维都可。不要存放node类的class，地址不一样。</p>

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
