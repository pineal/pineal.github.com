<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>Kth Problems</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="Kth Problems">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="Kth Problems">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://pineal.github.com/posts/kth_problems/">
	<meta name="og:site_name" content="Kth Problems">
	<meta name="og:type" content="article">
	
	<meta name="article:tag" content="Heap priority Queue ">
	<link rel="stylesheet" type="text/css" href="https://pineal.github.com/css/style.css">
	
	
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script type="text/javascript" async
	src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
	tex2jax: {
	  inlineMath: [['$','$'], ['\\(','\\)']],
	  displayMath: [['$$','$$'], ['\[','\]']],
	  processEscapes: true,
	  processEnvironments: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
	  TeX: { equationNumbers: { autoNumber: "AMS" },
		   extensions: ["AMSmath.js", "AMSsymbols.js"] }
	}
  });
  </script>
</head>

<body>

<header>
	
	<a href="https://pineal.github.com/" style="float: left;color:#777;"><strong>PINEAL.ME</strong></a>
	
	&nbsp;&nbsp;<a href="https://pineal.github.com/archives/" style="color:#777;"><strong>Archives</strong></a>&nbsp;&nbsp;<a href="https://pineal.github.com/about/" style="color:#777;"><strong>About</strong></a>
	
	
	
	<a href="https://pineal.github.com/index.xml" style="color:#777;float: right;"><strong><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></strong></a>
</header>


<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
      el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
  <h1>Kth Problems</h1>
  <aside> <nav id="TableOfContents">
<ul>
<li><a href="#kth-problems">Kth Problems</a>
<ul>
<li><a href="#solution-with-priority-queue">Solution with priority queue</a>
<ul>
<li><a href="#merge-k-sorted-lists">Merge k Sorted Lists</a></li>
<li><a href="#kth-smallest-number-in-sorted-matrix">Kth Smallest Number In Sorted Matrix</a></li>
<li><a href="#kth-smallest-sum-in-two-sorted-arrays">Kth Smallest Sum In Two Sorted Arrays</a></li>
<li><a href="#kth-smallest-with-only-3-5-7-as-factors">Kth Smallest With Only 3, 5, 7 As Factors</a></li>
<li><a href="#kth-closest-point">Kth Closest Point</a></li>
</ul></li>
<li><a href="#solution-with-binary-search">Solution with binary search</a></li>
<li><a href="#solution-with-quick-sort-partition">Solution with quick-sort partition</a></li>
</ul></li>
</ul>
</nav></aside>
  

<h1 id="kth-problems">Kth Problems</h1>

<h2 id="solution-with-priority-queue">Solution with priority queue</h2>

<p>套路：找第K个的问题，最常用的做法就是用优先队列来实现，根据题意用最大堆或者最小堆把时间复杂度优化到 O(nlogk).</p>

<h3 id="merge-k-sorted-lists">Merge k Sorted Lists</h3>

<pre><code class="language-cpp">
//Time O(nlogk)
//Space O(n)
//provides greater
struct Cmp {
  bool operator() (ListNode* n1, ListNode* n2) {
    return n1 -&gt; val &gt; n2 -&gt; val;
  }
};

class Solution {
public:
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
    //min_heap needs a greater comparator
    //Method 1: redefine functor
    //priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; min_heap;
    //Method 2: Lambda
    auto cmp = [](ListNode* n1, ListNode* n2) {return n1 -&gt; val &gt; n2 -&gt; val;};
    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; min_heap(cmp);
    //maintain the min_heap of size k instead of all nodes
    // klogn =&gt; nlogk
    for (int i = 0; i &lt; lists.size(); i++) {
      if (lists[i]) {
        min_heap.emplace(lists[i]);
      }
    }

    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    while (!min_heap.empty()) {
      ListNode* temp = min_heap.top();
      cur -&gt; next = temp;
      min_heap.pop();
      if (temp -&gt; next) {
        min_heap.emplace(temp -&gt; next);
      }
      cur = cur -&gt; next;
    }
    return dummy -&gt; next;
  }
};
</code></pre>

<h3 id="kth-smallest-number-in-sorted-matrix">Kth Smallest Number In Sorted Matrix</h3>

<p>Solution 1: use priority queue</p>

<pre><code class="language-cpp">//O(klogk)
class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        auto cmp = [&amp;matrix](const pair&lt;int, int&gt; &amp; p1, const pair&lt;int, int&gt; &amp; p2) {
            return matrix[p1.first][p1.second] &gt; matrix[p2.first][p2.second];
        };
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; min_heap(cmp);
        deque&lt;deque&lt;bool&gt;&gt; visited(n, deque&lt;bool&gt;(n, false));
        min_heap.emplace(0, 0);
        visited[0][0] = true;
        while (k &gt; 1) {
            auto p = min_heap.top();
            min_heap.pop();
            int x = p.first;
            int y = p.second;
            if (x + 1 &lt; n &amp;&amp; visited[x+1][y] == false) {
                visited[x+1][y] = true;
                min_heap.emplace(x+1, y);
            }
            if (y + 1 &lt; n &amp;&amp; visited[x][y+1] == false) {
                visited[x][y+1] = true;
                min_heap.emplace(x, y+1);
            }
            k--;
        }
        return matrix[min_heap.top().first][min_heap.top().second];
    }
};
</code></pre>

<p>Sulution 2: use binary search</p>

<pre><code class="language-cpp">int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        return helper(matrix, k, matrix.front().front(), matrix.back().back());   
    }
    
    int helper(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k, int left, int right) {
        if (left &gt;= right) {
            return left;
        }
        //pick a reference value
        int mid = left + (right - left)/2;
        int n = matrix.size(); 
        int m = 0;
        //counts number of elements smaller than or equal to mid
        for (int i = 0; i &lt; n; i++) {
                          
            /* 
             * 
             *The upper bound idea if optimized from:
              for (int j = 0; j &lt; matrix[i].size(); j++) {
                  if (matrix[i][j] &lt;= mid) {
                      m++;
                  }
              }
             * using for loop is the basic idea to help understand,
             * actually we can use binary search again to find the smallest element that larger than mid
             */            

            int num = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            m += num;
        }
        // now we know that there are m elements &lt;= mid[include mid]
        // thus mid is m th smallest element in the matrix
        // if m == k, actually mid is the kth 
        // if m &lt; k, then kth smallest element must appear after mid
        // otherwise, kth element must appear before mid

        if (m &lt; k) {
            return helper(matrix, k, mid + 1, right);
        } else {
            return helper(matrix, k, left, mid);
        }
    }
</code></pre>

<h3 id="kth-smallest-sum-in-two-sorted-arrays">Kth Smallest Sum In Two Sorted Arrays</h3>

<pre><code class="language-cpp">class Cell {
public:
  int i;
  int j;
  int sum;
  Cell(int _i, int _j, int _sum) {
    i = _i;
    j = _j;
    sum = _sum;
  }

  bool operator &lt; (const Cell &amp; c) const {
    return sum &lt;= c.sum;
  }

  bool operator &gt; (const Cell &amp; c) const {
    return sum &gt; c.sum;
  }
};

class Solution {
 public:
  int kthSum(vector&lt;int&gt; a, vector&lt;int&gt; b, int k) {
    // Write your solution here
    priority_queue&lt;Cell, vector&lt;Cell&gt;, greater&lt;Cell&gt;&gt; min_heap;
    vector&lt;vector&lt;bool&gt;&gt; visited(a.size(), vector&lt;bool&gt;(b.size(), false));
    visited[0][0] = true;
    min_heap.emplace(Cell(0, 0, a[0] + b[0]));
    for (int i = 0; i &lt; k - 1; i++) {
      Cell cur = min_heap.top();
      min_heap.pop();
      if (cur.i + 1 &lt; a.size() &amp;&amp; !visited[cur.i + 1][cur.j]) {
        int sum = a[cur.i + 1] + b[cur.j];
        min_heap.emplace(Cell(cur.i + 1, cur.j, sum));
        visited[cur.i + 1][cur.j] = true;
      }

      if (cur.j + 1 &lt; b.size() &amp;&amp; !visited[cur.i][cur.j + 1]) {
        int sum = a[cur.i] + b[cur.j + 1];
        min_heap.emplace(Cell(cur.i, cur.j + 1, sum));
        visited[cur.i][cur.j + 1] = true;
      }
    }
    return min_heap.top().sum;
  }
};
</code></pre>

<h3 id="kth-smallest-with-only-3-5-7-as-factors">Kth Smallest With Only 3, 5, 7 As Factors</h3>

<pre><code class="language-cpp">  long kth(int k) {
    // Write your solution here.
    priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; min_heap;
    min_heap.emplace(105);
    set&lt;long&gt; visited;
    visited.emplace(105);
    for (int i = 0; i &lt; k - 1; i++) {
      long cur = min_heap.top();
      min_heap.pop();
      if (visited.find(cur * 3) == visited.end()) {
        min_heap.emplace(cur * 3);
        visited.emplace(cur * 3);
      }

      if (visited.find(cur * 5) == visited.end()) {
        min_heap.emplace(cur * 5);
        visited.emplace(cur * 5);
      }      

      if (visited.find(cur * 7) == visited.end()) {
        min_heap.emplace(cur * 7);
        visited.emplace(cur * 7);
      }      
    }

    return min_heap.top();
  }
</code></pre>

<h3 id="kth-closest-point">Kth Closest Point</h3>

<pre><code class="language-cpp">class Point {
public:
    int x;
    int y;
    int z;
    double dis;
    Point (int _x, int _y, int _z, double _dis) {
        x = _x;
        y = _y;
        z = _z;
        dis = _dis;
    }

    bool operator &lt; (const Point &amp; p1) const {
        return dis &lt;= p1.dis;
    }

    bool operator &gt; (const Point &amp; p1) const {
        return dis &gt; p1.dis;
    }

};

class Solution {
 public:
    vector&lt;int&gt; closest(vector&lt;int&gt; a, vector&lt;int&gt; b, vector&lt;int&gt; c, int k) {
        priority_queue&lt;Point, vector&lt;Point&gt;, greater&lt;Point&gt;&gt; min_heap;
        set&lt;vector&lt;int&gt;&gt; visited;
        double d = sqrt(a[0] * a[0] + b[0] * b[0] + c[0] * c[0] + 0.0);
        Point* start = new Point(0,0,0,d);
        min_heap.emplace(*start);
        visited.emplace(vector&lt;int&gt;{0,0,0});
        for (int i = 0; i &lt; k - 1; i++) {
            Point p = min_heap.top();
            min_heap.pop();
            if (p.x + 1 &lt; a.size()) {
                double d = sqrt(a[p.x + 1] * a[p.x + 1] + b[p.y] * b[p.y] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x + 1,p.y,p.z,d);
                if (visited.find({p.x + 1,p.y,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x + 1, p.y, p.z};
                    visited.emplace(v);
                }
            }
            if (p.y + 1 &lt; b.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y + 1] * b[p.y + 1] + c[p.z] * c[p.z] + 0.0);
                Point* temp = new Point(p.x,p.y + 1,p.z,d);
                if (visited.find({p.x,p.y + 1,p.z}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x,p.y + 1,p.z};
                    visited.emplace(v);
                }
            }

            if (p.z + 1 &lt; c.size()) {
                double d = sqrt(a[p.x] * a[p.x] + b[p.y] * b[p.y] + c[p.z + 1] * c[p.z + 1] + 0.0);
                Point* temp = new Point(p.x,p.y,p.z + 1,d);
                if (visited.find({p.x,p.y,p.z + 1}) == visited.end()) {
                    min_heap.emplace(*temp);
                    vector&lt;int&gt; v = {p.x,p.y,p.z + 1};
                    visited.emplace(v);
                }
            }      
        }

        Point rst = min_heap.top();
        return {a[rst.x], b[rst.y], c[rst.z]};
    }
};
</code></pre>

<p>visited尽量用bool数组表示，二维三维都可。不要存放node类的class，地址不一样。</p>

<h2 id="solution-with-binary-search">Solution with binary search</h2>

<p><a href="http://pineal.github.io/posts/binary_search/#advanced-using-binary-search-to-solve-kth-problem">post about binary search</a></p>

<h2 id="solution-with-quick-sort-partition">Solution with quick-sort partition</h2>

<p>Kth Largest Element in an Array</p>

<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>

<pre><code class="language-cpp">class Solution {
public:    
    int partition(vector&lt;int&gt; &amp; nums, int left, int right) {        
        int pivot_index = left + rand() % (right - left + 1); 
        int pivot = nums[pivot_index];
        swap(nums[left], nums[pivot_index]);
        int left_bound = left + 1;
        int right_bound = right;
        while (left_bound &lt;= right_bound) {
            if (nums[right_bound] &lt;= pivot) {
                right_bound--;
            } 
            else if (nums[left_bound] &gt;= pivot) {
                left_bound++;
            } 
            else {
                swap(nums[left_bound++], nums[right_bound--]);
            }
        }
        swap(nums[left], nums[right_bound]);
        return right_bound;
    }
    
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        int left = 0;
        int right = nums.size() - 1;
        while (true) {
            int pos = partition(nums, left, right); 
            if (pos == k - 1) {
                return nums[pos];
            } 
            else if (pos &gt; k - 1) {
                right = pos - 1;
            } 
            else {
                left = pos + 1;
            }
        }
    }
};
</code></pre>


  <a href="/tags/heap/">Heap</a></a>&nbsp;&nbsp;&nbsp;<a href="/tags/priority-queue/">priority Queue</a></a>&nbsp;&nbsp;&nbsp;

</div>




<footer>
	<p>© 2017-2018, all rights reserved.</a>
</footer>
</body>
</html>
