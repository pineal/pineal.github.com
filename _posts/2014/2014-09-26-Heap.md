---
layout: post
title: Priority Queue:Heap
categories:
- Algorithm
- Data Structure
tags:
- Binary Tree
- Heap
- Binary Heap
- Binomial Heap
- Fibonacci Heap
---

##Copyright Statement
> The Exercise and some notes are homework or examples in course CSCI 570, computer science department, university of California. All copyright belongs to the team of this course, including Professors and TAs. Posts on this blog are just for self-learning. 

##Binary Tree
A binary tree is made of a set of nodes. This set can be empty or it can consist of a node called a root along with two disjoint subtrees.

###Types of binary tree
- In **full binary tree** every node other than the leaves has two children.

- A **perfect binary tree** is a full binary tree in which all leaves have the same depth or same level.

- In a **complete binary tree**, every level except possibly the last, is completely filled, and all nodes are as far left as possible. It can have between 1 and 2^h nodes, as far left as possible, agh the last level h. A binary tree is called an almost complete binary tree or nearly complete binary tree if mentioned exception holds, i.e. the last level is not completely filled. This type of binary tree is used as a specialized data structure called **binary heap**.

- A **balanced binary tree** has the minimum possible maximum height for the leaf nodes, because for any given number of leaf nodes the leaf nodes are placed at the greatest height possible.

###Comparison of Full binary tree and complete binary tree
 ![Compare of full binary tree and complete binary tree](http://gsourcecode.files.wordpress.com/2012/02/complete-full-trees1.png)

##Binary Heap

###Defination
A binary heap is a complete binary tree which satisfies the heap ordering property. The ordering can be one of two types:

- the min-heap property: the value of each node is greater than or equal to the value of its parent, with the minimum-value element at the root.
- the max-heap property: the value of each node is less than or equal to the value of its parent, with the maximum-value element at the root.

Here heap refers to a min-heap.

###Array Implementation
Heaps can be maintained in an array H indexed by i=1,...,N. 

###Operation Implementation 
To add an element to heap, we start with placing the element v to the final position i = n + 1, by setting H[i] = v. Then we need to use the procedure Heapify-up to fix the damaged heap now.

```
Heapify-up(H,i):
	If i>1 then
		let j = parent(i) = [i/2]
		If key[H[i]] < key[H[j]] then
			swap the array entries H[i] and H[j]
			Heapify-up(H,j)
		Endif
	Endif
```
By deleting an element v from position H[i] of a heap, the heap-order property has been violated, and there is a hole in the position. Move the lament w in position H[n] to H[i]. Then do a Heapify-down operation.

```
Heapify-down(H,j):
	Let n = length(H)
	If 2i > n then
		Terminate with H unchanged
	Else if 2i < n then
		Let left = 2i, and right = 2i + 1
		Let j be the index that minimize key[H[left]] and key[H[right]]
	Else if 2i = n then
		Let j = 2i
	Endif
	If Key[H[j]] < key[H[i]] then
		swap the array entries H[i] and H[j]
		Heapify-down(H,j)
	Endif
```

###Time complexity of operations

- StartHeap(N): O(N)
- Insert(H, v): O(log n)
- FindMin(H): O(1)
- Delete(H, i): O(log n)
- ExtractMin(H): O(log n) = O(log n) + O(1)

###Example Exercise
Input: an unsorted array with length of n
Output: top K values in the array (k<n)
Constraints: 1. cannot use any additional memory; 2. Find an algorithm up to O(nlogk)
.

**Solution:**
1. It takes O(k) to construct a min-heap inside the array. The reason we want a min-heap rather than a max heap is we need to do the extraction operation in the heap of size k, and replace it with a bigger key value in the rest of array n-k.
2. Then it takes O(logk) to ExtractMin and Insert once, so for the rest, the total time is (n-k)O(logk).
3. Therefore the overall time is O(k) + (n-k)O(logk) = O(nlogk)

##Binomial Tree
Def A binomial tree B_k is an ordered tree defined recessively. Binomial tree B_o consists of only one one node. B_k consists of 2 binomial trees B_k-1 that are linked together in this fashion such that root of one is the left most child of the root of the other. 

![binomial tree](http://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Binomial_Trees.svg/700px-Binomial_Trees.svg.png)

##Binomial Heap
A binomial heap H is a set of binomial trees that satisfies the following properties:

1. Each binomial tree in H obeys the min-heap property
2. For any non-negative integer k there is at most one binomial tree with degree k.

All operation in a binomial heap take O(log n) including merge. Construction still O(n).

##Fibonacci Heap
Fibonacci Heaps are loosely based on binomial heaps. 
FH is a collection of min-heap trees similar to Binomial heaps however trees in FHs are not constrained to be binomial trees. Also, unlike binomial heaps trees in FHs are not ordered. 

???Not understood yet???

\ | Binary Heap | Binomial Heap | Fibonacci Heap
------------ |------------ | ------------- | ------------
FindMin | O(1) | O(log n)  | O(1)
Insert | O(log n) | O(log n)  | O(1)
ExtractMin | O(log n) | O(log n)  | O(log n)*
Delete | O(log n) | O(log n)  | O(log n)*
DecreaseKey | O(log n) | O(log n)  | O(1)
Merge | O(1) | O(log n)  | O(1)
Construct | O(1) | O(log n)  | O(n)

???star * represents amortized costs???
##reference:
1. <http://gsourcecode.wordpress.com/2012/02/12/fs-bt-intr/>
2. <http://en.wikipedia.org/wiki/Binary_tree>
3. <http://en.wikipedia.org/wiki/Heap_(data_structure)>
4. <http://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html>
5. <http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html>