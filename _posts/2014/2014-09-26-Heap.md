---
layout: post
title: Priority Queue:Heap
categories:
- Algorithm
- Data Structure
tags:
- Binary Tree
- Heap
- Binary Heap
- Binomial Heap
- Fibonacci Heap
---

##Copyright Statement
> The Exercise and some notes are homework or examples in course CSCI 570, computer science department, university of California. All copyright belongs to the team of this course, including Professors and TAs. Posts on this blog are just for self-learning. 

##Binary Tree
A binary tree is made of a set of nodes. This set can be empty or it can consist of a node called a root along with two disjoint subtrees.

###Types of binary tree
- In **full binary tree** every node other than the leaves has two children.

- A **perfect binary tree** is a full binary tree in which all leaves have the same depth or same level.

- In a **complete binary tree**, every level except possibly the last, is completely filled, and all nodes are as far left as possible. It can have between 1 and 2^h nodes, as far left as possible, agh the last level h. A binary tree is called an almost complete binary tree or nearly complete binary tree if mentioned exception holds, i.e. the last level is not completely filled. This type of binary tree is used as a specialized data structure called **binary heap**.

- A **balanced binary tree** has the minimum possible maximum height for the leaf nodes, because for any given number of leaf nodes the leaf nodes are placed at the greatest height possible.

###Comparison of Full binary tree and complete binary tree
 ![Compare of full binary tree and complete binary tree](http://gsourcecode.files.wordpress.com/2012/02/complete-full-trees1.png)

##Binary Heap

###Defination
A binary heap is a complete binary tree which satisfies the heap ordering property. The ordering can be one of two types:

- the min-heap property: the value of each node is greater than or equal to the value of its parent, with the minimum-value element at the root.
- the max-heap property: the value of each node is less than or equal to the value of its parent, with the maximum-value element at the root.

Here heap refers to a min-heap.

###Array Implementation
Heaps can be maintained in an array H indexed by i=1,...,N. 

###Operation Implementation 
To add an element to heap, we start with placing the element v to the final position i = n + 1, by setting H[i] = v. Then we need to use the procedure Heapify-up to fix the damaged heap now.

```
Heapify-up(H,i):
	If i>1 then
		let j = parent(i) = [i/2]
		If key[H[i]] < key[H[j]] then
			swap the array entries H[i] and H[j]
			Heapify-up(H,j)
		Endif
	Endif
```
By deleting an element v from position H[i] of a heap, the heap-order property has been violated, and there is a hole in the position. Move the lament w in position H[n] to H[i]. Then do a Heapify-down operation.

```
Heapify-down(H,j):
	Let n = length(H)
	If 2i > n then
		Terminate with H unchanged
	Else if 2i < n then
		Let left = 2i, and right = 2i + 1
		Let j be the index that minimize key[H[left]] and key[H[right]]
	Else if 2i = n then
		Let j = 2i
	Endif
	If Key[H[j]] < key[H[i]] then
		swap the array entries H[i] and H[j]
		Heapify-down(H,j)
	Endif
```

###Time complexity of operations

- StartHeap(N): O(N)
- Insert(H, v): O(log n)
- FindMin(H): O(1)
- Delete(H, i): O(log n)
- ExtractMin(H): O(log n) = O(log n) + O(1)

reference:

<http://gsourcecode.wordpress.com/2012/02/12/fs-bt-intr/>
<http://en.wikipedia.org/wiki/Binary_tree>
<http://en.wikipedia.org/wiki/Heap_(data_structure)>
<http://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html>
<http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html>