---
layout: post
title: Priority Queue:Heap
categories:
- Algorithm
- Data Structure
tags:
- Binary Tree
- Heap
- Binary Heap
- Binomial Heap
- Fibonacci Heap
---

##Copyright Statement
> The Exercise and some notes are homework or examples in course CSCI 570, computer science department, university of Southern California. All copyright belongs to the team of this course, including Professors and TAs. Posts on this blog are just for self-learning. 

##Binary Tree
A binary tree is made of a set of nodes. This set can be empty or it can consist of a node called a root along with two disjoint subtrees.

###Types of binary tree
- In **full binary tree** every node other than the leaves has two children.

- A **perfect binary tree** is a full binary tree in which all leaves have the same depth or same level.

- In a **complete binary tree**, every level except possibly the last, is completely filled, and all nodes are as far left as possible. It can have between 1 and 2^h nodes, as far left as possible, agh the last level h. A binary tree is called an almost complete binary tree or nearly complete binary tree if mentioned exception holds, i.e. the last level is not completely filled. This type of binary tree is used as a specialized data structure called **binary heap**.

- A **balanced binary tree** has the minimum possible maximum height for the leaf nodes, because for any given number of leaf nodes the leaf nodes are placed at the greatest height possible.

###Comparison of Full binary tree and complete binary tree
 ![Compare of full binary tree and complete binary tree](http://gsourcecode.files.wordpress.com/2012/02/complete-full-trees1.png)

##Binary Heap

###Defination
A binary heap is a complete binary tree which satisfies the heap ordering property. The ordering can be one of two types:

- the min-heap property: the value of each node is greater than or equal to the value of its parent, with the minimum-value element at the root.
- the max-heap property: the value of each node is less than or equal to the value of its parent, with the maximum-value element at the root.

Here heap refers to a min-heap.

###Array Implementation
Heaps can be maintained in an array H indexed by i=1,...,N. 

###Operation Implementation 
To add an element to heap, we start with placing the element v to the final position i = n + 1, by setting H[i] = v. Then we need to use the procedure Heapify-up to fix the damaged heap now.

```
Heapify-up(H,i):
	If i>1 then
		let j = parent(i) = [i/2]
		If key[H[i]] < key[H[j]] then
			swap the array entries H[i] and H[j]
			Heapify-up(H,j)
		Endif
	Endif
```
By deleting an element v from position H[i] of a heap, the heap-order property has been violated, and there is a hole in the position. Move the elment w in position H[n] to H[i]. Then do a Heapify-down operation.

```
Heapify-down(H,i):
	Let n = length(H)
	If 2i > n then
		Terminate with H unchanged
	Else if 2i < n then
		Let left = 2i, and right = 2i + 1
		Let j be the index that minimize key[H[left]] and key[H[right]]
	Else if 2i = n then
		Let j = 2i
	Endif
	If Key[H[j]] < key[H[i]] then
		swap the array entries H[i] and H[j]
		Heapify-down(H,j)
	Endif
```

###Time complexity of operations

- StartHeap(N): O(N)
- Insert(H, v): O(log n)
- FindMin(H): O(1)
- Delete(H, i): O(log n)
- ExtractMin(H): O(log n) = O(log n) + O(1)

###Example Exercise
**Input:** an unsorted array with length of n

**Output:** top K values in the array (k<n)

**Constraints: **

1. Cannot use any additional memory; 
2. Find an algorithm up to O(nlogk).

**Solution:**
1. It takes O(k) to construct a min-heap inside the array. The reason we want a min-heap rather than a max heap is we need to do the extraction operation in the heap of size k, and replace it with a bigger key value in the rest of array n-k.
2. Then it takes O(logk) to ExtractMin and Insert once, so for the rest, the total time is (n-k)O(logk).
3. Therefore the overall time is O(k) + (n-k)O(logk) = O(nlogk)

##Binomial Tree
Def A binomial tree B_k is an ordered tree defined recessively. Binomial tree B_o consists of only one one node. B_k consists of 2 binomial trees B_k-1 that are linked together in this fashion such that root of one is the left most child of the root of the other. 

![binomial tree](http://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Binomial_Trees.svg/700px-Binomial_Trees.svg.png)

##Binomial Heap
A binomial heap H is a set of binomial trees that satisfies the following properties:

1. Each binomial tree in H obeys the min-heap property
2. For any non-negative integer k there is at most one binomial tree with degree k.

All operation in a binomial heap take O(log n) including merge. Construction still O(n).

##Fibonacci Heap
Fibonacci Heaps are loosely based on binomial heaps. 
FH is a collection of min-heap trees similar to Binomial heaps however trees in FHs are not constrained to be binomial trees. Also, unlike binomial heaps trees in FHs are not ordered. 

???Not understood yet???

|Operation/Heap | Binary Heap | Binomial Heap | Fibonacci Heap|
|------------ |------------ | ------------- | ------------|
|FindMin | O(1) | O(log n)  | O(1) |
|Insert | O(log n) | O(log n)  | O(1) |
|ExtractMin | O(log n) | O(log n)  | O(log n)* |
|Delete | O(log n) | O(log n)  | O(log n)* |
|DecreaseKey | O(log n) | O(log n)  | O(1) |
|Merge | O(n) | O(log n)  | O(1) |
|Construct | O(n) | O(n)  | O(n) |


???star * represents amortized costs???


##Exercises
**1.** Design a data structure that has the following properties (assume n elements in the data structure, and that the data structure properties need to be preserved at the end of each operation):

- Find median takes O(1) time
- Extract-Median takes O(log n) time
- Insert takes O(log n) time
- Delete takes O(log n) time

Do the following:1. Describe how your data structure will work.
2. Give algorithms that implement the Extract-Median() and Insert() functions.

**Solution**

We use the [n/2] smallest elements(or n/2+1) to build a max-heap and use the remaining [n/2] to build a min-heap. The median is the root of max-heap. Find it takes O(1).

Insert() algorithm: For a new element x,1. Compare x to the current median (root of max-heap).2. If x < median, we insert x into the max-heap. Otherwise, we insert x into the min-heap. This takes O(log n) time in the worst case.
3. If size(maxHeap) > size(minHeap)+1, then we call Extract-Max() on max-heap and insert the extracted value into the min-heap. This takes O(log n) time in the worst case.
4. Also, if size(minHeap) >size(maxHeap), we call Extract-Min() on min-heap and insert the extracted value in to the max-heap. This takes O(log n) time in the worst case.
Extract-Median() algorithm: Run ExtractMax() on max-heap. If after extraction, size(maxHeap) < size(minHeap) then execute Extract-Min() on the min-heap and insert the extracted value into the max-heap. Again worst case time is O(log n).

**2.** There is a stream of integers that comes continuously to a small server. The job of the server is to keep track of k largest numbers that it has seen so far. The server has the following restrictions:

1. It can process only one number from the stream at a time, which means it takes a number from the stream, processes it, finishes with that number and takes the next number from the stream. It cannot take more than one number from the stream at a time due to memory restriction.2. It has enough memory to store up to k integers in a simple data structure (e.g. an array), and some extra memory for computation (like comparison, etc.).3. The time complexity for processing one number must be better than Θ(k). Anything that is Θ(k) or worse is not acceptable.**Solution：** Use a binary min-heap on the server.

1. Do not wait until k numbers have arrived at the server to build the heap, otherwise you would incur a time complexity of O(k). Instead, build the heap on-the-fly, i.e. as soon as a number arrives, if the heap is not full, insert the number into the heap and execute Heapify(). The first k numbers are obviously the k largest numbers that the server has seen.

2. When a new number x arrives and the heap is full, compare x to the minimum number r in the heap located at the root, which can be done in O(1) time. If x ≤ r, ignore x. Otherwise, run Extract-min() and insert the new number x into the heap and call Heapify() to maintain the structure of the heap.

3. Both Extract-min() and Heapify() can be done in O(log k) time. Hence, the overall complexity is O(log k).##reference:
1. <http://gsourcecode.wordpress.com/2012/02/12/fs-bt-intr/>
2. <http://en.wikipedia.org/wiki/Binary_tree>
3. <http://en.wikipedia.org/wiki/Heap_(data_structure)>
4. <http://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html>
5. <http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html>