<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on PINEAL.ME</title>
    <link>http://pineal.github.io/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Feb 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://pineal.github.io/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Jump Game</title>
      <link>http://pineal.github.io/posts/jump_game/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/jump_game/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/jump-game/&#34;&gt;Jump Game&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/jump-game-ii/&#34;&gt;Jume Game II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两题明眼看是序列形动态规划的题，但是时间复杂度上其实并不好，会出现超时的情况。而用贪心法则能避免。单独拿出来记录一下贪心法。尤其是Jump Game II 的做法非常巧妙。&lt;/p&gt;

&lt;h2 id=&#34;jump-game&#34;&gt;Jump Game&lt;/h2&gt;

&lt;p&gt;动态规划解法，无法被AC, c++的解法会超时。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    bool canJump(vector&amp;lt;int&amp;gt; A) {
        if (A.empty()) {
            return true;
        }

        vector&amp;lt;bool&amp;gt; jumpto(A.size(), false);
        jumpto[0] = true;

        for (int i = 1; i != A.size(); ++i) {
            for (int j = i - 1; j &amp;gt;= 0; --j) {
                if (jumpto[j] &amp;amp;&amp;amp; (j + A[j] &amp;gt;= i)) {
                    jumpto[i] = true;
                    break;
                }
            }
        }

        return jumpto[A.size() - 1];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贪心法的解法，很快。&lt;/p&gt;

&lt;p&gt;维护一个最远能到达的变量，如果当前位置的值超过了这个变量那么更新该变量。从头循环到尾，如果现在的位置超过了最远能到达的位置，那说明到不了最后，返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     */
    bool canJump(vector&amp;lt;int&amp;gt; A) {
        // write you code here

        int reachable = 0;
        for (int i = 0; i &amp;lt; A.size(); ++i){
            if (i &amp;gt; reachable){
                return false;
            }
            reachable = max(reachable, i + A[i]);
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jump-game-ii&#34;&gt;Jump Game II&lt;/h2&gt;

&lt;p&gt;动态规划的和之前的没什么大差别，把维护的数组类型从bool换成了int记录步数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: A list of lists of integers
     * @return: An integer
     */
    int jump(vector&amp;lt;int&amp;gt; A) {
        if (A.empty()) {
            return -1;
        }

        const int N = A.size() - 1;
        vector&amp;lt;int&amp;gt; steps(N, INT_MAX);
        steps[0] = 0;

        for (int i = 1; i != N + 1; ++i) {
            for (int j = 0; j != i; ++j) {
                if ((steps[j] != INT_MAX) &amp;amp;&amp;amp; (j + A[j] &amp;gt;= i)) {
                    steps[i] = steps[j] + 1;
                    break;
                }
            }
        }

        return steps[N];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;贪心法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Time:  O(n)
// Space: O(1)

class Solution {
public:
    /**
     * @param A: A list of lists of integers
     * @return: An integer
     */
    int jump(vector&amp;lt;int&amp;gt; A) {
        int jump_count = 0;
        int reachable = 0;
        int curr_reachable = 0;
        for (int i = 0; i &amp;lt; A.size(); ++i) {
            if (i &amp;gt; curr_reachable) {
                // current jumps are not enough,
                // jump one more step, which enlarges curr_reachable to reachable.
                curr_reachable = reachable;
                ++jump_count;
            }
            reachable = max(reachable, i + A[i]);
        }   

        return jump_count;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.kancloud.cn/kancloud/data-structure-and-algorithm-notes/73079&#34;&gt;reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>http://pineal.github.io/posts/palindrome_partitioning/</link>
      <pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/palindrome_partitioning/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;分隔回文串问题，共有两题，分别是搜索和动归的代表题型。刚碰到的时候理解比较难，单独拿出来看一看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning/&#34;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning-ii/&#34;&gt;Palindrome Partitioning II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;palindrome-partitioning-ii&#34;&gt;Palindrome Partitioning II&lt;/h2&gt;

&lt;p&gt;求最小的分割次数，一维的一个数组，满足动态规划的条件。&lt;/p&gt;

&lt;p&gt;提示：动归字符串时基本上要把f[0]空出来，这样就需要n+1长度的一个数组来记录最优值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minCut(string s) {
        int len = s.size();
        if (len &amp;lt;= 1) return 0;

//用一个矩阵来记录子字符串s[i:j]是否为回文串

        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; mat = vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt;(len, vector&amp;lt;bool&amp;gt;(len, true));

        for (int i = len; i &amp;gt;= 0; --i) {
            for (int j = i; j &amp;lt; len; ++j) {
//                if((i+1&amp;gt;j-1 || isPal[i+1][j-1]) &amp;amp;&amp;amp; s[i]==s[j])
//                    isPal[i][j] = true;                
//很多答案给的是这样的判断方法，个人觉得没有下面的清楚，边界条件实际上就两种，要么i==j要么i和j靠在一起。其他就判断xSx是不是回文串（如果S是的话）              
                if (j == i) {
                    mat[i][j] = true;
                } else if (j == i + 1) {
                    mat[i][j] = (s[i] == s[j]);
                } else {
                    mat[i][j] = ((s[i] == s[j]) &amp;amp;&amp;amp; mat[i + 1][j - 1]);
                }
            }
        }

        vector&amp;lt;int&amp;gt; cut(len + 1, INT_MAX);

// 真正的sequence DP: cut[i]表示到i的minCut
// 到位置i时候，就判断j+1到i是不是一个回文串（到角标就变成了和j , i-1）
// 就找所有比i小的j的位置上能切的minCut + 1（此时条件为上面那个矩阵）
//

        for (int i = 1; i &amp;lt; 1 + len; ++i) {
            for (int j = 0; j &amp;lt; i; ++j) {
                if (mat[j][i - 1]) {
                    cut[i] = min(cut[i], 1 + cut[j]);
                }
            }
        }

        return cut[len];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个&lt;a href=&#34;https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space&#34;&gt;优化的解&lt;/a&gt;以后留着看。&lt;/p&gt;

&lt;h2 id=&#34;palindrome-partitioning&#34;&gt;Palindrome Partitioning&lt;/h2&gt;

&lt;p&gt;这题求的是具体的分隔方法，基本上就是DFS搜索加回溯的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;
        if (s.empty()) return result;

        vector&amp;lt;string&amp;gt; palindromes;
        dfs(s, 0, palindromes, result);

        return result;
    }

private:
    void dfs(string s, int pos, vector&amp;lt;string&amp;gt; &amp;amp;palindromes,
             vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;ret) {

        if (pos == s.size()) {
            ret.push_back(palindromes);
            return;
        }

        for (int i = pos + 1; i &amp;lt;= s.size(); ++i) {
            string substr = s.substr(pos, i - pos);
            if (!isPalindrome(substr)) {
                continue;
            }

            palindromes.push_back(substr);
            dfs(s, i, palindromes, ret);
            palindromes.pop_back();
        }
    }

    bool isPalindrome(string s) {
        if (s.empty()) return false;

        int n = s.size();
        for (int i = 0; i &amp;lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }

        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sequences Dynamic Programming</title>
      <link>http://pineal.github.io/posts/two_sequences_dynamic_programming/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/two_sequences_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;两个序列类型的动态规划。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/longest-common-subsequence/&#34;&gt;Longest Common Sequences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/edit-distance/&#34;&gt;Edit Distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/interleaving-string/&#34;&gt;Interleaving String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/distinct-subsequences/&#34;&gt;Distinct Subsequences&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;longest-common-sequences&#34;&gt;Longest Common Sequences&lt;/h2&gt;

&lt;p&gt;LCS是的经典动归问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    int longestCommonSubsequence(string A, string B) {
        // write your code here
        int dp[A.size() + 1][B.size() + 1];

        for (int i = 0; i &amp;lt; A.size() + 1; ++i){
            dp[i][0] = 0;
        }

        for (int i = 0; i &amp;lt; B.size() + 1; ++i){
            dp[0][i] = 0;
        }

        for (int i = 1; i &amp;lt; A.size() + 1; ++i){
            for (int j = 1; j &amp;lt; B.size() + 1; ++j){
                if (A[i - 1] == B[j - 1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
    return dp[A.size()][B.size()];    
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;edit-distance&#34;&gt;Edit Distance&lt;/h2&gt;

&lt;p&gt;设状态为dp[i][j]，表示T[0, j]在S[0, i]里出现的次数。&lt;/p&gt;

&lt;p&gt;状态转移方程可以用一下公式来表达：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果 $$word1[i] == word2[j]$$，&lt;/p&gt;

&lt;p&gt;$$dp[i][j] = dp[i - 1][j - 1]$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 $word1[i] != word2[j]$,&lt;/p&gt;

&lt;p&gt;$$
  \begin{aligned}
 dp[i][j] &amp;amp; =  min ( &lt;br /&gt;
   &amp;amp; = dp[i - 1][j] + 1,(在word1中删除一个字符word1[i])   &lt;br /&gt;
   &amp;amp; = dp[i][j - 1] + 1,（在word1中插入一个字符word2[j]）   &lt;br /&gt;
   &amp;amp; = dp[i - 1][j - 1] + 1（替换word1[i] == word2[j]）    &lt;br /&gt;
   &amp;amp; )    &lt;br /&gt;
  \end{aligned}
$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://yutianx.info/2014/09/26/2014-09-26-leetcode-edit-distance/&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minDistance(string word1, string word2) {
        const int len1 = word1.size();
        const int len2 = word2.size();

        int dp[len1 + 1][len2 + 1];
        for (int i = 0; i &amp;lt;= len1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j &amp;lt;= len2; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i &amp;lt;= len1; i++) {
            for (int j = 1; j &amp;lt;= len2; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));  
                }
            }
        }
        return dp[len1][len2];
}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;interleaving-string&#34;&gt;Interleaving String&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true of false.
     */
    bool isInterleave(string s1, string s2, string s3) {
        // write your code here
        int len1 = s1.size(), len2 = s2.size(), len3 = s3.size();
        if (len1 + len2 != len3) return false;
        //代表s1前i个字符和s2前j个字符能否组成s3前i+j个字符

        bool dp[len1 + 1][len2 + 1];
        dp[0][0] = true;
        //初始化：s1前i个字符和s2前0个字符能否组成s3前i个字符？
        //只要能一一配对，即为true 否则为 false
        for (int i = 1; i &amp;lt; len1 + 1; ++i){
            dp[i][0] = (s3[i-1] == s1[i-1])? true : false;
        }

        for (int j = 1; j &amp;lt; len2 + 1; ++j){
            dp[0][j] = (s3[j-1] == s2[j-1])? true : false;
        }
        // 比较 s3 第i + j 个字符 和 s1第i个字符 或者 s2第j个字符
        for (int i = 1; i &amp;lt; len1 + 1; ++i){
            for (int j = 1; j &amp;lt; len2 + 1; ++j){
                if ((s3[i + j - 1] == s1[i - 1] &amp;amp;&amp;amp; dp[i - 1][j]) || (s3[i + j - 1] == s2[j - 1] &amp;amp;&amp;amp; dp[i][j - 1])){
                    dp[i][j] = true;
                }
                else{
                    dp[i][j] = false;
                }
            }
        }
        return dp[len1][len2];   
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;distinct-subsequences&#34;&gt;Distinct Subsequences&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    int numDistinct(string &amp;amp;S, string &amp;amp;T) {

        if (S.size() &amp;lt; T.size()) return 0;
        if (T.empty()) return 1;

        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(S.size() + 1, vector&amp;lt;int&amp;gt;(T.size() + 1, 0));

        int lenS = S.size();
        int lenT = T.size();

        for (int i = 0; i &amp;lt; S.size(); ++i) {
            dp[i][0] = 1;
            for (int j = 0; j &amp;lt; T.size(); ++j) {
                if (S[i] == T[j]) {
                    dp[i + 1][j + 1] = dp[i][j + 1] + dp[i][j];
                } else {
                    dp[i + 1][j + 1] = dp[i][j + 1];
                }
            }
        }

        return dp[S.size()][T.size()];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Matrix Dynamic Programming</title>
      <link>http://pineal.github.io/posts/matrix_dynamic_programming/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/matrix_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/unique-paths/&#34;&gt;Unique Paths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/minimum-path-sum/&#34;&gt;Min Path Sum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般这类问题都是给了一个m＊n的矩阵(或者三角形)，从一个方向走到另一个方向（从顶到底，或者从左上角到右下角 .etc），一般来说只会朝固定的方向走。&lt;/p&gt;

&lt;p&gt;初始化两条边，然后根据条件循环更新状态方程，主要看上一步的状态，最后得出结果。&lt;/p&gt;

&lt;h2 id=&#34;unique-paths&#34;&gt;Unique Paths&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n, m: positive integer (1 &amp;lt;= n ,m &amp;lt;= 100)
     * @return an integer
     */
    int uniquePaths(int m, int n) {
        // wirte your code here

    int dp[m][n];

        for (int i = 0; i &amp;lt; m; i++){
            dp[i][0] =  1;
        }

        for (int i = 0; i &amp;lt; n; i++){
            dp[0][i] =  1;
        }

        for (int i = 1;i &amp;lt; m; i++){
            for (int j = 1; j &amp;lt; n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;min-path-sum&#34;&gt;Min Path Sum&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param grid: a list of lists of integers.
     * @return: An integer, minimizes the sum of all numbers along its path
     */
    int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;grid) {
        // write your code here
        int m = grid.size(), n = grid[0].size();
        int sum[m][n];

        sum[0][0] = grid[0][0];

        for (int i = 1; i &amp;lt; m; i++){
            sum[i][0] =  sum[i-1][0] + grid[i][0];
        }

        for (int i = 1; i &amp;lt; n; i++){
            sum[0][i] =  sum[0][i-1] + grid[0][i];
        }

        for (int i = 1; i &amp;lt; m; i++){
            for (int j = 1 ; j &amp;lt; n; j++){
                sum[i][j] = min(sum[i-1][j], sum[i][j-1]) + grid[i][j];
            }
        }
        return sum[m-1][n-1];
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sequence Dynamic Programming</title>
      <link>http://pineal.github.io/posts/sequence_dynamic_programming/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/sequence_dynamic_programming/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/unique-paths/&#34;&gt;Climbing Stairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/house-robber/&#34;&gt;House Robber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/longest-increasing-subsequence/&#34;&gt;Longest Increasing Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/word-break/&#34;&gt;Word Break&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;climbing-stairs&#34;&gt;Climbing Stairs&lt;/h2&gt;

&lt;p&gt;状态转移方程，两种可能：要么是从i-1爬到i的，要么就是从i-2爬到i的，要计算所有可能的爬法之要把两者相加即可。所以维护一个数组来记录到i的爬法总数，那么:&lt;/p&gt;

&lt;p&gt;$$
f[i] = f[i-1] + f[i-2]
$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        // write your code here
        if (n &amp;lt;= 1){
            return 1;
        }

        vector&amp;lt;int&amp;gt; opt = {0, 1, 2};

        for (int i = 3; i &amp;lt;= n; i++){
            opt.emplace_back(opt[i-1] + opt[i-2]);
        }

        return opt[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;house-robber&#34;&gt;House Robber&lt;/h2&gt;

&lt;p&gt;这道题很像学校里上算法课的时候给的例题。最重要的是想清楚状态转移方程是怎么样的。常规的动归思路：维护一个相同大小的一维数组，因为是一个累积的过程，并且不能取邻近位置，那么在位置i的最优解只有两种可能：不取位置i上的值，那么这个最优值就跟i-1位置上的一样；或者取i上的值加上i-2上的最优值。比较这两者之间的大小即可。这类问题可以枚举初始状态，然后顺着这个思路写出状态转移方程。并且一般都是从头到尾的一次循环。&lt;/p&gt;

&lt;p&gt;$$
f[i] = max(f[i-1], f[i-2] + A[i])
$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
long long houseRobber(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int len = nums.size();
    if (len == 0) return 0;
    if (len == 1) return nums[0];

    vector&amp;lt;long long&amp;gt; s = {nums[0], max(nums[0],nums[1])};

    for (int i=2;i&amp;lt;len;i++){
        s.emplace_back(max(s[i-1], s[i-2] + nums[i]));
    }

    return s[len-1];
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;longest-increasing-subsequence&#34;&gt;Longest Increasing Subsequence&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param nums: The integer array
     * @return: The length of LIS (longest increasing subsequence)
     */
    int longestIncreasingSubsequence(vector&amp;lt;int&amp;gt; nums) {
        // write your code here
        if (nums.empty()) return 0;

        vector&amp;lt;int&amp;gt; dp(nums.size(), 1);
        int rst = 0;

        for (int i = 1; i &amp;lt; nums.size(); i++){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if (nums[j] &amp;lt;= nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }                             
            }
            rst = max(rst, dp[i]);
        }
        return rst;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;word-break&#34;&gt;Word Break&lt;/h2&gt;

&lt;p&gt;在做了分割字符串II那道题之后，发现其实这两题一样一样的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;State: f[i] 表示前i个字符能否根据词典中的词被成功分词。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function: f[i] = or{f[j], j &amp;lt; i, letter in [j+1, i] can be found in dict}, 含义为小于i的索引j中只要有一个f[j]为真且j+1到i中组成的字符能在词典中找到时，f[i]即为真，否则为假。具体实现可分为自顶向下或者自底向上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Initialization: f[0] = true, 数组长度为字符串长度 + 1，便于处理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Answer: f[s.length]&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    bool wordBreak(string s, unordered_set&amp;lt;string&amp;gt; &amp;amp;dict) {
        // write your code here
        if (s.empty()) return true;
        if (dict.empty()) return false;

        int len = s.size();
        int max_word_len = 0;

        for (unordered_set&amp;lt;string&amp;gt;::iterator it = dict.begin(); it != dict.end(); ++it) {
            int thisLen = (*it).size();
            max_word_len = max(max_word_len, thisLen);
        }

        deque&amp;lt;bool&amp;gt; canBreak(len + 1, false);
        canBreak[0] = true;

        for (int i = 1; i &amp;lt; len + 1; ++i){
            for (int j = i - 1; j &amp;gt;= 0; --j){

                if (i - j &amp;gt; max_word_len) break;


                if (canBreak[j] &amp;amp;&amp;amp; dict.find(s.substr(j, i - j))!= dict.end()){
                    canBreak[i] = true;
                    break;
                }   
            }
        }
    return canBreak[len];    
    }
};


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>