<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>N Queens on PINEAL.ME</title>
    <link>http://pineal.github.io/tags/n-queens/</link>
    <description>Recent content in N Queens on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Jan 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://pineal.github.io/tags/n-queens/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Permutations and N-Queens</title>
      <link>http://pineal.github.io/posts/permutations_n_queens/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://pineal.github.io/posts/permutations_n_queens/</guid>
      <description>

&lt;h1 id=&#34;permutations-and-n-queens&#34;&gt;Permutations and N-Queens&lt;/h1&gt;

&lt;h2 id=&#34;permutation-from-stl-library&#34;&gt;Permutation from STL Library&lt;/h2&gt;

&lt;p&gt;最直接的做法：C++11中的STL中有关于排列的algorithm库可以直接用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/is_permutation&#34;&gt;std::is_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/prev_permutation&#34;&gt;std::prev_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/next_permutation&#34;&gt;std::next_permutation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他有什么用呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Changes the order of the elements in [Begin, end) according to the next permutation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return &lt;em&gt;False&lt;/em&gt; if the elements got the &amp;ldquo;normal&amp;rdquo;(lexicographical) order: that is, ascending order. So, to run through all permutations, you have to sort all elements and start a loop that calls this function as long as these algorithms return true.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution:
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt; nums){
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;

    if (nums.empty()){return {}};
    std::sort(nums.begin(), nums.end());

    do{
        result.emplace_back(nums);
    } while(next_permutation(nums.begin(), nums.end()));
    return result;
    }
};    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation-of-std-next-permutation&#34;&gt;Implementation of std::next_permutation()&lt;/h3&gt;

&lt;p&gt;大致思路为，我们先固定第一个数，然后对右边剩下的数做全排列。什么时候右边剩下的数完成了全排列呢？那就是当这些数变成了降序。然后我们才用第一个数。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation&#34;&gt;留着慢慢消化，反正直接让我写，我是写不出来。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//kan bu dong...
template&amp;lt;class BidirIt&amp;gt;
bool next_permutation(BidirIt first, BidirIt last)
{
    if (first == last) return false;
    BidirIt i = last;
    if (first == --i) return false;

    while (true) {
        BidirIt i1, i2;

        i1 = i;
        //if the elements are in ascending order
        if (*--i &amp;lt; *i1) {
            i2 = last;
            //find the next largest digit
            while (!(*i &amp;lt; *--i2));
            // and put it in front
            std::iter_swap(i, i2);
            //put the remaining digits in ascending order
            std::reverse(i1, last);
            return true;
        }
        //last purmutation
        if (i == first) {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个之后我们可以自己模拟 std::next_permutation()&lt;/p&gt;

&lt;h2 id=&#34;recursion-version-for-permutations&#34;&gt;Recursion Version for Permutations&lt;/h2&gt;

&lt;p&gt;常规的backtracking回溯，用DFS递归就行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permute(vector&amp;lt;int&amp;gt; nums) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (nums.size() == 0) return rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(rst, nums, v);
        return rst;
    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v){
        if (v.size() == nums.size()){
            rst.emplace_back(v);
            return ;
        }

        for (int i = 0; i &amp;lt; nums.size(); ++i){
            //can employ map to improve the time complexity
            //vector&amp;lt;bool&amp;gt; is not a container. do not use. alternates: deque&amp;lt;bool&amp;gt;, or bitset
            if (find(v.begin(), v.end(), nums[i]) != v.end()){
                continue;
            }
            v.emplace_back(nums[i]);
            backtracking(rst, nums, v);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;permutations-ii&#34;&gt;Permutations II&lt;/h2&gt;

&lt;p&gt;全排列去重。在循环的过程中加入while语句跳过相同的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permuteUnique(vector&amp;lt;int&amp;gt; &amp;amp;num) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permutations;
        if(num.size() == 0)
            return permutations;
        vector&amp;lt;int&amp;gt; curr;
        vector&amp;lt;bool&amp;gt; isVisited(num.size(), false);
        /* we need to sort the input array here because of this array
           contains the duplication value, then we need to skip the duplication
           value for the final result */
        sort(num.begin(),num.end());
        dfs(permutations,curr,num,isVisited);
        return permutations;
    }

    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ret, vector&amp;lt;int&amp;gt; curr, vector&amp;lt;int&amp;gt; num, vector&amp;lt;bool&amp;gt; isVisited)
    {
        if(curr.size() == num.size())
        {
            ret.push_back(curr);
            return;
        }

        for(int i = 0; i &amp;lt; num.size(); ++i)
        {
            if(isVisited[i] == false)
            {
                isVisited[i] = true;
                curr.push_back(num[i]);
                dfs(ret,curr,num,isVisited);
                isVisited[i] = false;
                curr.pop_back();
                while(i &amp;lt; num.size()-1 &amp;amp;&amp;amp; num[i] == num[i+1])
                //we use this while loop to skip the duplication value in the input array.
                    ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens&#34;&gt;N-Queens&lt;/h2&gt;

&lt;p&gt;经典的搜索题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string &#39;...Q&#39; shows a queen on forth position
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; solveNQueens(int n) {
        // write your code here
        vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; rst;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            rst.emplace_back(cur);
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens-ii&#34;&gt;N-Queens II&lt;/h2&gt;

&lt;p&gt;只要求solutions的个数就可以。这道题并不用动归解，还是要用搜索。和上一题基本没差别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    int totalNQueens(int n) {
         // write your code here
        int rst = 0;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(int&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            ++rst;
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>