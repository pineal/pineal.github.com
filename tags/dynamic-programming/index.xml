<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Sep 2018 09:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DP III - Knapsack Problems</title>
      <link>https://pineal.github.com/posts/dynamic_programming_iii/</link>
      <pubDate>Sat, 08 Sep 2018 09:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_iii/</guid>
      <description>

&lt;h1 id=&#34;背包问题&#34;&gt;背包问题&lt;/h1&gt;

&lt;h2 id=&#34;0-1-背包问题&#34;&gt;0-1 背包问题&lt;/h2&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;p&gt;Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays $values[0..n-1]$ and $weights[0..n-1]$ which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, &lt;strong&gt;find out the maximum value subset of $values[0..n-1]$ such that sum of the weights of this subset is smaller than or equal to W&lt;/strong&gt;. You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From: &lt;a href=&#34;https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/&#34;&gt;GeekforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;analyze&#34;&gt;Analyze&lt;/h3&gt;

&lt;p&gt;每件物品只有一个，那么考虑最后一个物品 $i$ ，一共就放或者不放两种状态选择。如果不放第 $i$ 件物品，那么问题转化为 前 $i-1$ 件物品放入到容量为 $j$ 的背包中, 即为 $M[i, j] = M[i-1, j]$。如果放第 $i$ 件物品，那么就是 前 $i-1$ 件物品放到容量为 $j-W_i$ 的背包中的 $value$ 加上把第 $i$ 件物品放入背包中的价值，即为 $M[i, j] = M[i-1, j - weights_i + values_i]$.&lt;/p&gt;

&lt;p&gt;此外，这个问题问得是得到的结果尽可能大，并不要求背包正好装满，初始化的时候都是 0。 如果要求恰好装满背包，那么除了 $M[0, 0]$ 初始化为 0 之外，其他都初始化为负无穷大。这样就可以保证最终的到的结果是一种恰好装满背包的最优解。&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(W + 1, 0));
    for (int i = 1; i &amp;lt;= n; i++) {
        for (int j = 1; j &amp;lt;= W; j++) {
            if (weights[i - 1] &amp;lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    return M.back().back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;space-optimization&#34;&gt;Space Optimization&lt;/h3&gt;

&lt;p&gt;如果对以上代码填表，可以更直观的显示出当前状态只跟上一行的状态有关。所以空间复杂度可以优化到 $O(n)$.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;int&amp;gt; M(W + 1, 0);
    for (int i = 0; i &amp;lt; n; i++) {
        for (int j = W; j &amp;gt;= weights[i]; j--) {
            M[j] = max(M[j], values[i] + M[j - weights[i]]);
        }
    }
    return M.back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;print-all-items&#34;&gt;Print all items&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int knapsack(int W, vector&amp;lt;int&amp;gt; weights, vector&amp;lt;int&amp;gt; values) {
    int n = weights.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(W + 1, 0));
    //M[0][0] = 0;
    for (int i = 0; i &amp;lt;= n; i++) {
        for (int j = 0; j &amp;lt;= W; j++) {
            if (weights[i - 1] &amp;lt;= j) {
                M[i][j] = max(values[i-1] + M[i-1][j - weights[i - 1]], M[i-1][j]);
            }
            else {
                M[i][j] = M[i-1][j];
            }
        }
    }
    int res =  M.back().back();
    for (int i = n; i &amp;gt; 0 &amp;amp;&amp;amp; res &amp;gt; 0; i--) {
        if (res == M[i-1][W])
            continue;
        else {
            cout &amp;lt;&amp;lt; weights[i-1] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        res -= values[i-1];
        W = W - weights[i-1];
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;house-robber&#34;&gt;House Robber&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() &amp;lt;= 2) {
            return max(nums[0], nums.back());
        }
        vector&amp;lt;int&amp;gt; M(nums.size(), 0);
        M[0] = nums[0];
        M[1] = max(nums[0], nums[1]);
        for (int i = 2; i &amp;lt; M.size(); i++) {
            M[i] = max(M[i - 2] + nums[i], M[i - 1]);
        }
        return M.back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完全背包问题&#34;&gt;完全背包问题&lt;/h2&gt;

&lt;p&gt;由于每个物品的数量变成了无限，那么从0-1背包问题转变过来，从取或者不取两种状态转换到了取0个，取1个到最多取 $k = \frac{Capacity}{weights[i]}$ 个。&lt;/p&gt;

&lt;h3 id=&#34;example-coin-change-ii&#34;&gt;Example - Coin Change II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount*amount)
//O(mn)
class Solution {
public:
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        /*
        M[i][j] =&amp;gt; the number of combinations to make up amount j with the first i types of coins
        M[i][j] =   M[i-1][j],                   use coins[i-1] 0 times
                  + M[i-1][j - coins[i-1]]       use coins[i-1] 1 time
                  + M[i-1][j- coins[i-1] * 2]    use coins[i-1] 2 times
                  + M[i-1][j- coins[i-1] * 3]    use coins[i-1] 3 times
                  ...
        */
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                M[i][j] = 0;
                for (int k = 0; k * coins[i - 1] &amp;lt;= j; k++) {
                    M[i][j] += M[i - 1][j - k * coins[i - 1]];
                }
            }
        }
        return M.back().back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;time-optimization&#34;&gt;Time Optimization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount)
//O(mn)
class Solution {
public:
    /*
        1.
        f[i][j] = f[i-1][j]
                + f[i-1][j - coins[i-1]]
                + f[i-1][j - coins[i-1] * 2]
                + f[i-1][j - coins[i-1] * 3]
                ...
        2.
        f[i][j - coins[i-1]]
                = f[i-1][j-coins[i-1]]
                + f[i-1][j-coins[i-1] * 2]
                + f[i-1][j-coins[i-1] * 3]
                ...
        3.
        f[i][j] = f[i-1][j]
                + f[i][j - coins[i-1]]
    */
    
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n + 1, vector&amp;lt;int&amp;gt;(amount + 1, 0));
        M[0][0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                M[i][j] = M[i-1][j] + (coins[i-1] &amp;lt;= j? M[i][j - coins[i - 1]] : 0);
            }
        }
        return M.back().back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;space-optimization-1&#34;&gt;Space Optimization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//O(n*amount)
//O(amount)
class Solution {
public:
    int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) {
        int n = coins.size();
        vector&amp;lt;int&amp;gt; M(amount + 1, 0);
        M[0] = 1;
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 0; j &amp;lt;= amount; j++) {
                if (coins[i-1] &amp;lt;= j) {
                    M[j] += M[j - coins[i -1]];
                }
            }
        }
        return M.back();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;minimum-number-of-refueling-stops&#34;&gt;Minimum Number of Refueling Stops&lt;/h3&gt;

&lt;p&gt;Recursive - LTE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; stations) {
        if (stations.empty()) return startFuel &amp;gt;= target? 0 : -1;
        stations.insert(stations.begin(), {0, startFuel});
        int res = INT_MAX;
        helper(0, res, 0, startFuel, stations, target);
        return res == INT_MAX? -1 : res;
    }
    
    
    void helper(int level, int &amp;amp; res, int num, int remain, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; stations, int target) {
        if (remain &amp;lt; 0) {
            return;
        }
        if (level == stations.size()) {            
            res = min(res, num);
            return;
        }
        int cost = (level == stations.size() - 1)? target - stations[level][0] : stations[level + 1][0] - stations[level][0];
        int refuel = (level == stations.size() - 1)? 0 : stations[level+1][1];
        if (cost &amp;lt;= remain) {
            helper(level + 1, res, num, remain - cost, stations, target);
            helper(level + 1, res, num + 1, remain - cost + refuel, stations, target);        
        }

    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DP knapsack solution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    // dp[i][j]: pick j stops to refill from [0, i] stops, how far away can we go
    // dp[i][j] = max {dp[i-1][j] &amp;gt;= stations[i-1][0] ? dp[i-1][j] : 0
    //          =      dp[i-1][j-1] &amp;gt;= stations[i-1][0] ? dp[i-1][j-1] + stations[i-1][1] : 0 }
    // 
    int minRefuelStops(int target, int startFuel, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; stations) {
        int n = stations.size();
        vector&amp;lt;vector&amp;lt;long&amp;gt;&amp;gt; M(n+1, vector&amp;lt;long&amp;gt;(n+1, 0));
        
        M[0][0] = startFuel;
        for (int i = 1; i &amp;lt;= n; i++) {
            if (startFuel &amp;gt;= stations[i-1][0])
                M[i][0] = startFuel;
        }
        
        for (int i = 1; i &amp;lt;= n; i++) {
            for (int j = 1; j &amp;lt;= i; j++) {
                if (M[i-1][j] &amp;gt;= stations[i-1][0]) {
                    M[i][j] = M[i-1][j];
                }
                if (M[i-1][j-1] &amp;gt;= stations[i-1][0]) {
                    M[i][j] = max(M[i][j], M[i-1][j-1] + stations[i-1][1]);
                }
                    
            }
        }
        for (int t = 0; t &amp;lt;= n; ++t)
            if (M[n][t] &amp;gt;= target) return t;
        return -1;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO: space optimization&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf&#34;&gt;背包九讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ZKAILBWl08g&#34;&gt;https://www.youtube.com/watch?v=ZKAILBWl08g&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming I</title>
      <link>https://pineal.github.com/posts/dynamic_programming_i/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dynamic_programming_i/</guid>
      <description>

&lt;h2 id=&#34;max-product-of-cutting-rope&#34;&gt;Max Product Of Cutting Rope&lt;/h2&gt;

&lt;p&gt;Given a rope with positive integer-length n, how to cut the rope into m integer-length parts with length $p[0], p[1], &amp;hellip;,p[m-1]$, in order to get the maximal product of $p[0]p[1] &amp;hellip; p[m-1]$? m is determined by you and must be greater than 0 (at least one cut must be made). Return the max product you can have.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;n = 12, the max product is 3 * 3 * 3 * 3 = 81 (cut the rope into 4 pieces with length of each is 3).&lt;/p&gt;

&lt;h3 id=&#34;top-down-recursion&#34;&gt;Top-Down Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    if (length &amp;lt;= 2) {
      return 1;
    }
    int res = 0;
    for (int i = 1; i &amp;lt; length - 1; i++) {
      res = max(res, max(length - i, maxProduct(length - i)) * i);
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-down-recursion-memorization&#34;&gt;Top-Down Recursion + Memorization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    if (length &amp;lt;= 2) {
      return 1;
    }
    vector&amp;lt;int&amp;gt; M(length + 1, 0);
    return maxProductHelper(length, M);
  }
  
  int maxProductHelper(int length, vector&amp;lt;int&amp;gt; &amp;amp; M) {
    if (M[length]) {
      return M[length];
    }
    int res = 0;
    for (int i = 1; i &amp;lt; length - 1; i++) {
      res = max(res, max(length - i, maxProductHelper(length - i, M)) * i);
    }
    M[length] = res;
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-dp-solution&#34;&gt;Bottom-up DP Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int maxProduct(int length) {
    vector&amp;lt;int&amp;gt; M(length + 1, 0);
    //M[i] =&amp;gt; max product of first i length rope
    for (int i = 1; i &amp;lt; length + 1; i++) {
      for (int j = 0; j &amp;lt; i; j++) {
        M[i] = max(M[i], max(j, M[j])/*take care of corner case*/ * (i - j));
      }
    }
    return M.back();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cut-rope-ii&#34;&gt;Cut rope II&lt;/h2&gt;

&lt;p&gt;There is a wooden stick with length L &amp;gt;= 1, we need to cut it into pieces, where the cutting positions are defined in an int array A. The positions are guaranteed to be in ascending order in the range of $[1, L - 1]$. The cost of each cut is the length of the stick segment being cut. Determine the minimum total cost to cut the stick into the defined pieces.&lt;/p&gt;

&lt;h3 id=&#34;top-down-recursion-1&#34;&gt;Top-Down Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    return helper(0, cuts.size() - 1, cuts);
  }
  
  int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; cuts) {
    if (start + 1 == end) {
      return 0;
    }
 
    int res = INT_MAX;
    for (int k = start + 1; k &amp;lt; end; k++) {
      res = min(res, helper(start, k, cuts) + 
                cuts[end] - cuts [start] + 
                helper(k, end, cuts));
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;top-down-recursion-memorization-1&#34;&gt;Top-Down Recursion + Memorization&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    int n = cuts.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    return helper(0, n - 1, cuts, M);
  }

  int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; cuts, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; M) {
    if (start + 1 == end) {
      return 0;
    }
    if (M[start][end] != INT_MAX) {
      return M[start][end];
    } 
    int res = INT_MAX;
    for (int k = start + 1; k &amp;lt; end; k++) {
      res = min(res, helper(start, k, cuts, M) + 
                cuts[end] - cuts [start] + 
                helper(k, end, cuts, M));
    }
    M[start][end] = res;
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int minCost(vector&amp;lt;int&amp;gt; cuts, int length) {
    cuts.insert(cuts.begin(),0);
    cuts.emplace_back(length);
    int n = cuts.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    for (int right = 1; right &amp;lt; n; right++) {
      for (int left = right - 1; left &amp;gt;= 0; left--) {
        if (left + 1 == right) {
          M[left][right] = 0;
        }
        else {
          for (int k = left + 1; k &amp;lt;= right - 1; k++) {
            M[left][right] = min(M[left][right],
                          M[left][k] + M[k][right] + cuts[right] - cuts[left]);            
          }
        }
      }
    }
    return M.front().back();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;merge-stone&#34;&gt;Merge Stone&lt;/h2&gt;

&lt;p&gt;We have a list of piles of stones, each pile of stones has a certain weight, represented by an array of integers. In each move, we can merge two adjacent piles into one larger pile, the cost is the sum of the weights of the two piles. We merge the piles of stones until we have only one pile left. Determine the minimum total cost.&lt;/p&gt;

&lt;p&gt;stones is not null and is length of at least 1&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;{4, 3, 3, 4}, the minimum cost is 28&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;merge first 4 and first 3, cost 7&lt;/li&gt;
&lt;li&gt;merge second 3 and second 4, cost 7&lt;/li&gt;
&lt;li&gt;merge two 7s, cost 14&lt;/li&gt;
&lt;li&gt;total cost = 7 + 7 + 14 = 28&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recursion-memo&#34;&gt;Recursion + memo&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; stones) {
    return helper(0, stones.size() - 1, stones);
  }
  
  int helper(int left, int right, const vector&amp;lt;int&amp;gt; &amp;amp; stones) {
    if (left == right) {
      return 0;
    }
    if (left + 1 == right) {
      return stones[left] + stones[right];
    }
    
    int sum = 0;
    for (int i = left; i &amp;lt;= right; i++) {
      sum += stones[i];
    }
    
    int res = INT_MAX;
    for (int k = left; k &amp;lt;= right - 1; k++) {
      res = min(res, 
                helper(left, k, stones) + helper(k + 1, right, stones) + sum);
    }
    return res;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming-1&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int minCost(vector&amp;lt;int&amp;gt; stones) {
    int n = stones.size();
    //sum[i] ==&amp;gt; sum from stones[0] to stones[i]
    vector&amp;lt;int&amp;gt; sums(n);
    for (int i = 0; i &amp;lt; stones.size(); i++) {
      if (i == 0) {
        sums[i] = stones[i];
      }
      else {
        sums[i] = sums[i - 1] + stones[i];
      }
    }
    //M[i][j] =&amp;gt; min cost from stones[i] to stones[j]
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, INT_MAX));
    for (int right = 0; right &amp;lt; n; right++) {
      for (int left = right; left &amp;gt;= 0; left--) {
        int sum = left == 0? sums[right] : sums[right] - sums[left - 1];
        if (left == right) {
          M[left][right] = 0;
          continue;
        }
        //k =&amp;gt; last stone to merge
        for (int k = left; k &amp;lt;= right; k++) {
          int rightsub = k == right? 0 : M[k + 1][right];
          M[left][right] = min(M[left][right], 
                               M[left][k] + sum + (k == right? 0 : M[k + 1][right]));
        }
      }    
    }
    return M.front().back();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;burst-bsllons&#34;&gt;Burst Bsllons&lt;/h2&gt;

&lt;p&gt;Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get $nums[left] * nums[i] * nums[right]$ coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.&lt;/p&gt;

&lt;p&gt;Find the maximum coins you can collect by bursting the balloons wisely.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;You may imagine $nums[-1] = nums[n] = 1$. They are not real therefore you can not burst them.&lt;/p&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Input: {3,1,5,8}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nums = {3,1,5,8} &amp;ndash;&amp;gt; {3,5,8} &amp;ndash;&amp;gt;   {3,8}   &amp;ndash;&amp;gt;  {8}  &amp;ndash;&amp;gt; {}&lt;/li&gt;
&lt;li&gt;coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recursion&#34;&gt;Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        return helper(0, nums.size() - 1, nums);
    }
    
    int helper(int start, int end, vector&amp;lt;int&amp;gt; &amp;amp; nums) {
        if (start + 1 == end) {
            return 0;
        }
        int res = 0;
        for (int i = start + 1; i &amp;lt; end; i++) {
            res = max(res, 
                      helper(start, i, nums) + 
                      nums[start] * nums[i] * nums[end] + 
                      helper(i, end, nums));
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursion-memo-1&#34;&gt;Recursion + Memo&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        int n = nums.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, 0));
        return helper(0, nums.size() - 1, nums, M);
    }
    
    int helper(int start, int end, const vector&amp;lt;int&amp;gt; &amp;amp; nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; M) {
        if (start + 1 == end) {
            return 0;
        }
        if (M[start][end]) {
            return M[start][end];
        }
        int res = 0;
        for (int i = start + 1; i &amp;lt; end; i++) {
            res = max(res, 
                      helper(start, i, nums, M) + 
                      nums[start] * nums[i] * nums[end] + 
                      helper(i, end, nums, M));
        }
        M[start][end] = res;
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-programming-2&#34;&gt;Dynamic Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  int maxCoins(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        nums.insert(nums.begin(), 1);
        nums.push_back(1);
        int n = nums.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; M(n, vector&amp;lt;int&amp;gt;(n, 0));

        for (int right = 2; right &amp;lt; n; right++) {
            for (int left = right - 2; left &amp;gt;= 0; left--) {
                for (int k = left + 1; k &amp;lt; right; k++) {
                    M[left][right] = max(M[left][right],
                                        M[left][k] + nums[left] * nums[k] * nums[right] + M[k][right]);
                }
            }
        }
        return M[0][n - 1];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>