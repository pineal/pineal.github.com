<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bit Manipulation on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/bit-manipulation/</link>
    <description>Recent content in Bit Manipulation on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Apr 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/bit-manipulation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bit Manipulation</title>
      <link>https://pineal.github.com/posts/bit_manipulation/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/bit_manipulation/</guid>
      <description>

&lt;h1 id=&#34;summary-of-basic-bit-manipulation&#34;&gt;Summary of Basic Bit Manipulation&lt;/h1&gt;

&lt;h2 id=&#34;count-1-in-binary&#34;&gt;Count 1 in Binary&lt;/h2&gt;

&lt;p&gt;数的二进制表示中有多少位1. 有两种方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每次把各位的数和 1 做 &amp;amp; 运算，然后计数，右移进行下一位。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        for (int i = 0; i &amp;lt; sizeof(int)*8; i++) {
            counter += num &amp;amp; 1;
            num &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;把 num 和 num - 1 做 &amp;amp; 运算， 直到num为0，有多少次运算就有多少个1. 因为每次“&amp;amp;”都会去掉num最右边的1.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        // write your code here
        int counter = 0;
        while (num) {
            num &amp;amp;= num - 1;
            counter++;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个用法判断是不是2的整数次幂很容易，因为2的整数次幂必然只有1个bit的1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkPowerOf2(int n) {
    // write your code here
    return n &amp;gt; 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flip-bits&#34;&gt;Flip Bits&lt;/h2&gt;

&lt;p&gt;用到了xor的性质。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param a, b: Two integer
     *return: An integer
     */
    int bitSwapRequired(int a, int b) {
        // write your code here
        int counter = 0;
        int c = a^b;
        for (int i = 0; i &amp;lt; 32; i++) {
            counter += c &amp;amp; 1;
            c &amp;gt;&amp;gt;= 1;
        }
        return counter;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-b-problem&#34;&gt;A + B problem&lt;/h2&gt;

&lt;p&gt;这题。
         主要利用异或运算来完成。
         异或运算有一个别名叫做：不进位加法。
         那么a ^ b就是a和b相加之后，该进位的地方不进位的结果。
         然后下面考虑哪些地方要进位，自然是a和b里都是1的地方。
         a &amp;amp; b就是a和b里都是1的那些位置，a &amp;amp; b &amp;lt;&amp;lt; 1 就是进位
         之后的结果。所以：a + b = (a ^ b) + (a &amp;amp; b &amp;lt;&amp;lt; 1)
         。令a&amp;rsquo; = a ^ b, b&amp;rsquo; = (a &amp;amp; b) &amp;lt;&amp;lt; 1
         可以知道，这个过程是在模拟加法的运算过程，进位不可能
         一直持续，所以b最终会变为0。因此重复做上述操作就可以
         求得a + b的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
       while (b != 0) {
            int _a = a ^ b;
            int _b = (a &amp;amp; b) &amp;lt;&amp;lt; 1;
            a = _a;
            b = _b;
        }
        return a;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-bits&#34;&gt;Update Bits&lt;/h2&gt;

&lt;p&gt;Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.&lt;/p&gt;

&lt;p&gt;把一个数的 ［j， i］ 之间的bits 用另一个数去填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        // write your code here
        int right_part = n &amp;amp; ((1 &amp;lt;&amp;lt; i) - 1);
        // The behavior of right shift &amp;gt;= 32 is undefined in C++.
        int left_part = j &amp;gt;= 31 ? 0 : (n &amp;gt;&amp;gt; (j + 1)) &amp;lt;&amp;lt; (j + 1);
        return left_part | (m &amp;lt;&amp;lt; i) | right_part;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先用一个 mask 把 i 右边的数给取出来。
左边的数要这么取：先把bits右移 j + 1位，然后再左移 j + 1位，这样右边的数就都清空了。
最后一步把 m 左移后再把左边部分和右边部分用 ｜ 粘起来。
这种思想还可以用来做高地位互换等。把前一半的数右移，把后一半的数左移，然后 ｜ 起来。&lt;/p&gt;

&lt;h2 id=&#34;swap-two-variables&#34;&gt;swap two variables&lt;/h2&gt;

&lt;p&gt;如何不用第三个临时变量来交换两个数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(int &amp;amp;a, int &amp;amp;b){
	if (a != b){
		  a ^= b;
      b ^= a;
      a ^= b;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;abs&#34;&gt;abs&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//取符号位
	int a = -100;
	int i = a &amp;gt;&amp;gt; 31;
	//i = 0 正数
	if(i == 0){
		printf(&amp;quot;%d\n&amp;quot;,a);
	}
	//i = 1 负数
	else{
		printf(&amp;quot;%d\n&amp;quot;,~a + 1);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-complement&#34;&gt;Number Complement&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int findComplement(int num) {
        unsigned mask = ~0;
        while (num &amp;amp; mask) mask &amp;lt;&amp;lt;= 1;
        return ~mask &amp;amp; ~num;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>