<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backtracking on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/backtracking/</link>
    <description>Recent content in Backtracking on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 Mar 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/backtracking/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Basic Backtracking Problems</title>
      <link>https://pineal.github.com/posts/backtracking/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/backtracking/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Backtracking 类型的题目最重要的是想清楚每一层在做什么，以及到下一层一共有几个分叉。&lt;/p&gt;

&lt;p&gt;时间复杂度： branch factor ^ level&lt;/p&gt;

&lt;p&gt;时间复杂度： call stack -&amp;gt; level&lt;/p&gt;

&lt;h2 id=&#34;subsets&#34;&gt;Subsets&lt;/h2&gt;

&lt;p&gt;这一类的题目的框架为，在递归树中的第 i 层，代表正在处理 nums 里的第 i 个元素。 从该层的父节点一定会伸展出两个分叉： 第一个分叉代表着一层会放这个元素，第二个分叉代表不放这个元素。 这样出来的递归树非常平衡。&lt;/p&gt;

&lt;h3 id=&#34;subsets-i-http-www-lintcode-com-en-problem-subsets&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        sort(nums.begin(), nums.end());
        vector&amp;lt;int&amp;gt; cur;
        dfs(rst, cur, nums, 0);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; rst, vector&amp;lt;int&amp;gt; &amp;amp; cur, const vector&amp;lt;int&amp;gt;&amp;amp; nums, int level) {
        if (level == nums.size()) {
            rst.emplace_back(cur);
            return;
        }
        cur.emplace_back(nums[level]);
        dfs(rst, cur, nums, level + 1);
        cur.pop_back();
        dfs(rst, cur, nums, level + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subsets-ii-dedup-http-www-lintcode-com-en-problem-subsets-ii&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II - Dedup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;去重首先需要排序，要利用有序性。从递归树上看的话，放的那一个分支不变，因为我们是先做放元素，再走不放该元素的。如果不放该元素，那么此时的结果会跟父节点的是重复的。ab1 -&amp;gt; ab1b2, ab1。  a -&amp;gt; ab2, a。 ab1 和 ab2 不能同时出现。 所以这个分支就需要直接跳到跟当前层元素不同的那一层。在代码上体现就是level++。&lt;/p&gt;

&lt;p&gt;ab1 ab2 出发产生的分支都是完全一样的。那么我们可以去掉ab2。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; cur;
        sort(nums.begin(), nums.end());
        dfs(rst, nums, 0, cur);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; result, vector&amp;lt;int&amp;gt; &amp;amp; nums, int level, vector&amp;lt;int&amp;gt; &amp;amp; cur) {
        if (level == nums.size()) {
            result.emplace_back(cur);
            return;
        }
        
        cur.emplace_back(nums[level]);
        dfs(result, nums, level + 1, cur);
        cur.pop_back();
        //pruning techniques
        while (level &amp;lt; nums.size() - 1 &amp;amp;&amp;amp; nums[level] == nums[level+1]) {
            level++;
        }                
        dfs(result, nums, level + 1, cur);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variant-i-combination&#34;&gt;Variant I - Combination&lt;/h3&gt;

&lt;p&gt;整体框架跟 Subset I 一模一样， 唯一的区别是 base case return 的时候加上条件： 当前结果的长度为 k 才返回。
原题链接：&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;去重的方法也应该和 Subset II 一样。&lt;/p&gt;

&lt;h3 id=&#34;variant-ii-permutations-of-inserting-spaces-into-a-string&#34;&gt;Variant II - Permutations of inserting spaces into a string&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&#34;&gt;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还有别的问法，比如如何分一个给定的数组成两部分，两部分的和相同。或者要在一串数组/字符串里面插入。&lt;/li&gt;
&lt;li&gt;时间复杂度是$O(2^n)$&lt;/li&gt;
&lt;li&gt;另一种常见做法：k层，每层的意义为最后的结果钟第几个元素应该是什么。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;permutations&#34;&gt;Permutations&lt;/h2&gt;

&lt;p&gt;因为全排列需要全部元素都出现，唯一不同的是他们的顺序，那么我们可以不停两两交换数组中的元素，得到全排列。&lt;/p&gt;

&lt;p&gt;Time n * (n-1) * (n - 2) = O(n!)&lt;/p&gt;

&lt;p&gt;Space O(n)&lt;/p&gt;

&lt;p&gt;如果要求 一个长度不变的array/string 的 permutation 只是 order 不一样，就可以考虑用 swap-swap 的方法。&lt;/p&gt;

&lt;h3 id=&#34;permutations-i&#34;&gt;Permutations I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
  if (input == &amp;quot;&amp;quot;) {
    return {&amp;quot;&amp;quot;};
  }
  vector&amp;lt;string&amp;gt; result;
  helper(result, input, 0);
  return result;
  }
  
private:
  void swap(string &amp;amp;s, int i, int j) {
    auto temp = s[i];
    s[i] = s[j];
    s[j] = temp;
  }

  void helper(vector&amp;lt;string&amp;gt; &amp;amp; result, string &amp;amp; s, int index) {
    if (index == s.size()){
      result.emplace_back(s);
      return;
    }
    for (int i = index; i &amp;lt; s.size(); i++) {
      swap(s, i, index);
      helper(result, s, index + 1);
      swap(s, i, index);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;permutations-ii-dedup&#34;&gt;Permutations II - Dedup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
    vector&amp;lt;string&amp;gt; result;
    helper(input, result, 0);
    return result;
  }
  
private:
  void helper(string &amp;amp; input, vector&amp;lt;string&amp;gt; &amp;amp; result, int level) {
    if (level == input.size()) {
        result.emplace_back(input);
        return;
    }
    
    set&amp;lt;char&amp;gt; charset;
    for (int i = level; i &amp;lt; input.size(); ++i) {
      if (charset.find(input[i]) != charset.end()) {
        continue;
      }
      charset.emplace(input[i]);
      swap(input[i], input[level]);
      helper(input, result, level + 1);
      swap(input[i], input[level]);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parenthesis-problems&#34;&gt;Parenthesis Problems&lt;/h2&gt;

&lt;h3 id=&#34;valid&#34;&gt;Valid&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Given N pairs of parentheses “()”, return a list with all the valid permutations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void validParenthesisHelper(int l, int r, int n, string &amp;amp; cur, vector&amp;lt;string&amp;gt; &amp;amp; res) {
    if (l + r ==  2 * n) {
        res.emplace_back(cur);
        return;
    }
    
    if (l &amp;lt; n) {
        cur += &amp;quot;(&amp;quot;;
        validParenthesisHelper(l + 1, r, n, cur, res);
        cur.pop_back();
    }
    
    if (r &amp;lt; l) {
        cur += &amp;quot;)&amp;quot;;
        validParenthesisHelper(l, r + 1, n, cur, res);
        cur.pop_back();
    }
}

vector&amp;lt;string&amp;gt; validParenthesis(int n) {
    vector&amp;lt;string&amp;gt; res;
    string cur;
    validParenthesisHelper(0, 0, n, cur, res);
    return res;
}

void testvalidParenthesis() {
    auto res = validParenthesis(3);
    for (const auto &amp;amp; str : res) {
        cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time: O(2^2n)
Space: O(2n)&lt;/p&gt;

&lt;h2 id=&#34;coin-combinations&#34;&gt;Coin Combinations&lt;/h2&gt;

&lt;h3 id=&#34;99-cents&#34;&gt;99 Cents&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&#34;&gt;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void coinCombinationHelper(const vector&amp;lt;int&amp;gt; &amp;amp; coins,
                           vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res,
                           vector&amp;lt;int&amp;gt; &amp;amp; cur,
                           int remaining,
                           int level) {
    if (level == coins.size()) {
        if (remaining == 0) {
            res.emplace_back(cur);
        }
        return;
    }

    int n = remaining/coins[level];
    for (int i = 0; i &amp;lt;= n; i++) {
        cur.emplace_back(i);
        coinCombinationHelper(coins, res, cur, remaining - i * coins[level], level + 1);
        cur.pop_back();
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; coinCombination(const vector&amp;lt;int&amp;gt; &amp;amp; coins, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; cur;
    coinCombinationHelper(coins, res, cur, target, 0);
    return res;
}

void testCoinsCombination() {
    vector&amp;lt;int&amp;gt; coins = {25, 10, 5, 1};
    auto res = coinCombination(coins, 99);
    for (const auto &amp;amp; v : res) {
        for (const auto &amp;amp; c : v) {
            cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;find-all-valid-combinations-of-factors-that-form-an-integer&#34;&gt;find all valid combinations of factors that form an integer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&#34;&gt;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;backtracking-on-tree&#34;&gt;Backtracking on Tree&lt;/h2&gt;

&lt;h3 id=&#34;longest-consecutive-sequence&#34;&gt;Longest consecutive sequence&lt;/h3&gt;

&lt;p&gt;int global_max = INT_MIN;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int helper(TreeNode* root) {
  if (root == nullptr) {
    return 0;
  }

  int left = 0;
  int right = 0;

  if (root-&amp;gt;left &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;val -1 == root-&amp;gt;val) {
    left = helper(root-&amp;gt;left);
  } 
  if (root-&amp;gt;right &amp;amp;&amp;amp; root-&amp;gt;right-&amp;gt;val -1 == root-&amp;gt;val) {
    right = helper(root-&amp;gt;right);
  } 
  int local_max = max(left, right) + 1;
  global_max = max(global_max, local_max)l
  return local_max;

} 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>https://pineal.github.com/posts/palindrome_partitioning/</link>
      <pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/palindrome_partitioning/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;分隔回文串问题，共有两题，分别是搜索和动归的代表题型。刚碰到的时候理解比较难，单独拿出来看一看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning/&#34;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning-ii/&#34;&gt;Palindrome Partitioning II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;palindrome-partitioning-ii&#34;&gt;Palindrome Partitioning II&lt;/h2&gt;

&lt;p&gt;求最小的分割次数，一维的一个数组，满足动态规划的条件。&lt;/p&gt;

&lt;p&gt;提示：动归字符串时基本上要把f[0]空出来，这样就需要n+1长度的一个数组来记录最优值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minCut(string s) {
        int len = s.size();
        if (len &amp;lt;= 1) return 0;

//用一个矩阵来记录子字符串s[i:j]是否为回文串

        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; mat = vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt;(len, vector&amp;lt;bool&amp;gt;(len, true));

        for (int i = len; i &amp;gt;= 0; --i) {
            for (int j = i; j &amp;lt; len; ++j) {
//                if((i+1&amp;gt;j-1 || isPal[i+1][j-1]) &amp;amp;&amp;amp; s[i]==s[j])
//                    isPal[i][j] = true;                
//很多答案给的是这样的判断方法，个人觉得没有下面的清楚，边界条件实际上就两种，要么i==j要么i和j靠在一起。其他就判断xSx是不是回文串（如果S是的话）              
                if (j == i) {
                    mat[i][j] = true;
                } else if (j == i + 1) {
                    mat[i][j] = (s[i] == s[j]);
                } else {
                    mat[i][j] = ((s[i] == s[j]) &amp;amp;&amp;amp; mat[i + 1][j - 1]);
                }
            }
        }

        vector&amp;lt;int&amp;gt; cut(len + 1, INT_MAX);

// 真正的sequence DP: cut[i]表示到i的minCut
// 到位置i时候，就判断j+1到i是不是一个回文串（到角标就变成了和j , i-1）
// 就找所有比i小的j的位置上能切的minCut + 1（此时条件为上面那个矩阵）
//

        for (int i = 1; i &amp;lt; 1 + len; ++i) {
            for (int j = 0; j &amp;lt; i; ++j) {
                if (mat[j][i - 1]) {
                    cut[i] = min(cut[i], 1 + cut[j]);
                }
            }
        }

        return cut[len];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个&lt;a href=&#34;https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space&#34;&gt;优化的解&lt;/a&gt;以后留着看。&lt;/p&gt;

&lt;h2 id=&#34;palindrome-partitioning&#34;&gt;Palindrome Partitioning&lt;/h2&gt;

&lt;p&gt;这题求的是具体的分隔方法，基本上就是DFS搜索加回溯的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;
        if (s.empty()) return result;

        vector&amp;lt;string&amp;gt; palindromes;
        dfs(s, 0, palindromes, result);

        return result;
    }

private:
    void dfs(string s, int pos, vector&amp;lt;string&amp;gt; &amp;amp;palindromes,
             vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;ret) {

        if (pos == s.size()) {
            ret.push_back(palindromes);
            return;
        }

        for (int i = pos + 1; i &amp;lt;= s.size(); ++i) {
            string substr = s.substr(pos, i - pos);
            if (!isPalindrome(substr)) {
                continue;
            }

            palindromes.push_back(substr);
            dfs(s, i, palindromes, ret);
            palindromes.pop_back();
        }
    }

    bool isPalindrome(string s) {
        if (s.empty()) return false;

        int n = s.size();
        for (int i = 0; i &amp;lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }

        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当状态可以用index 从 0 到 i 可以表示，一维DP往往是足够的。
当过去的状态不能从i 开始， 那么i-j开始，需要用二维DP。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>