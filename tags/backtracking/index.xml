<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backtracking on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/backtracking/</link>
    <description>Recent content in Backtracking on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Feb 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/backtracking/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>https://pineal.github.com/posts/palindrome_partitioning/</link>
      <pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/palindrome_partitioning/</guid>
      <description>

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;p&gt;分隔回文串问题，共有两题，分别是搜索和动归的代表题型。刚碰到的时候理解比较难，单独拿出来看一看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning/&#34;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/palindrome-partitioning-ii/&#34;&gt;Palindrome Partitioning II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;palindrome-partitioning-ii&#34;&gt;Palindrome Partitioning II&lt;/h2&gt;

&lt;p&gt;求最小的分割次数，一维的一个数组，满足动态规划的条件。&lt;/p&gt;

&lt;p&gt;提示：动归字符串时基本上要把f[0]空出来，这样就需要n+1长度的一个数组来记录最优值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int minCut(string s) {
        int len = s.size();
        if (len &amp;lt;= 1) return 0;

//用一个矩阵来记录子字符串s[i:j]是否为回文串

        vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt; mat = vector&amp;lt;vector&amp;lt;bool&amp;gt; &amp;gt;(len, vector&amp;lt;bool&amp;gt;(len, true));

        for (int i = len; i &amp;gt;= 0; --i) {
            for (int j = i; j &amp;lt; len; ++j) {
//                if((i+1&amp;gt;j-1 || isPal[i+1][j-1]) &amp;amp;&amp;amp; s[i]==s[j])
//                    isPal[i][j] = true;                
//很多答案给的是这样的判断方法，个人觉得没有下面的清楚，边界条件实际上就两种，要么i==j要么i和j靠在一起。其他就判断xSx是不是回文串（如果S是的话）              
                if (j == i) {
                    mat[i][j] = true;
                } else if (j == i + 1) {
                    mat[i][j] = (s[i] == s[j]);
                } else {
                    mat[i][j] = ((s[i] == s[j]) &amp;amp;&amp;amp; mat[i + 1][j - 1]);
                }
            }
        }

        vector&amp;lt;int&amp;gt; cut(len + 1, INT_MAX);

// 真正的sequence DP: cut[i]表示到i的minCut
// 到位置i时候，就判断j+1到i是不是一个回文串（到角标就变成了和j , i-1）
// 就找所有比i小的j的位置上能切的minCut + 1（此时条件为上面那个矩阵）
//

        for (int i = 1; i &amp;lt; 1 + len; ++i) {
            for (int j = 0; j &amp;lt; i; ++j) {
                if (mat[j][i - 1]) {
                    cut[i] = min(cut[i], 1 + cut[j]);
                }
            }
        }

        return cut[len];
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个&lt;a href=&#34;https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space&#34;&gt;优化的解&lt;/a&gt;以后留着看。&lt;/p&gt;

&lt;h2 id=&#34;palindrome-partitioning&#34;&gt;Palindrome Partitioning&lt;/h2&gt;

&lt;p&gt;这题求的是具体的分隔方法，基本上就是DFS搜索加回溯的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) {
        vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; result;
        if (s.empty()) return result;

        vector&amp;lt;string&amp;gt; palindromes;
        dfs(s, 0, palindromes, result);

        return result;
    }

private:
    void dfs(string s, int pos, vector&amp;lt;string&amp;gt; &amp;amp;palindromes,
             vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; &amp;amp;ret) {

        if (pos == s.size()) {
            ret.push_back(palindromes);
            return;
        }

        for (int i = pos + 1; i &amp;lt;= s.size(); ++i) {
            string substr = s.substr(pos, i - pos);
            if (!isPalindrome(substr)) {
                continue;
            }

            palindromes.push_back(substr);
            dfs(s, i, palindromes, ret);
            palindromes.pop_back();
        }
    }

    bool isPalindrome(string s) {
        if (s.empty()) return false;

        int n = s.size();
        for (int i = 0; i &amp;lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }

        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutations and N-Queens</title>
      <link>https://pineal.github.com/posts/permutations_n_queens/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/permutations_n_queens/</guid>
      <description>

&lt;h1 id=&#34;permutations-and-n-queens&#34;&gt;Permutations and N-Queens&lt;/h1&gt;

&lt;h2 id=&#34;permutation-from-stl-library&#34;&gt;Permutation from STL Library&lt;/h2&gt;

&lt;p&gt;最直接的做法：C++11中的STL中有关于排列的algorithm库可以直接用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/is_permutation&#34;&gt;std::is_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/prev_permutation&#34;&gt;std::prev_permutation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/next_permutation&#34;&gt;std::next_permutation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他有什么用呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Changes the order of the elements in [Begin, end) according to the next permutation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return &lt;em&gt;False&lt;/em&gt; if the elements got the &amp;ldquo;normal&amp;rdquo;(lexicographical) order: that is, ascending order. So, to run through all permutations, you have to sort all elements and start a loop that calls this function as long as these algorithms return true.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution:
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt; nums){
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;

    if (nums.empty()){return {}};
    std::sort(nums.begin(), nums.end());

    do{
        result.emplace_back(nums);
    } while(next_permutation(nums.begin(), nums.end()));
    return result;
    }
};    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementation-of-std-next-permutation&#34;&gt;Implementation of std::next_permutation()&lt;/h3&gt;

&lt;p&gt;大致思路为，我们先固定第一个数，然后对右边剩下的数做全排列。什么时候右边剩下的数完成了全排列呢？那就是当这些数变成了降序。然后我们才用第一个数。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation&#34;&gt;留着慢慢消化，反正直接让我写，我是写不出来。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//kan bu dong...
template&amp;lt;class BidirIt&amp;gt;
bool next_permutation(BidirIt first, BidirIt last)
{
    if (first == last) return false;
    BidirIt i = last;
    if (first == --i) return false;

    while (true) {
        BidirIt i1, i2;

        i1 = i;
        //if the elements are in ascending order
        if (*--i &amp;lt; *i1) {
            i2 = last;
            //find the next largest digit
            while (!(*i &amp;lt; *--i2));
            // and put it in front
            std::iter_swap(i, i2);
            //put the remaining digits in ascending order
            std::reverse(i1, last);
            return true;
        }
        //last purmutation
        if (i == first) {
            std::reverse(first, last);
            return false;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个之后我们可以自己模拟 std::next_permutation()&lt;/p&gt;

&lt;h2 id=&#34;recursion-version-for-permutations&#34;&gt;Recursion Version for Permutations&lt;/h2&gt;

&lt;p&gt;常规的backtracking回溯，用DFS递归就行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permute(vector&amp;lt;int&amp;gt; nums) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (nums.size() == 0) return rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(rst, nums, v);
        return rst;
    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v){
        if (v.size() == nums.size()){
            rst.emplace_back(v);
            return ;
        }

        for (int i = 0; i &amp;lt; nums.size(); ++i){
            //can employ map to improve the time complexity
            //vector&amp;lt;bool&amp;gt; is not a container. do not use. alternates: deque&amp;lt;bool&amp;gt;, or bitset
            if (find(v.begin(), v.end(), nums[i]) != v.end()){
                continue;
            }
            v.emplace_back(nums[i]);
            backtracking(rst, nums, v);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;permutations-ii&#34;&gt;Permutations II&lt;/h2&gt;

&lt;p&gt;全排列去重。在循环的过程中加入while语句跳过相同的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; permuteUnique(vector&amp;lt;int&amp;gt; &amp;amp;num) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permutations;
        if(num.size() == 0)
            return permutations;
        vector&amp;lt;int&amp;gt; curr;
        vector&amp;lt;bool&amp;gt; isVisited(num.size(), false);
        /* we need to sort the input array here because of this array
           contains the duplication value, then we need to skip the duplication
           value for the final result */
        sort(num.begin(),num.end());
        dfs(permutations,curr,num,isVisited);
        return permutations;
    }

    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ret, vector&amp;lt;int&amp;gt; curr, vector&amp;lt;int&amp;gt; num, vector&amp;lt;bool&amp;gt; isVisited)
    {
        if(curr.size() == num.size())
        {
            ret.push_back(curr);
            return;
        }

        for(int i = 0; i &amp;lt; num.size(); ++i)
        {
            if(isVisited[i] == false)
            {
                isVisited[i] = true;
                curr.push_back(num[i]);
                dfs(ret,curr,num,isVisited);
                isVisited[i] = false;
                curr.pop_back();
                while(i &amp;lt; num.size()-1 &amp;amp;&amp;amp; num[i] == num[i+1])
                //we use this while loop to skip the duplication value in the input array.
                    ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens&#34;&gt;N-Queens&lt;/h2&gt;

&lt;p&gt;经典的搜索题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string &#39;...Q&#39; shows a queen on forth position
     */
    vector&amp;lt;vector&amp;lt;string&amp;gt; &amp;gt; solveNQueens(int n) {
        // write your code here
        vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; rst;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            rst.emplace_back(cur);
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-queens-ii&#34;&gt;N-Queens II&lt;/h2&gt;

&lt;p&gt;只要求solutions的个数就可以。这道题并不用动归解，还是要用搜索。和上一题基本没差别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    int totalNQueens(int n) {
         // write your code here
        int rst = 0;
        vector&amp;lt;string&amp;gt; cur(n, string(n, &#39;.&#39;));
        backtracking(rst, cur, 0);
        return rst;
    }

    void backtracking(int&amp;amp; rst, vector&amp;lt;string&amp;gt;&amp;amp; cur, int row){
        if (row == cur.size()){
            ++rst;
            return;
        }

        for (int col = 0; col &amp;lt; cur.size(); col++){
            if (isValid(cur, row, col)){
                cur[row][col] = &#39;Q&#39;;
                backtracking(rst, cur, row + 1);
                cur[row][col] = &#39;.&#39;;
            }
        }
    }

    bool isValid(vector&amp;lt;string&amp;gt; cur, int row, int col){
        for (int i = 0; i &amp;lt; row; i++){
            if (cur[i][col] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col - 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;gt;=0; i--, j--){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        for (int i = row - 1, j = col + 1; i &amp;gt;=0 &amp;amp;&amp;amp; j &amp;lt; cur.size(); i--, j++){
            if (cur[i][j] == &#39;Q&#39;) return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Subsets and Combinations</title>
      <link>https://pineal.github.com/posts/subsets_combinations/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/subsets_combinations/</guid>
      <description>

&lt;h1 id=&#34;subsets-and-combinations&#34;&gt;Subsets and Combinations&lt;/h1&gt;

&lt;p&gt;Original Questions on &lt;a href=&#34;http://www.lintcode.com&#34;&gt;LeetCode&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subsets-i&#34;&gt;Subsets I&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible subsets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If S = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursive-solution&#34;&gt;Recursive Solution&lt;/h3&gt;

&lt;p&gt;Backtracking的模板。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    	if (nums.size() == 0)
    	    return {};
    	vector&amp;lt;int&amp;gt; v;
    	sort(nums.begin(), nums.end());
    	backtracking(rst, v, nums, 0);
    	return rst;

    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos){

        rst.emplace_back(v);

        for (int i = pos; i &amp;lt; nums.size(); ++i){
            v.emplace_back(nums[i]);
            backtracking(rst, v, nums, i + 1);
            v.pop_back();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterative-solution&#34;&gt;Iterative Solution&lt;/h3&gt;

&lt;p&gt;建一个result的vector用来储存结果。初始化为一个［］。从nums取出下一个元素$$m$$，和result里所有的vector: $ temp = v \in rst$, 把 m 加到这些vector的末端: $temp = temp \bigcup m$, 再把这些vector放到result中，进行下一次迭代。一共有两重循环， 外面那层代表了每次从nums中取元素共有nums.size()个，里面那层代表把元素放到新的vector里，一共有result.size() 的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	sort(nums.begin(),nums.end());
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst(1);
    	vector&amp;lt;int&amp;gt; temp;
    	for (int i = 0; i &amp;lt; nums.size(); ++i){
    	  int size = rst.size();  
    	  for (int j = 0; j &amp;lt; size; ++j){
    	      temp = rst[j];
    	      temp.emplace_back(nums[i]);
    	      rst.emplace_back(temp);
    	      temp.clear();
    	  }
    	}
    	return rst;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subsets-ii&#34;&gt;Subsets II&lt;/h2&gt;

&lt;p&gt;上面那道题的followup，加上了去重的要求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        vector&amp;lt;int&amp;gt; sorted_S(S);
        sort(sorted_S.begin(), sorted_S.end());
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result(1);
        size_t previous_size = 0;
        for (size_t i = 0; i &amp;lt; sorted_S.size(); ++i) {
            const size_t size = result.size();
            for (size_t j = 0; j &amp;lt; size; ++j) {

                if (i == 0 || sorted_S[i] != sorted_S[i - 1] || j &amp;gt;= previous_size) {
                    result.emplace_back(result[j]);
                    result.back().emplace_back(sorted_S[i]);
                }
            }
            previous_size = size;
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去重的递归：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (S.size() == 0)
            return {};
        vector &amp;lt;int&amp;gt; v;
        vector&amp;lt;int&amp;gt; nums(S);
        sort(nums.begin(), nums.end());
        backtracking(rst, nums, v, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v, int pos){

        rst.emplace_back(v);    

        for (int i = pos; i &amp;lt; nums.size(); i++){
            v.emplace_back(nums[i]);
            backtracking (rst, nums, v, i + 1);
            v.pop_back();
            while(i &amp;lt; nums.size()-1 &amp;amp;&amp;amp; nums[i] == nums[i+1]){
                ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinations&#34;&gt;Combinations&lt;/h2&gt;

&lt;p&gt;相似的递归模版：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n: Given the range of numbers
     * @param k: Given the numbers of combinations
     * @return: All the combinations of k numbers out of 1..n
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combine(int n, int k) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(n, k, rst, v, 1);
        return rst;
    }


    void backtracking(int n, int k, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, int curr){
        if (v.size() == k){
            rst.emplace_back(v);
            return;
        }

        for (int i = curr;  i &amp;lt;= n; ++i){
            v.emplace_back(i);
            backtracking(n, k, rst, v, i+1);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>