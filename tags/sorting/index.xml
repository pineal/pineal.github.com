<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sorting on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/sorting/</link>
    <description>Recent content in Sorting on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Mar 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/sorting/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sorting Algorithms</title>
      <link>https://pineal.github.com/posts/sorting_algorithms/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/sorting_algorithms/</guid>
      <description>

&lt;p&gt;假设这里的排序都是升序。&lt;/p&gt;

&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort:&lt;/h2&gt;

&lt;p&gt;归并排序。分治法（divide and conquer）思想入门的算法。Recursively 递归入栈时将字符串分为左右两半，直到无法分割为止。出栈时再把这两半合并起来，在合并的过程中排序。最后所有的栈返回是一个排好序的数组。在用分治法的时候注意一下和纯递归求解的区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// merge part
  vector&amp;lt;int&amp;gt; merge(vector&amp;lt;int&amp;gt; A, vector&amp;lt;int&amp;gt; B) {
	  vector&amp;lt;int&amp;gt; rst;
	  std::vector&amp;lt;int&amp;gt;::iterator iter1 = A.begin(), iter2 = B.begin();

	  while (iter1 != A.end() || iter2 != B.end()) {
	  	if (iter1 == A.end()) {
		  	rst.insert(rst.end(), iter2, B.end());
		  	break;
		  }
		  if (iter2 == B.end()) {
		  	rst.insert(rst.end(), iter1, A.end());
		  	break;
		  }
		  if (*iter1 &amp;lt; *iter2) {
			  rst.emplace_back(*iter1);
			  iter1++;
		  }
		  else {
			  rst.emplace_back(*iter2);
			  iter2++;
		  }
	  }
	  return rst;
  }

// key part of merge sort, recursive function
  vector&amp;lt;int&amp;gt; MSort(vector&amp;lt;int&amp;gt; array, int left, int right) {
	  vector&amp;lt;int&amp;gt; rst;
	  if (left == right) {
		  rst.emplace_back(array[left]);
		  return rst;
	  }
	  int mid = left + (right - left) / 2;
	  vector&amp;lt;int&amp;gt; leftArr = MSort(array, left, mid);
	  vector&amp;lt;int&amp;gt; rightArr = MSort(array, mid + 1, right);
	  rst = merge(leftArr, rightArr);
	  return rst;
  }
// driver for merge sort
  vector&amp;lt;int&amp;gt; mergeSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
	  vector&amp;lt;int&amp;gt; rst;
	  rst = MSort(array, 0, array.size() - 1);
	  return rst;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析： $O(nlog(n))$&lt;/p&gt;

&lt;p&gt;画出递归树，一共 $log(n)$ 层, 每一层是 $O(n)$ 的复杂度.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort:&lt;/h2&gt;

&lt;p&gt;快速排序的核心的思想为是 &lt;strong&gt;partition&lt;/strong&gt;. 这个思想在很多类型的问题中都会用到，会在后文举例说明。&lt;/p&gt;

&lt;p&gt;快速排序的基本操作为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选取一个pivot。&lt;/li&gt;
&lt;li&gt;所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边。&lt;/li&gt;
&lt;li&gt;分割数组：对pivot两边的数组递归重复以上步骤，直到不能分割。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体有哪些实现呢。
先来看第一种方法。这是一个textbook的解法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; int median(vector&amp;lt;int&amp;gt;&amp;amp; arr, int left, int right){
   // arr[left] &amp;lt;= arr[center] &amp;lt;= arr[right]
   int center = left + (right - left)/2;
   if (arr[left] &amp;gt; arr[center]) swap(&amp;amp;arr[left], &amp;amp;arr[center]);
   if (arr[left] &amp;gt; arr[right])  swap(&amp;amp;arr[left], &amp;amp;arr[right]);
   if (arr[center] &amp;gt; arr[right]) swap(&amp;amp;arr[center], &amp;amp;arr[right]);
   swap(&amp;amp;arr[center], &amp;amp;arr[right - 1]); //hide pivot
   return arr[right - 1];
 }

 void QSort(vector&amp;lt;int&amp;gt; &amp;amp; arr, int left, int right) {

//   if (left &amp;gt;= right) return;
   if (left + CutOff &amp;lt;= right){
     int pivot = median(arr, left, right);
     int i = left;
     int j = right - 1;
     for(;;){
      while (arr[++i] &amp;lt; pivot){}
       while (arr[--j] &amp;gt; pivot){}
      if (i &amp;lt; j) swap(&amp;amp;arr[i], &amp;amp;arr[j]);
       else  break;
     }
//   if (left + 1 != right){
       swap(&amp;amp;arr[i], &amp;amp;arr[right - 1]); //restore pivot
//   }  
     QSort(arr, left, i - 1);
     QSort(arr, i + 1, right);
   }
   else{
     insertion_Sort(arr, left, right - left + 1);
   }
 }

 vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
   if (array.size() &amp;lt;= 1) return array;
   QSort(array, 0, array.size() - 1);
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个解法。基本思想是一样的。每次都要保持所有比pivot小的数放在pivot的左边，所有比pivot大的数放在pivot的右边这个条件。
实现的过程为，选取两块挡板，分别从数组的头和尾往中间靠拢，直到挡板相遇。在每一次的循环中，保证第一块挡板左边的数都小于pivot，第二块挡板右边的数都大于pivot。&lt;/p&gt;

&lt;p&gt;事实上根据上面这个general rule来分，两个挡板指向的两个数只有四种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;lt; pivot, a[j] &amp;lt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt; pivot, a[j] &amp;gt; pivot$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$$a[i] &amp;gt;= pivot, a[j] &amp;lt;= pivot$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么对应刚才的rule该做着么呢？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;满足条件：移动挡板i++， j&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足前半个条件，移动挡板i++，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;满足后半个条件，移动挡板j&amp;ndash;，继续检查条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不满足任何条件，但是一旦交换两个挡板上的数，即可让条件满足&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  void QuickSort(vector&amp;lt;int&amp;gt; &amp;amp; array, int left, int right){
    if (left &amp;gt; right) return;
    int pivot_index = (left + right)/2;
    int pivot =  array[pivot_index];
    int left_bound = left;
    int right_bound = right - 1;
    //hide the pivot in the rightmost
    std::swap(array[pivot_index], array[right]);
    //three regions:
    //1. [0, leftbound - 1] : all elements smaller than pivot should be here
    //2. [leftbound, rightbound]: to be discovered, scan the element in a[leftbound], and move leftbound every step
    //3. [rightbound + 1, array.size() - 1] all elements bigger than pivot should be here
    while (left_bound &amp;lt;= right_bound) {
      //check two
      if (array[left_bound] &amp;lt; pivot) {
      // obey all three rules, move leftbound
        ++left_bound;
      }
      else if (array[right_bound] &amp;gt; pivot) {
        --right_bound;
      }
      else {
        //array[left_bound] &amp;gt; pivot &amp;amp;&amp;amp; array[right_bound &amp;lt; pivot]
        std::swap(array[left_bound++], array[right_bound--]);      
      }
    }
    //restore the pivot to the original position
    std::swap(array[left_bound], array[right]);
    //partition and recursion
    QuickSort(array, left, left_bound - 1);
    QuickSort(array, left_bound + 1, right);
  }

  vector&amp;lt;int&amp;gt; quickSort(vector&amp;lt;int&amp;gt; array) {
    if (array.size() &amp;lt;= 1) return array;
    QuickSort(array, 0, array.size() - 1);
    return array;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的解法可以归结为一种类型。比如一堆数中只有两种，三种四种数，那么就可以对应个数的挡板将数分割成相应区域，每次检查条件是否满足。Eg: Sort colors。这样的做法复杂度只需要$O(n)$.&lt;/p&gt;

&lt;p&gt;Demo: GeeksforGeeks&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-i-sort-colors&#34;&gt;Partition Extension I: Sort Colors&lt;/h3&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    int zero = 0;
    int one = 0;    //explorer
    int two = nums.size() - 1;
    //Three seperator Four regions
    //[0, zero)     0
    //[zero, one]   1
    //(two, end]    2
    while (one &amp;lt;= two) {
        if (nums[one] == 0) {   
            swap(nums[one++], nums[zero++]);
        } else if (nums[one] == 1) {
            one++;
        } else {
            swap(nums[one], nums[two--]);
            //don&#39;t move &#39;one&#39;:
            //you don&#39;t know what is swaped from &#39;two&#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-i-four-colors&#34;&gt;Follow up I: four colors&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; rainbowSortII(vector&amp;lt;int&amp;gt; array) {
   int zero = 0, one = 0, other = array.size() - 1;
   while (one &amp;lt;= other) {
     if (array[one] &amp;lt; 1) {
       swap(array[one++], array[zero++]);
     } else if (array[one] &amp;gt; 1) {
       swap(array[other--], array[one]);
     } else {
       one++;
     }
   }
   int two = one, three = array.size() - 1;
   while (two &amp;lt;= three) {
     if (array[two] == 3 &amp;amp;&amp;amp; array[three] == 2) {
       swap(array[two++], array[three--]);
     } else if (array[two] == 2) {
       two++;
     } else {
       three--;
     }
   }
   return array;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-ii-k-colors&#34;&gt;Follow up II: k colors&lt;/h3&gt;

&lt;p&gt;TODO: couting sort.&lt;/p&gt;

&lt;h3 id=&#34;partition-extension-ii-kth-smallest-largest-element-in-an-unsorted-array&#34;&gt;Partition Extension II: Kth smallest/largest element in an unsorted array&lt;/h3&gt;

&lt;p&gt;quick sort partition 思想的另一经典应用。
&lt;a href=&#34;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&#34;&gt;https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wiggle-sort&#34;&gt;Wiggle Sort&lt;/h2&gt;

&lt;p&gt;$nums[0] &amp;lt;= nums[1] &amp;gt;= nums[2] &amp;lt;= nums[3]&amp;hellip;.$&lt;/p&gt;

&lt;p&gt;这个时间复杂度优化到了O(n)。下面那个做法是通用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    for (int i=0; i&amp;lt;(int)nums.size() - 1; i++) {
        if (i % 2 == 0 &amp;amp;&amp;amp; nums[i] &amp;gt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
        if (i % 2 == 1 &amp;amp;&amp;amp; nums[i] &amp;lt; nums[i+1]) {
            swap(nums[i], nums[i+1]);
        }
    }        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-wiggle-sort-ii&#34;&gt;Follow up: Wiggle Sort II&lt;/h3&gt;

&lt;p&gt;$nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;$&lt;/p&gt;

&lt;p&gt;根据这个性质，我们可以确定一种排法一定可以成立：把小的那一半排在偶数位，把大的那一半排在奇数位。这个是通用的。
 时间复杂度 $ O(nlog(n)) $.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wiggleSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
    vector&amp;lt;int&amp;gt; copy(nums);
    sort(copy.begin(), copy.end());
    int left = (nums.size() + 1) / 2 - 1;
    int right = nums.size() - 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        nums[i] = (i % 2 == 0)? copy[left--] : copy[right--];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传说中$O(n)$ 的解法。&lt;/p&gt;

&lt;h2 id=&#34;sort-in-specified-order&#34;&gt;Sort In Specified Order&lt;/h2&gt;

&lt;p&gt;A1 = {2, 1, 2, 5, 7, 1, 9, 3},&lt;/p&gt;

&lt;p&gt;A2 = {2, 1, 3},&lt;/p&gt;

&lt;p&gt;A1 is sorted to {2, 2, 1, 1, 3, 5, 7, 9}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; helper(vector&amp;lt;int&amp;gt; &amp;amp; A1, vector&amp;lt;int&amp;gt; &amp;amp; A2) {
   // Write your solution here.
   if (A1.size() &amp;lt;= 1 |||| A2.size() == 0) {
       sort(A1.begin(), A1.end());
       return A1;
   }
   map&amp;lt;int, int&amp;gt; t;
   for (int i = 0; i &amp;lt; A2.size(); i++) {
       t.emplace(A2[i], i);
   }

   int j = 0, k = A1.size() - 1;
   while (j &amp;lt;= k) {
       if (t.find(A1[j]) == t.end() &amp;amp;&amp;amp; t.find(A1[k]) != t.end()) {
           swap(A1[j], A1[k]);
           j++;
           k--;
       }
       else if (t.find(A1[j]) != t.end()) {
           j++;
       }
       else {
           k--;
       }
   }

   //sort the [0, j) in specified order
   //[2 1 3 4]
   //2 1 2 1 4 3 =&amp;gt; 2 2 1 1 3 4

   for (int i = 0; i &amp;lt; j; i++) {
       int min_index = i;
       for (int l = i; l &amp;lt; j; l++) {
           if (t[A1[min_index]] &amp;gt; t[A1[l]]) {
               min_index = l;
           }
       }
       swap(A1[i], A1[min_index]);
   }

   //sort the (k, n) part in ascending order
   sort(A1.begin() + k + 1, A1.end());
   return A1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort:&lt;/h2&gt;

&lt;p&gt;插入排序。假设一个长度为N的数组$A[]$，总体过程为，从 index 为 1 开始到 N-1，使得 $A[0,index]$ 是一个排好序的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void insertion_sort(T arr[], int len){
  for (int i = 1; i &amp;lt; len; i++){
    int temp = arr[i];
      for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1]&amp;gt;temp; j--){ //实际比较的是j-1
        arr[j] = arr[j-1];  //全部往后移一位腾出位置等插入
      }
    arr[j] = temp;    //插入到腾出来的位置
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度：
$O(n^2)$&lt;/p&gt;

&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort:&lt;/h2&gt;

&lt;p&gt;选择排序。假设一个长度为N的数组$A[]$，总体过程为，从index为0开始到N-1，使得$A[0,index]$是一个排好序的数组。&lt;/p&gt;

&lt;p&gt;怎么跟插入排序这么像呢？是挺像的，但是具体的过程是有区别。这区别就是“插入”和“选择”的区别。&lt;/p&gt;

&lt;p&gt;插入排序是每次往前面那些已经排序好的数里“插入”进去，而选择排序则是，每次从这个数后面那些没排好序的数里“选择”到最小的，和这个数交换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void selection_sort(T arr[], int len){
  for (int i = 0; i &amp;lt; len - 1; i++){  //len - 1即可，最后一次交换在倒数第一个和倒数第二个之间进行
    int min_index = i;
    for (int j = i + 1; j &amp;lt; len; j++){
      //找到未排序的数组中最小的数的index
      if (arr[j]&amp;lt;arr[min_index]){
          min_index = j;
      }        
    }
    swap(arr[i], arr[min_index]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复杂度分析：
$O(n^2)$的复杂度。实际上是冒泡排序的一个优化，虽然最坏时间复杂度上是一样的。&lt;/p&gt;

&lt;p&gt;附上冒泡排序代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void bubble_sort(int arr[], int n) {
    int i, j;
    for (i = 0; i &amp;lt; n - 1; i++) {
        for (j = 0; j &amp;lt; n - 1 - i; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>