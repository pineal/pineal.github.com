<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subsets on PINEAL.ME</title>
    <link>https://pineal.me/tags/subsets/</link>
    <description>Recent content in Subsets on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 Jan 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.me/tags/subsets/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Subsets and Combinations</title>
      <link>https://pineal.me/posts/subsets_combinations/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.me/posts/subsets_combinations/</guid>
      <description>

&lt;h1 id=&#34;subsets-and-combinations&#34;&gt;Subsets and Combinations&lt;/h1&gt;

&lt;p&gt;Original Questions on &lt;a href=&#34;http://www.lintcode.com&#34;&gt;LeetCode&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subsets-i&#34;&gt;Subsets I&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a set of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible subsets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If S = [1,2,3], a solution is:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursive-solution&#34;&gt;Recursive Solution&lt;/h3&gt;

&lt;p&gt;Backtracking的模板。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    	if (nums.size() == 0)
    	    return {};
    	vector&amp;lt;int&amp;gt; v;
    	sort(nums.begin(), nums.end());
    	backtracking(rst, v, nums, 0);
    	return rst;

    }


    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, vector&amp;lt;int&amp;gt;&amp;amp; nums, int pos){

        rst.emplace_back(v);

        for (int i = pos; i &amp;lt; nums.size(); ++i){
            v.emplace_back(nums[i]);
            backtracking(rst, v, nums, i + 1);
            v.pop_back();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterative-solution&#34;&gt;Iterative Solution&lt;/h3&gt;

&lt;p&gt;建一个result的vector用来储存结果。初始化为一个［］。从nums取出下一个元素$$m$$，和result里所有的vector: $ temp = v \in rst$, 把 m 加到这些vector的末端: $temp = temp \bigcup m$, 再把这些vector放到result中，进行下一次迭代。一共有两重循环， 外面那层代表了每次从nums中取元素共有nums.size()个，里面那层代表把元素放到新的vector里，一共有result.size() 的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    	// write your code here
    	sort(nums.begin(),nums.end());
    	vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst(1);
    	vector&amp;lt;int&amp;gt; temp;
    	for (int i = 0; i &amp;lt; nums.size(); ++i){
    	  int size = rst.size();  
    	  for (int j = 0; j &amp;lt; size; ++j){
    	      temp = rst[j];
    	      temp.emplace_back(nums[i]);
    	      rst.emplace_back(temp);
    	      temp.clear();
    	  }
    	}
    	return rst;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subsets-ii&#34;&gt;Subsets II&lt;/h2&gt;

&lt;p&gt;上面那道题的followup，加上了去重的要求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        vector&amp;lt;int&amp;gt; sorted_S(S);
        sort(sorted_S.begin(), sorted_S.end());
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result(1);
        size_t previous_size = 0;
        for (size_t i = 0; i &amp;lt; sorted_S.size(); ++i) {
            const size_t size = result.size();
            for (size_t j = 0; j &amp;lt; size; ++j) {

                if (i == 0 || sorted_S[i] != sorted_S[i - 1] || j &amp;gt;= previous_size) {
                    result.emplace_back(result[j]);
                    result.back().emplace_back(sorted_S[i]);
                }
            }
            previous_size = size;
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去重的递归：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; subsetsWithDup(const vector&amp;lt;int&amp;gt; &amp;amp;S) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        if (S.size() == 0)
            return {};
        vector &amp;lt;int&amp;gt; v;
        vector&amp;lt;int&amp;gt; nums(S);
        sort(nums.begin(), nums.end());
        backtracking(rst, nums, v, 0);
        return rst;
    }

    void backtracking(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;int&amp;gt;&amp;amp; v, int pos){

        rst.emplace_back(v);    

        for (int i = pos; i &amp;lt; nums.size(); i++){
            v.emplace_back(nums[i]);
            backtracking (rst, nums, v, i + 1);
            v.pop_back();
            while(i &amp;lt; nums.size()-1 &amp;amp;&amp;amp; nums[i] == nums[i+1]){
                ++i;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinations&#34;&gt;Combinations&lt;/h2&gt;

&lt;p&gt;相似的递归模版：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    /**
     * @param n: Given the range of numbers
     * @param k: Given the numbers of combinations
     * @return: All the combinations of k numbers out of 1..n
     */
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; combine(int n, int k) {
        // write your code here
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; v;
        backtracking(n, k, rst, v, 1);
        return rst;
    }


    void backtracking(int n, int k, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; rst, vector&amp;lt;int&amp;gt;&amp;amp; v, int curr){
        if (v.size() == k){
            rst.emplace_back(v);
            return;
        }

        for (int i = curr;  i &amp;lt;= n; ++i){
            v.emplace_back(i);
            backtracking(n, k, rst, v, i+1);
            v.pop_back();
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>