<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dfs on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/dfs/</link>
    <description>Recent content in Dfs on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Sep 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Depth first search in matrix</title>
      <link>https://pineal.github.com/posts/dfs/</link>
      <pubDate>Wed, 05 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/dfs/</guid>
      <description>

&lt;h2 id=&#34;robot-room-cleaner&#34;&gt;Robot Room Cleaner&lt;/h2&gt;

&lt;p&gt;Given a robot cleaner in a room modeled as a grid.&lt;/p&gt;

&lt;p&gt;Each cell in the grid can be empty or blocked.&lt;/p&gt;

&lt;p&gt;The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.&lt;/p&gt;

&lt;p&gt;When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.&lt;/p&gt;

&lt;p&gt;Design an algorithm to clean the entire room using only the 4 given APIs shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Robot {
  // returns true if next cell is open and robot moves into the cell.
  // returns false if next cell is obstacle and robot stays on the current cell.
  boolean move();

  // Robot will stay on the same cell after calling turnLeft/turnRight.
  // Each turn will be 90 degrees.
  void turnLeft();
  void turnRight();

  // Clean the current cell.
  void clean();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reference: &lt;a href=&#34;https://leetcode.com/problems/robot-room-cleaner/description/&#34;&gt;Leetcode&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * // This is the robot&#39;s control interface.
 * // You should not implement it, or speculate about its implementation
 * class Robot {
 *   public:
 *     // Returns true if the cell in front is open and robot moves into the cell.
 *     // Returns false if the cell in front is blocked and robot stays in the current cell.
 *     bool move();
 *
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     void turnLeft();
 *     void turnRight();
 *
 *     // Clean the current cell.
 *     void clean();
 * };
 */
class Solution {
public:
    int x = 0;
    int y = 0;
    int dir = 0;
    
    unordered_set&amp;lt;string&amp;gt; cleaned;
    int dx[4]={0, -1, 0, 1};    //define it anti-clockwisely
    int dy[4]={1, 0, -1, 0};    //N -&amp;gt; W -&amp;gt; S -&amp;gt; E
    
    void turnAround(Robot &amp;amp; r) {
        r.turnRight();
        r.turnRight();
    }
    
    void cleanRoom(Robot&amp;amp; robot) {
        string state = to_string(x) + &amp;quot; &amp;quot; + to_string(y);
        if (cleaned.count(state)) {
            return;
        }    
        
        cleaned.emplace(state);        
        robot.clean();
    
        //try 
        for (int i = 0; i &amp;lt; 4; i++) {
            if (robot.move()) {
                //record the current location
                x += dx[dir];
                y += dy[dir];
                //dfs goto next state
                cleanRoom(robot);
                //reset old location
                turnAround(robot);
                robot.move();
                x -= dx[dir];
                y -= dy[dir];                
                //reset old direction 
                turnAround(robot);
            }
            //make turn anti-clockwisely 
            // - we are going to try next direction 
            robot.turnLeft();
            //record the current direction
            dir = (dir + 1) % 4;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-random-maze&#34;&gt;Generate Random Maze&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Randomly generate a maze of size N * N (where N = 2K + 1) whose corridor and wall’s width are both 1 cell. For each pair of cells on the corridor, there must exist one and only one path between them. (Randomly means that the solution is generated randomly, and whenever the program is executed, the solution can be different.). The wall is denoted by 1 in the matrix and corridor is denoted by 0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assumptions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;N = 2K + 1 and K &amp;gt;= 0
the top left corner must be corridor
there should be as many corridor cells as possible
for each pair of cells on the corridor, there must exist one and only one path between them&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;N = 5, one possible maze generated is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0  0  0  1  0

    1  1  0  1  0

    0  1  0  0  0

    0  1  1  1  0

    0  0  0  0  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res, int x, int y) {
    int n = res.size();
    vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    random_shuffle(dirs.begin(), dirs.end());
    int xx, xxx, yy, yyy;
    xx = xxx = x;
    yy = yyy = y;
    for (const auto &amp;amp; dir : dirs) {
        int dx =dir.first;
        int dy = dir.second;
        xx = x + dx;
        xxx = x + dx * 2;
        yy = y + dy;
        yyy = y + dy * 2;

        if (xxx &amp;gt;= 0 &amp;amp;&amp;amp; xxx &amp;lt; n &amp;amp;&amp;amp; yyy &amp;gt;= 0 &amp;amp;&amp;amp; yyy &amp;lt; n &amp;amp;&amp;amp; res[xxx][yyy] != 0) {
            res[xxx][yyy] = 0;
            res[xx][yy] = 0;
            dfs(res, xxx, yyy);
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; generateRandomMaze(int n) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res(n, vector&amp;lt;int&amp;gt;(n, 1));
    dfs(res, 0, 0);
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Basic Backtracking Problems</title>
      <link>https://pineal.github.com/posts/backtracking/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/backtracking/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Backtracking 类型的题目最重要的是想清楚每一层在做什么，以及到下一层一共有几个分叉。&lt;/p&gt;

&lt;p&gt;时间复杂度： branch factor ^ level&lt;/p&gt;

&lt;p&gt;时间复杂度： call stack -&amp;gt; level&lt;/p&gt;

&lt;h2 id=&#34;subsets&#34;&gt;Subsets&lt;/h2&gt;

&lt;p&gt;这一类的题目的框架为，在递归树中的第 i 层，代表正在处理 nums 里的第 i 个元素。 从该层的父节点一定会伸展出两个分叉： 第一个分叉代表着一层会放这个元素，第二个分叉代表不放这个元素。 这样出来的递归树非常平衡。&lt;/p&gt;

&lt;h3 id=&#34;subsets-i-http-www-lintcode-com-en-problem-subsets&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets/&#34;&gt;Subsets I&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        sort(nums.begin(), nums.end());
        vector&amp;lt;int&amp;gt; cur;
        dfs(rst, cur, nums, 0);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; rst, vector&amp;lt;int&amp;gt; &amp;amp; cur, const vector&amp;lt;int&amp;gt;&amp;amp; nums, int level) {
        if (level == nums.size()) {
            rst.emplace_back(cur);
            return;
        }
        cur.emplace_back(nums[level]);
        dfs(rst, cur, nums, level + 1);
        cur.pop_back();
        dfs(rst, cur, nums, level + 1);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subsets-ii-dedup-http-www-lintcode-com-en-problem-subsets-ii&#34;&gt;&lt;a href=&#34;http://www.lintcode.com/en/problem/subsets-ii/&#34;&gt;Subsets II - Dedup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;去重首先需要排序，要利用有序性。从递归树上看的话，放的那一个分支不变，因为我们是先做放元素，再走不放该元素的。如果不放该元素，那么此时的结果会跟父节点的是重复的。ab1 -&amp;gt; ab1b2, ab1。  a -&amp;gt; ab2, a。 ab1 和 ab2 不能同时出现。 所以这个分支就需要直接跳到跟当前层元素不同的那一层。在代码上体现就是level++。&lt;/p&gt;

&lt;p&gt;ab1 ab2 出发产生的分支都是完全一样的。那么我们可以去掉ab2。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
        vector&amp;lt;int&amp;gt; cur;
        sort(nums.begin(), nums.end());
        dfs(rst, nums, 0, cur);
        return rst;
    }
    void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; result, vector&amp;lt;int&amp;gt; &amp;amp; nums, int level, vector&amp;lt;int&amp;gt; &amp;amp; cur) {
        if (level == nums.size()) {
            result.emplace_back(cur);
            return;
        }
        
        cur.emplace_back(nums[level]);
        dfs(result, nums, level + 1, cur);
        cur.pop_back();
        //pruning techniques
        while (level &amp;lt; nums.size() - 1 &amp;amp;&amp;amp; nums[level] == nums[level+1]) {
            level++;
        }                
        dfs(result, nums, level + 1, cur);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variant-i-combination&#34;&gt;Variant I - Combination&lt;/h3&gt;

&lt;p&gt;整体框架跟 Subset I 一模一样， 唯一的区别是 base case return 的时候加上条件： 当前结果的长度为 k 才返回。
原题链接：&lt;a href=&#34;http://www.lintcode.com/en/problem/combinations/&#34;&gt;Combinations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;去重的方法也应该和 Subset II 一样。&lt;/p&gt;

&lt;h3 id=&#34;variant-ii-permutations-of-inserting-spaces-into-a-string&#34;&gt;Variant II - Permutations of inserting spaces into a string&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&#34;&gt;https://www.geeksforgeeks.org/print-possible-strings-can-made-placing-spaces/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;还有别的问法，比如如何分一个给定的数组成两部分，两部分的和相同。或者要在一串数组/字符串里面插入。&lt;/li&gt;
&lt;li&gt;时间复杂度是$O(2^n)$&lt;/li&gt;
&lt;li&gt;另一种常见做法：k层，每层的意义为最后的结果钟第几个元素应该是什么。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;permutations&#34;&gt;Permutations&lt;/h2&gt;

&lt;p&gt;因为全排列需要全部元素都出现，唯一不同的是他们的顺序，那么我们可以不停两两交换数组中的元素，得到全排列。&lt;/p&gt;

&lt;p&gt;Time n * (n-1) * (n - 2) = O(n!)&lt;/p&gt;

&lt;p&gt;Space O(n)&lt;/p&gt;

&lt;p&gt;如果要求 一个长度不变的array/string 的 permutation 只是 order 不一样，就可以考虑用 swap-swap 的方法。&lt;/p&gt;

&lt;h3 id=&#34;permutations-i&#34;&gt;Permutations I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
  if (input == &amp;quot;&amp;quot;) {
    return {&amp;quot;&amp;quot;};
  }
  vector&amp;lt;string&amp;gt; result;
  helper(result, input, 0);
  return result;
  }
  
private:
  void swap(string &amp;amp;s, int i, int j) {
    auto temp = s[i];
    s[i] = s[j];
    s[j] = temp;
  }

  void helper(vector&amp;lt;string&amp;gt; &amp;amp; result, string &amp;amp; s, int index) {
    if (index == s.size()){
      result.emplace_back(s);
      return;
    }
    for (int i = index; i &amp;lt; s.size(); i++) {
      swap(s, i, index);
      helper(result, s, index + 1);
      swap(s, i, index);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;permutations-ii-dedup&#34;&gt;Permutations II - Dedup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  vector&amp;lt;string&amp;gt; solve(string input) {
    vector&amp;lt;string&amp;gt; result;
    helper(input, result, 0);
    return result;
  }
  
private:
  void helper(string &amp;amp; input, vector&amp;lt;string&amp;gt; &amp;amp; result, int level) {
    if (level == input.size()) {
        result.emplace_back(input);
        return;
    }
    
    set&amp;lt;char&amp;gt; charset;
    for (int i = level; i &amp;lt; input.size(); ++i) {
      if (charset.find(input[i]) != charset.end()) {
        continue;
      }
      charset.emplace(input[i]);
      swap(input[i], input[level]);
      helper(input, result, level + 1);
      swap(input[i], input[level]);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parenthesis-problems&#34;&gt;Parenthesis Problems&lt;/h2&gt;

&lt;h3 id=&#34;valid&#34;&gt;Valid&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Given N pairs of parentheses “()”, return a list with all the valid permutations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void validParenthesisHelper(int l, int r, int n, string &amp;amp; cur, vector&amp;lt;string&amp;gt; &amp;amp; res) {
    if (l + r ==  2 * n) {
        res.emplace_back(cur);
        return;
    }
    
    if (l &amp;lt; n) {
        cur += &amp;quot;(&amp;quot;;
        validParenthesisHelper(l + 1, r, n, cur, res);
        cur.pop_back();
    }
    
    if (r &amp;lt; l) {
        cur += &amp;quot;)&amp;quot;;
        validParenthesisHelper(l, r + 1, n, cur, res);
        cur.pop_back();
    }
}

vector&amp;lt;string&amp;gt; validParenthesis(int n) {
    vector&amp;lt;string&amp;gt; res;
    string cur;
    validParenthesisHelper(0, 0, n, cur, res);
    return res;
}

void testvalidParenthesis() {
    auto res = validParenthesis(3);
    for (const auto &amp;amp; str : res) {
        cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time: O(2^2n)
Space: O(2n)&lt;/p&gt;

&lt;h2 id=&#34;coin-combinations&#34;&gt;Coin Combinations&lt;/h2&gt;

&lt;h3 id=&#34;99-cents&#34;&gt;99 Cents&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&#34;&gt;https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void coinCombinationHelper(const vector&amp;lt;int&amp;gt; &amp;amp; coins,
                           vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp; res,
                           vector&amp;lt;int&amp;gt; &amp;amp; cur,
                           int remaining,
                           int level) {
    if (level == coins.size()) {
        if (remaining == 0) {
            res.emplace_back(cur);
        }
        return;
    }

    int n = remaining/coins[level];
    for (int i = 0; i &amp;lt;= n; i++) {
        cur.emplace_back(i);
        coinCombinationHelper(coins, res, cur, remaining - i * coins[level], level + 1);
        cur.pop_back();
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; coinCombination(const vector&amp;lt;int&amp;gt; &amp;amp; coins, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res;
    vector&amp;lt;int&amp;gt; cur;
    coinCombinationHelper(coins, res, cur, target, 0);
    return res;
}

void testCoinsCombination() {
    vector&amp;lt;int&amp;gt; coins = {25, 10, 5, 1};
    auto res = coinCombination(coins, 99);
    for (const auto &amp;amp; v : res) {
        for (const auto &amp;amp; c : v) {
            cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;find-all-valid-combinations-of-factors-that-form-an-integer&#34;&gt;find all valid combinations of factors that form an integer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&#34;&gt;https://www.geeksforgeeks.org/given-array-strings-find-strings-can-chained-form-circle/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;backtracking-on-tree&#34;&gt;Backtracking on Tree&lt;/h2&gt;

&lt;h3 id=&#34;longest-consecutive-sequence&#34;&gt;Longest consecutive sequence&lt;/h3&gt;

&lt;p&gt;int global_max = INT_MIN;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int helper(TreeNode* root) {
  if (root == nullptr) {
    return 0;
  }

  int left = 0;
  int right = 0;

  if (root-&amp;gt;left &amp;amp;&amp;amp; root-&amp;gt;left-&amp;gt;val -1 == root-&amp;gt;val) {
    left = helper(root-&amp;gt;left);
  } 
  if (root-&amp;gt;right &amp;amp;&amp;amp; root-&amp;gt;right-&amp;gt;val -1 == root-&amp;gt;val) {
    right = helper(root-&amp;gt;right);
  } 
  int local_max = max(left, right) + 1;
  global_max = max(global_max, local_max)l
  return local_max;

} 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>