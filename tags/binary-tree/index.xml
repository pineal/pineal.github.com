<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Tree on PINEAL.ME</title>
    <link>https://pineal.github.com/tags/binary-tree/</link>
    <description>Recent content in Binary Tree on PINEAL.ME</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Aug 2015 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://pineal.github.com/tags/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Binary Tree</title>
      <link>https://pineal.github.com/posts/binary_tree/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://pineal.github.com/posts/binary_tree/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;h3 id=&#34;concepts&#34;&gt;Concepts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full Binary Tree: 全部都填满的树。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Complete Binary Tree: 除了最后一行其他都填满，最后一行的最后一个之前（左边）全部是满的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Balanced Binary Tree: 左右子树的高度最多差1. Height of the tree: $O(log(n))$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary Search Tree: Recursively, Leftsubtree is smaller than root and righ subtree is larger than root. Inorder traverse is increasing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;traverse&#34;&gt;Traverse&lt;/h2&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png&#34; alt=&#34;example&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preorder: 8-&amp;gt;3-&amp;gt;1-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;10-&amp;gt;14-&amp;gt;13&lt;/li&gt;
&lt;li&gt;Inorder:  1-&amp;gt;3-&amp;gt;4-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;10-&amp;gt;13-&amp;gt;14&lt;/li&gt;
&lt;li&gt;Postorder: 1-&amp;gt;4-&amp;gt;7-&amp;gt;6-&amp;gt;3-&amp;gt;13-&amp;gt;14-&amp;gt;10-&amp;gt;8&lt;/li&gt;
&lt;li&gt;Levelorder: 8-&amp;gt;3-&amp;gt;10-&amp;gt;1-&amp;gt;6-&amp;gt;14-&amp;gt;4-&amp;gt;7-&amp;gt;13&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;traverse-recursively&#34;&gt;Traverse Recursively&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void helper(TreeNode* node, vector&amp;lt;int&amp;gt; &amp;amp; rst){
    if (node != nullptr){
//      rst.emplace_back(root -&amp;gt; val);  If it is PreOder
        helper(node -&amp;gt; left, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is InOrder
        helper(node -&amp;gt; right, rst);
//      rst.emplace_back(root -&amp;gt; val);  If it is PostOrder
    }
}
vector&amp;lt;int&amp;gt; DFS_Traversal(TreeNode* root) {
    // write your code here
    vector&amp;lt;int&amp;gt; rst;
    helper(root, rst);
    return rst;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;preorder-iterative&#34;&gt;Preorder iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s, vector&amp;lt;int&amp;gt; &amp;amp; res) {
    while (root) {
        res.emplace_back(root-&amp;gt;val);
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; preorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s, res);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        cur = cur-&amp;gt;right;
        pushleft(cur, s, res);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inorder-iterative&#34;&gt;Inorder Iterative&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void pushleft(TreeNode* root, stack&amp;lt;TreeNode*&amp;gt; &amp;amp; s) {
    while (root) {
        s.push(root);
        root = root-&amp;gt;left;
    }
}

vector&amp;lt;int&amp;gt; inorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    pushleft(root, s);
    while (!s.empty()) {
        auto cur = s.top();
        s.pop();
        res.emplace_back(cur-&amp;gt;val);
        cur = cur-&amp;gt;right;
        pushleft(cur, s);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-i&#34;&gt;Postorder iterative I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorder(TreeNode* root) {
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s1, s2;
    s1.push(root);
    while (!s1.empty()) {
        auto cur = s1.top();
        s2.push(cur);
        s1.pop();
        if (cur-&amp;gt;left) {
            s1.push(cur-&amp;gt;left);
        }
        if (cur-&amp;gt;right) {
            s1.push(cur-&amp;gt;right);
        }
    }
    while (!s2.empty()) {
        auto cur = s2.top();
        s2.pop();
        res.emplace_back(cur-&amp;gt;val);
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;postorder-iterative-ii&#34;&gt;Postorder iterative II&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; postorderII(TreeNode* root) {
    if (root == nullptr) {
        return {};
    }
    vector&amp;lt;int&amp;gt; res;
    stack&amp;lt;TreeNode*&amp;gt; s;
    s.push(root);
    TreeNode* prev = nullptr;
    while (!s.empty()) {
        auto cur = s.top();
        if (prev == nullptr || cur == prev-&amp;gt;left || cur == prev-&amp;gt;right) {
            if (cur-&amp;gt;left) {
                s.push(cur-&amp;gt;left);
            }
            else if (cur-&amp;gt;right) {
                s.push(cur-&amp;gt;right);
            }
            else {
                s.pop();
                res.emplace_back(cur-&amp;gt;val);
            }
        }
        else if (prev == cur-&amp;gt;right || prev == cur-&amp;gt;left &amp;amp;&amp;amp; cur-&amp;gt;right == nullptr) {
            s.pop();
            res.emplace_back(cur-&amp;gt;val);
        }
        else {
            s.push(cur-&amp;gt;right);
        }
        prev = cur;
    }
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bfs-level-order&#34;&gt;BFS level order&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rst;
    if (root == nullptr) return rst;

    queue&amp;lt;TreeNode*&amp;gt; nodes;
    nodes.push(root);

    while(!nodes.empty()){
        vector&amp;lt;int&amp;gt; level;
        int size = nodes.size();
        for (int i = 0; i &amp;lt; size; i++){
            TreeNode* node = nodes.front();
            nodes.pop();
            level.emplace_back(node -&amp;gt; val);
            if (node -&amp;gt; left != nullptr) nodes.push(node -&amp;gt; left);
            if (node -&amp;gt; right != nullptr) nodes.push(node -&amp;gt; right);    
        }
        rst.emplace_back(level);
    }
return rst;    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;morris-traverse-todo&#34;&gt;Morris Traverse(TODO)&lt;/h3&gt;

&lt;h2 id=&#34;binary-tree-iterator&#34;&gt;Binary Tree Iterator&lt;/h2&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/pineal/-O_O-/blob/d600d536acf50c6d3299e99b200a4c247b79ece7/Binary_Tree/Binary_Tree_Iterator.cpp&#34;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bst-iterator&#34;&gt;BST iterator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BSTIterator {
private:
    stack&amp;lt;TreeNode*&amp;gt; s;
public:
    BSTIterator(TreeNode *root) {
        while (root) {
            s.push(root);
            root = root -&amp;gt; left;
        }
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !s.empty();
    }

    /** @return the next smallest number */
    //which means ascending order
    //which means inoredr traversal
    int next() {
        if (s.empty()) {
            return INT_MAX;
        }
        
        TreeNode* parent = s.top();
        s.pop();
        TreeNode* cur = parent -&amp;gt; right;
        while (cur) {
            s.push(cur);
            cur = cur -&amp;gt; left;
        }
        return parent -&amp;gt; val;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;different-views-of-tree&#34;&gt;Different views of tree&lt;/h2&gt;

&lt;h3 id=&#34;boundary-of-binary-tree&#34;&gt;Boundary of Binary Tree&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;int&amp;gt; boundaryOfBinaryTree(TreeNode* root) {
        if (root == nullptr) {
            return {};
        }
        vector&amp;lt;int&amp;gt; left, right, bottom, res;
        res.emplace_back(root-&amp;gt;val);
        getLeft(root-&amp;gt;left, left);
        getBottom(root-&amp;gt;left, bottom);
        getBottom(root-&amp;gt;right, bottom);
        getRight(root-&amp;gt;right, right);
        res.insert(res.end(), left.begin(), left.end());
        res.insert(res.end(), bottom.begin(), bottom.end());
        res.insert(res.end(), right.rbegin(), right.rend());
        return res;
    }
private:    
    void getLeft(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;left) {
            getLeft(root-&amp;gt;left, res);
        }
        else {
            getLeft(root-&amp;gt;right, res);    
        }
    }
    
    void getRight(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            return;
        }
        res.emplace_back(root-&amp;gt;val);
        if (root-&amp;gt;right) {
            getRight(root-&amp;gt;right, res);
        } 
        else {
            getRight(root-&amp;gt;left, res);
        }
    }
    
    void getBottom(TreeNode* root, vector&amp;lt;int&amp;gt; &amp;amp; res) {
        if (root == nullptr) {
            return;
        }
        if (!root-&amp;gt;left &amp;amp;&amp;amp; !root-&amp;gt;right) {
            res.emplace_back(root-&amp;gt;val);
        }
        getBottom(root-&amp;gt;left, res);
        getBottom(root-&amp;gt;right, res);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;path-problems&#34;&gt;Path problems&lt;/h2&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-i&#34;&gt;Maximum Path Sum Binary Tree I&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from one leaf node to another leaf node. If there is no such path available, return INT_MIN (C++).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
 int global_max = INT_MIN;
 
  int maxPathSum(TreeNode* root){
    dfs(root);
    return global_max;
  }
 
  int dfs(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
  
    int left =  dfs(root -&amp;gt; left);
    int right = dfs(root -&amp;gt; right);

    if (root -&amp;gt; left &amp;amp;&amp;amp; root -&amp;gt; right) {
      int sum = left + right + root -&amp;gt; value;
      global_max = max(sum, global_max);
      return max(left, right) + root -&amp;gt; value;
    } 
      return (!root -&amp;gt; left)? right + root -&amp;gt; value : left + root -&amp;gt; value;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-ii&#34;&gt;Maximum Path Sum Binary Tree II&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number. Find the maximum possible sum from any node to any node &lt;strong&gt;(the start node and the end node can be the same)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);    
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    //left = (left &amp;lt; 0)? 0 : left;
    //right = (right &amp;lt; 0)? 0 : right; 
    global_max = max(global_max, left + right + root -&amp;gt; value);
    return max(0, max(left, right) + root -&amp;gt; value); 
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;maximum-path-sum-binary-tree-iii&#34;&gt;Maximum Path Sum Binary Tree III&lt;/h3&gt;

&lt;p&gt;Given a binary tree in which each node contains an integer number.
Find the maximum possible subpath sum&lt;strong&gt;(both the starting and ending node of the subpath should be on the same path from root to one of the leaf nodes, and the subpath is allowed to contain only one node)&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  int maxPathSum(TreeNode* root) {
    int global_max = INT_MIN;
    dfs(root, global_max);
    return global_max;
  }
  
  int dfs(TreeNode* root, int&amp;amp; global_max) {
    if (root == nullptr) {
      return 0;
    }
    int left = dfs(root -&amp;gt; left, global_max);
    int right = dfs(root -&amp;gt; right, global_max);
    int sum = max(max(left, right) , 0) + root -&amp;gt; value;
    global_max = max(global_max, sum);
    return sum;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lca-problems&#34;&gt;LCA problems&lt;/h2&gt;

&lt;h3 id=&#34;lca-i&#34;&gt;LCA I&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root -&amp;gt; left, p, q);
        TreeNode* right = lowestCommonAncestor(root -&amp;gt; right, p, q);
        if (left &amp;amp;&amp;amp; right) {
            return root;
        }
        return left? left : right;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-of-bst&#34;&gt;LCA of BST&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return root;
        // p, q are in two sides or root is one of p, q
        } else if ((root-&amp;gt;val - p-&amp;gt;val) * (root-&amp;gt;val - q-&amp;gt;val) &amp;lt;= 0) {
            return root;
        //p,q are smaller than root =&amp;gt; both in left side
        } else if (root-&amp;gt;val &amp;gt; p-&amp;gt;val &amp;amp;&amp;amp; root -&amp;gt; val &amp;gt; q-&amp;gt;val) {
            return lowestCommonAncestor(root-&amp;gt;left, p, q);
        //both in right side
        } else {
            return lowestCommonAncestor(root-&amp;gt;right, p, q);            
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-ii&#34;&gt;LCA II&lt;/h3&gt;

&lt;p&gt;Give the treenode with parent pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//class TreeNodeP {
// public:
//  int value;
//  TreeNodeP* left;
//  TreeNodeP* right;
//  TreeNodeP* parent;
//  TreeNodeP(int v, TreeNodeP* p) 
//      : value(v), left(NULL), right(NULL), parent(p) {}
//};

class Solution {
private:
 int path_length(TreeNodeP* node) {
   int length = 0;
   while (node) {
     node = node -&amp;gt; parent;
     length++;
   }
   return length;
 }
 
 TreeNodeP* llc(TreeNodeP* small, TreeNodeP* large, int diff) {
   while (diff &amp;gt; 0) {
     large = large -&amp;gt; parent;
     diff--;
   }
   while (large != small) {
     large = large -&amp;gt; parent;
     small = small -&amp;gt; parent;
   }
   return large;
 }
 public:
  TreeNodeP* LCA(TreeNodeP* one, TreeNodeP* two) {
    int l1 = path_length(one);
    int l2 = path_length(two);
    if (l1 &amp;lt;= l2) {
      return llc(one, two, l2 - l1);
    } else {
      return llc(two, one, l1 - l2);
    }
  }
  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iii&#34;&gt;LCA III&lt;/h3&gt;

&lt;p&gt;Given two nodes in a binary tree, find their lowest common ancestor (the given two nodes are not guaranteed to be in the binary tree). Return null If any of the nodes is not in the tree. There is no parent pointer for the nodes in the binary tree. The given two nodes are not guaranteed to be in the binary tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  bool flag1 = false;
  bool flag2 = false;
  TreeNode* solve(TreeNode* root, TreeNode* one, TreeNode* two) {
  
    traversal(root, one, two);
    if (flag1 &amp;amp;&amp;amp; flag2) {
      return findLCA(root, one, two);
    } 
    return nullptr;
  }
  void traversal(TreeNode* root, TreeNode* one, TreeNode* two) {
    if (root == nullptr) {
      return;
    }
    if (root == one) {flag1 = true;}
    if (root == two) {flag2 = true;}
    traversal(root -&amp;gt; left, one, two);
    traversal(root -&amp;gt; right, one, two);
  }
  TreeNode* findLCA(TreeNode* root, TreeNode* one, TreeNode* two) {
   
    if (root == nullptr) {
      return nullptr;
    }
    
    if (root == one) {
      return root;
    }
    
    if (root == two) {
      return root;
    }
    
    auto left =  findLCA(root -&amp;gt; left,  one, two);
    auto right = findLCA(root -&amp;gt; right, one, two);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else if (left) {
      return left;
    } else if (right) {
      return right;
    } else {
      return nullptr;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lca-iv&#34;&gt;LCA IV&lt;/h3&gt;

&lt;p&gt;Give k nodes, find their CLA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* LCA(TreeNode* root, vector&amp;lt;TreeNode*&amp;gt; nodes) {
    if (root == nullptr) {
      return root;
    }
    
    for (int i = 0; i &amp;lt; nodes.size(); i++) {
      if (root == nodes[i]) {
        return root;
      }
    }
    
    auto left = LCA(root -&amp;gt; left, nodes);
    auto right = LCA(root -&amp;gt; right, nodes);
    
    if (left &amp;amp;&amp;amp; right) {
      return root;
    } else {
      return left? left : right;
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-if-cousins&#34;&gt;Check if cousins&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/check-two-nodes-cousins-binary-tree/&#34;&gt;Geeksforgeeks source&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool checkIfCousins(TreeNode* root, TreeNode* one, TreeNode* two) {
  
  bool res = false;
  helper(root, one, two, 0, res);
  return res;
}

//return target&#39;node level
//return -1 is not found
int helper(TreeNode* root, TreeNode* one, TreeNode* Two, int level, bool &amp;amp; res) {

  if (root == nullptr) {
    return -1;
  }

  if (root == one || root == two) {
    return level;
  }

  int left = helper(root-&amp;gt;left, one, two, level + 1, res);
  int right = helper(root-&amp;gt;right, one, two, level + 1, res);

  if (left == right &amp;amp;&amp;amp; left - 1 &amp;gt; level) {
    res = true;
  }
  return max(left, right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serialize-and-deserialize-binary-tree&#34;&gt;Serialize and deserialize binary tree&lt;/h2&gt;

&lt;h3 id=&#34;reconstruct-binary-tree-with-preorder-and-inorder&#34;&gt;Reconstruct Binary Tree With Preorder And Inorder&lt;/h3&gt;

&lt;p&gt;一棵树需要什么信息？需要知道什么是根，左子树和右子树分别又是什么。&lt;/p&gt;

&lt;p&gt;那么从这两种遍历之中可以获取什么信息？&lt;/p&gt;

&lt;p&gt;先序遍历： root | left subtree | right subtree&lt;/p&gt;

&lt;p&gt;中序遍历： left subtree | root | right subtree&lt;/p&gt;

&lt;p&gt;先序遍历的最左边，一定是根，但是无法找到左子树和右子树的分界点；但是可以通过找到根，从而从中序遍历中找到这个分界。&lt;/p&gt;

&lt;p&gt;解题步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;leftmost of preOrder must be root&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find position of root in inOrder =&amp;gt; need a hashtable to pre-store indices&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: left side of root is left subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in inorder: right side of root is right subtree&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;recursively solve the problem on left subtree and right subtree&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; pre) {
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    
    return helper(in, 0, in.size() - 1, pre, 0, table);
  }
  
  TreeNode* helper(const vector&amp;lt;int&amp;gt; &amp;amp; in, int in_left, int in_right, 
                   const vector&amp;lt;int&amp;gt; &amp;amp; pre, int pre_left,
                    unordered_map&amp;lt;int, int&amp;gt; table) {
                      
    if (in_left &amp;gt; in_right) {
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(pre[pre_left]);
    int index = table[root -&amp;gt; value];
    root -&amp;gt; left = helper(in, in_left, index - 1, pre, pre_left + 1, table);
    root -&amp;gt; right = helper(in, index + 1, in_right, pre, pre_left + index - in_left + 1, table);
    return root;                  
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-with-level-order&#34;&gt;Reconstruct with level order&lt;/h3&gt;

&lt;p&gt;level order 的第一个元素，一定是root。通过inorder找到root的位置，然后根据index的关系，分割左右子树。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; level) {
    map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
      table[in[i]] = i;
    }
    return helper(level, table);
  }
  TreeNode* helper(vector&amp;lt;int&amp;gt; level, map&amp;lt;int, int&amp;gt; table) {
    if (level.size() == 0) {
      return nullptr;
    }
    TreeNode* root = new TreeNode(level[0]);
    int index = table[root-&amp;gt;value];
    vector&amp;lt;int&amp;gt; left;
    vector&amp;lt;int&amp;gt; right;
    
    for (int i = 0; i &amp;lt; level.size(); i++) {
      if (table[level[i]] &amp;lt; index) {
        left.emplace_back(level[i]);
      } else if (table[level[i]] &amp;gt; index) {
        right.emplace_back(level[i]);
      }
    }
    root -&amp;gt; left = helper(left, table);
    root -&amp;gt; right = helper(right, table);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reconstruct-binary-search-tree-with-postorder-traversal&#34;&gt;Reconstruct Binary Search Tree With Postorder Traversal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
 public:
  TreeNode* reconstruct(vector&amp;lt;int&amp;gt; post) {
    //Post order -&amp;gt; [leftsubtree][rightsubtree]root =&amp;gt; determine the position of root
    //In   order -&amp;gt; [left]root[right] =&amp;gt;recursively find left and right parts
    vector&amp;lt;int&amp;gt; in(post);
    sort(in.begin(), in.end());
    unordered_map&amp;lt;int, int&amp;gt; table;
    for (int i = 0; i &amp;lt; in.size(); i++) {
        table[in[i]] = i;
    }
    return helper(in, post, table, post.size() - 1, 0, in.size() - 1);
  }
  
  TreeNode* helper(vector&amp;lt;int&amp;gt; in, vector&amp;lt;int&amp;gt; post, unordered_map&amp;lt;int, int&amp;gt; &amp;amp; table,
                    int post_right, int in_left, int in_right) {
  
    if (in_left &amp;gt; in_right){
      return nullptr;
    }
    
    TreeNode* root = new TreeNode(post[post_right]);
    int index = table[root -&amp;gt; value];
    
    root -&amp;gt; right = helper(in, post, table, post_right - 1, index + 1, in_right);
    root -&amp;gt; left = helper(in, post, table, post_right - 1 - (in_right - index), in_left, index - 1);
    return root;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string order;
        inorderDFS(root, order);
        return order;
    }
    
    inline void inorderDFS(TreeNode* root, string&amp;amp; order) {
        if (!root) return;
        char buf[4];
        memcpy(buf, &amp;amp;(root-&amp;gt;val), sizeof(int)); //burn the int into 4 chars
        for (int i=0; i&amp;lt;4; i++) order.push_back(buf[i]);
        inorderDFS(root-&amp;gt;left, order);
        inorderDFS(root-&amp;gt;right, order);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int pos = 0;
        return reconstruct(data, pos, INT_MIN, INT_MAX);
    }
    
    inline TreeNode* reconstruct(const string&amp;amp; buffer, int&amp;amp; pos, int minValue, int maxValue) {
        if (pos &amp;gt;= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.
        
        int value;
        memcpy(&amp;amp;value, &amp;amp;buffer[pos], sizeof(int));
        if (value &amp;lt; minValue || value &amp;gt; maxValue) return NULL;
        
        TreeNode* node = new TreeNode(value);
        pos += sizeof(int);
        node-&amp;gt;left = reconstruct(buffer, pos, minValue, value);
        node-&amp;gt;right = reconstruct(buffer, pos, value, maxValue);
        return node;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-doubly-linked-list-from-a-ternary-tree&#34;&gt;Create a Doubly Linked List from a Ternary Tree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/create-doubly-linked-list-ternary-ree/&#34;&gt;Question source&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;h3 id=&#34;difference-between-dfs-and-bfs&#34;&gt;Difference between DFS and BFS&lt;/h3&gt;

&lt;p&gt;DFS using stacks, and BFS using queues if Non-Recursion&lt;/p&gt;

&lt;h3 id=&#34;difference-between-recursion-and-non-recursion&#34;&gt;Difference between Recursion and Non-Recursion&lt;/h3&gt;

&lt;p&gt;Recursion is dangerous when memory resource is limited: stack may overflow;
However Non-Recursion method occupies more space&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>